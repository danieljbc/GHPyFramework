{
    "403": [],
    "309": [],
    "3644": [],
    "7": [
        "I vote not final.\nIf it were final then it would be impossible to extend Observable to add operators and still interoperate with other code that uses Observable.\n",
        "Agreed\n",
        "We have decided to not make it final.\n\nBut we also have changed it from being abstract to a normal concrete class.\n\nThe 'subscribe' implementation is passed in via a protected constructor or using Observable.create(Func1)\n"
    ],
    "4505": [],
    "1621": [],
    "3234": [],
    "19": [
        "Interesting quote from that page\n\"If you do not use the overload which takes a scheduler as an argument, Rx will pick a default scheduler by using the principle of least concurrency.  This means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen.  For example, for operators returning an observable with a finite and small number of messages, Rx calls Immediate.  For operators returning a potentially large or infinite number of messages, CurrentThread is called. For operators which use timers, ThreadPool is used.\"\n",
        "The docs say \"least amount of concurrency\" which I interpreted to mean that if the amount of work is unknown that it would it default to immediate.  We could still manipulate the defaults and probably ignore Schedulers passed in through a strategy.\n",
        "How would an operator know how many messages it is going to have? Only the origin Observable could know that - a given operator along the chain won't know so how does this get accomplished?\n",
        "I guess this would mean that things like \"toObservable(1, 2, 3, 4)\" are a known thing and can be done immediately without a thread, but merging 4 unknown sequences can't be known.\n\nObviously when Timers are used a Thread of some kind is needed (java.util.Timer or another implementation like this: https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java).\n\nFor the majority of cases though where the \"cost\" of the observable sequence is unknown I don't know that I like automatically spawning them off on threads. It has worked well for the Netflix API to leave that choice to the origin of the observable (to be synchronous or asynchronous, one thread or many, etc).\n\nThe introduction of Schedulers makes perfect sense when an app is dealing with data structures, their own synchronous IO operations or CPU bound computations, but it becomes awkward when consuming from a 3rd party API exposing Observables who can and will make their own choice about being synchronous or asynchronous.\n\nIn fact, that's been a huge part of the draw to Rx is that the API doesn't need to change when the backend implementations moves between synchronous and asynchronous for whatever reason it may choose to do so.\n\nIf the Observable is already asynchronous it would be inefficient to spin up another thread that in turn blocks on an async call.\n\nOther than documentation on the API calls that return Observables is there a better way to handle that scenario?\n\nI can imagine a scenario where some apps (such as the Netflix API) may want to disable any use of Schedulers so the origin retains control since Rx has allowed us to decouple the writing of business logic from the decisions of concurrency.\n\nBefore flaming me ... I DO like schedulers, it's very powerful and we will definitely get them added, I just have some questions about balancing that power (and inevitable inefficiencies of making poor scheduler choices) with the elegant simplicity of Rx Observables without them where concurrency is not a thought - everything is just asynchronous.\n\nI'm interested in all of your perspectives so please chime in.\n",
        "Yes, I think a strategy pattern will be needed to accomplish the Netflix API use case.\n",
        "Some thoughts while working on the design of this:\n- The Scheduler interface should be capable of supporting different sources of concurrency such as Executors, Threads, Actors, EventLoops\n- We should be capable of supporting rxjava-contrib modules with new types of Schedulers such as for Akka/Scala Actors\n- We need the ability (via plugins probably) of a system to override or prevent usage of Schedulers where they want. For example, if a system doesn't want client code starting threads they should be able to intercept and ignore or throw UnsupportedOperationException.\n",
        "Sections 6.9 through 6.12 of the Rx Design Guidelines PDF (http://go.microsoft.com/fwlink/?LinkID=205219) should be read by anyone involved in Schedulers design and implementation.\n",
        "Good video ... thanks for the link.\n",
        "First round of Schedulers implementation committed via pull request https://github.com/Netflix/RxJava/pull/225 contribued by @mairbek.\n\nIt implements ObserveOn (https://github.com/Netflix/RxJava/issues/11) and SubscribeOn (https://github.com/Netflix/RxJava/issues/12).\n",
        "Open questions:\n\n### 1) Scheduler Time\n\nWe're not using the Scheduler.now value anywhere, should we be? or is that only for the Virtual scheduler used for testing?\n\n### 2) Use of SubscribeOn vs Scheduler.scheduler\n\nI'm trying to understand how operator overloads should use Scheduler.\n\nHere is a potential implementation: https://github.com/Netflix/RxJava/pull/227 and another https://github.com/Netflix/RxJava/pull/226\n\nI have not yet found C# source code or documentation that clarifies this.\n\nI have also had feedback (that I agree with) that it this is clearer:\n\n``` java\nmerge(o1, o2).subscribeOn(scheduler)\n```\n\nthan this\n\n``` java\nmerge(o1, o2, scheduler)\n```\n\nSo is there anything different between this? \n\n### 3) Multiple Schedulers in Sequence\n\nI'm trying to understand how a sequence should work when multiple `subscribeOn` operators are applied at different steps of a sequence and it is unclear to me  how the unit test below should behave.\n\nCan someone with an Rx.Net environment setup implement a test similar to this from Java and tell me the output?\n\n``` java\n@Test\n    public void testMixedSchedulers() throws InterruptedException {\n        final String mainThreadName = Thread.currentThread().getName();\n\n        Observable<String> o = Observable.<String> create(new Func1<Observer<String>, Subscription>() {\n\n            @Override\n            public Subscription call(Observer<String> observer) {\n\n                System.out.println(\"Origin observable is running on: \" + Thread.currentThread().getName());\n\n                assertFalse(Thread.currentThread().getName().equals(mainThreadName));\n                assertTrue(\"Actually: \" + Thread.currentThread().getName(), Thread.currentThread().getName().startsWith(\"RxIOThreadPool\"));\n\n                observer.onNext(\"one\");\n                observer.onNext(\"two\");\n                observer.onNext(\"three\");\n                observer.onCompleted();\n\n                return Subscriptions.empty();\n            }\n        }).subscribeOn(Schedulers.threadPoolForIO()); // subscribe to the source on the IO thread pool\n\n        // now merge on the CPU threadpool\n        o = Observable.<String> merge(o, Observable.<String> from(\"four\", \"five\"))\n                .subscribeOn(Schedulers.threadPoolForComputation())\n                .map(new Func1<String, String>() {\n\n                    @Override\n                    public String call(String v) {\n                        // opportunity to see what thread the merge is running on\n                        System.out.println(\"Merge is running on: \" + Thread.currentThread().getName());\n                        return v;\n                    }\n\n                });\n\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final AtomicReference<RuntimeException> onError = new AtomicReference<RuntimeException>();\n\n        // subscribe on a new thread\n        o.subscribe(new Observer<String>() {\n\n            @Override\n            public void onCompleted() {\n                System.out.println(\"==> received onCompleted\");\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Exception e) {\n                System.out.println(\"==> received onError: \" + e.getMessage());\n                onError.set((RuntimeException) e);\n                latch.countDown();\n            }\n\n            @Override\n            public void onNext(String v) {\n                System.out.println(\"==> Final subscribe is running on: \" + Thread.currentThread().getName());\n                System.out.println(\"==> onNext: \" + v);\n\n            }\n        }, Schedulers.newThread());\n\n        // wait for the above to finish or blow up if it's blocked\n        latch.await(5, TimeUnit.SECONDS);\n    }\n```\n\nOf course Rx.Net doesn't have the IO and CPU thread pools ... those are just helper methods to Executors which would be 2 separate threadpools for different work types so you'll need to adjust that.\n",
        "I received the following feedback that will require a breaking change to the Scheduler interface:\n\n---\n\n> It is essential to be able to access the scheduler inside the action to recursively schedule yourself. Just having a Func1<Subscription is not very useful since there is no opportunity to return the subscription before the function terminates.\n\n``` C#\nInterface IScheduler\n{\nSchedule<TState>(TState s, Func<IScheduler, TState, IDisposable> a)          \n               Schedule<TState>(TState s, DateTimeOffset d, Func<IScheduler, TState, IDisposable> a).\n               Schedule<TState>(TState s, TimeSpan t, Func<IScheduler, TState, IDisposable> a)\n}\n```\n\n> You want to be able to write something like this\n\n``` C#\nvoid Main()\n{\n     var repeat = Observable.Create<int>(observer =>\n     {\n         while(true) observer.OnNext(42);\n         return () => {};\n     });\n\n     //var dispose = repeat.Subscribe(Console.WriteLine);\n\n     var dispose = ObservableEx.ToObservable(NewThreadScheduler.Default)\n                  .Select(_ => 42)\n                  .Subscribe(x => Console.WriteLine(x));\n\n     Console.ReadLine();\n     dispose.Dispose();\n     Console.WriteLine(\"Bye\");\n}\n\nstatic class ObservableEx\n{\n     public static IObservable<Unit> ToObservable(this IScheduler scheduler)\n     {\n    return Observable.Create<Unit>(observer =>\n         {\n              return scheduler.ScheduleAsync(async (_scheduler, token) =>\n              {\n                  while(!token.IsCancellationRequested)\n                  {\n                     observer.OnNext(Unit.Default);\n                       await _scheduler.Sleep(TimeSpan.FromSeconds(2));\n                   }\n              });\n         });\n     }\n}\n```\n",
        "Here is another use case:\n\n``` C#\nvar scheduler = TaskPoolScheduler.Default;\n\nvar xs = Observable.Generate\n     ( 0\n     , i=>true\n     , i=>i+1\n     , i=>i\n     , i=>TimeSpan.FromSeconds(1)\n     , scheduler\n     );\n\nvar ys = Observable.Create<int>(observer =>\n{\n     return scheduler.ScheduleAsync(async (_scheduler, cancel) =>\n     {\n         await _scheduler.Yield();\n         for(var i = 0; !cancel.IsCancellationRequested; i++)\n         {\n              observer.OnNext(i);\n              await _scheduler.Sleep(TimeSpan.FromSeconds(1));\n         }\n     });\n});\n\n//var dispose = ys.Timestamp().Subscribe(x => Console.WriteLine(x.ToString()));\nvar dispose = ys.Timestamp().DumpLive().Subscribe();\nConsole.ReadLine();\ndispose.Dispose();\nConsole.WriteLine(\"disposed\");\nConsole.ReadLine();\n```\n",
        "Note that I'm unavailable to work on this until the 15th. Anyone else who wants to jump in and determine the changes needed based on this feedback please do. \n",
        "Here is some simple code I was playing with to prove out the use of `subscribeOn` from an \"Observable API\" and it appears to be working as we want and from what I can tell it is conforming to the Rx contract and not injecting concurrency where it shouldn't.\n\nAnyone find faults in this?\n\n``` groovy\nimport rx.*\nimport rx.concurrency.Schedulers\n\n/*\n * ******** PRODUCER CODE ******** \n * This is the \"Observable API\"\n */\n\nObservable<Video> getVideos() {\n    return Observable.create({\n        observer ->\n        Thread.sleep(200); // simulate network traffic\n        // 10 videos are fetched in a batch and emitted\n        observer.onNext(new Video(1));\n        observer.onNext(new Video(2));\n        observer.onNext(new Video(3));\n        observer.onNext(new Video(4));\n        observer.onNext(new Video(5));\n        observer.onNext(new Video(6));\n        observer.onNext(new Video(7));\n        observer.onNext(new Video(8));\n        observer.onNext(new Video(9));\n        observer.onNext(new Video(10));\n        observer.onCompleted();\n    })\n}\n\n\nclass Video {\n    final int id;\n    public Video(int id) {\n        this.id = id;\n    }\n\n\n    Observable<Rating> getRating() {\n        return Observable.create({\n            observer ->\n            Thread.sleep(200); // simulate network traffic\n            observer.onNext(new Rating(id));\n            observer.onCompleted();\n        }).subscribeOn(Schedulers.threadPoolForIO())\n    }\n\n    Observable<Bookmark> getBookmark() {\n        return Observable.create({\n            observer ->\n            Thread.sleep(200); // simulate network traffic\n            observer.onNext(new Bookmark(id));\n            observer.onCompleted();\n        }).subscribeOn(Schedulers.newThread())\n    }\n}\n\nclass Rating {\n    final String value;\n    public Rating(int id) {\n        this.value = \"ratingFor_\" + id;\n    }\n}\n\nclass Bookmark {\n    final String value;\n    public Bookmark(int id) {\n        this.value = \"bookmarkFor_\" + id;\n    }\n}\n\n\n\n/*\n * ******** CONSUMER CODE ********\n * This is a client consuming the \"Observable API\"\n */\nlong start = System.currentTimeMillis();\ngetVideos().mapMany({\n    Video video ->\n    // fetch and transform bookmark\n    Observable ob = video.getBookmark().map({b -> \n        return \"transformed-\" + b.value;\n    })\n\n    // fetch ratings and zip together with bookmark\n    return Observable.zip(ob, video.getRating(), {b, r -> return [b.value, r.value]})\n    .map({ tuple ->\n        // combine all metadata for a single Video\n        return [\"id\" : video.id, \"bookmark\" : tuple[0], \"rating\": tuple[1]]\n    })\n}).forEach({\n    videoMap ->\n    System.out.println(\"Video: \" + videoMap[\"id\"] + \"   bookmark: \" + videoMap[\"bookmark\"] + \"   rating: \" + videoMap[\"rating\"] + \" Thread: \" + Thread.currentThread());\n})\n\nlong end = System.currentTimeMillis();\n\nSystem.out.println(\"time: \" + (end-start))\n```\n\nOutput is:\n\n```\nVideo: 5   bookmark: transformed-bookmarkFor_5   rating: ratingFor_5 Thread: Thread[RxIOThreadPool-5,5,main]\nVideo: 9   bookmark: transformed-bookmarkFor_9   rating: ratingFor_9 Thread: Thread[RxIOThreadPool-9,5,main]\nVideo: 10   bookmark: transformed-bookmarkFor_10   rating: ratingFor_10 Thread: Thread[RxIOThreadPool-10,5,main]\nVideo: 2   bookmark: transformed-bookmarkFor_2   rating: ratingFor_2 Thread: Thread[RxIOThreadPool-2,5,main]\nVideo: 4   bookmark: transformed-bookmarkFor_4   rating: ratingFor_4 Thread: Thread[RxIOThreadPool-4,5,main]\nVideo: 8   bookmark: transformed-bookmarkFor_8   rating: ratingFor_8 Thread: Thread[RxIOThreadPool-8,5,main]\nVideo: 6   bookmark: transformed-bookmarkFor_6   rating: ratingFor_6 Thread: Thread[RxIOThreadPool-6,5,main]\nVideo: 3   bookmark: transformed-bookmarkFor_3   rating: ratingFor_3 Thread: Thread[RxIOThreadPool-3,5,main]\nVideo: 7   bookmark: transformed-bookmarkFor_7   rating: ratingFor_7 Thread: Thread[RxIOThreadPool-7,5,main]\nVideo: 1   bookmark: transformed-bookmarkFor_1   rating: ratingFor_1 Thread: Thread[RxIOThreadPool-1,5,main]\ntime: 659\n```\n",
        "I forgot to upload the new Javadocs ... will do so once I'm at my laptop. Sorry about that. \n",
        "@mttkay I found wifi ... uploaded javadocs for 0.8.0.\n\nAlso, the example from @mairbek was incorporated into unit tests here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/concurrency/TestSchedulers.java#L255\n",
        "I believe we're pretty comfortable with the `Schedulers` implementation and interface as of 0.11/0.12 so closing this out.\n",
        "@benjchristensen I'm left wondering if or how question 3) from your comment (https://github.com/Netflix/RxJava/issues/19#issuecomment-15979582) was addressed or whether this is still an open question?\n\nIn our app we haven't quite figured out yet which layer should be responsible for scheduling an observable. If we schedule on the service layer--which would make sense when trying to make client code oblivious as to whether code runs concurrently or not--then what does that mean for reusability of observables? Would, say, service A be able to take an observable from service B which has already been scheduled by B, transform and re-schedule it?\n\nWith the pre-0.8 Schedulers, this is not possible, since subscribeOn/observeOn will wrap as many times as you call these methods.\n",
        "I think the JavaDocs haven't been updated yet: http://netflix.github.io/RxJava/javadoc/rx/Scheduler.html\n\nIs there any documentation / examples around what the state parameter is used for? Looking at the existing schedulers, I only ever see it being passed through, so I wonder what this accomplishes?\n",
        "There's also [this video](http://channel9.msdn.com/blogs/j.van.gogh/controlling-concurrency-in-rx) explaining the motivation behind introducing schedulers in Rx.\n",
        "Concerning 1), I guess it will come in handy when implementing #90 (or clock-like observables in general), at least if I understand this correctly. I'm currently figuring out how working with the schedulers feels by playing around with an implementation for #74, which also requires a \"clock\", though it doesn't seem to require the current time).\n",
        "Here's an example (by @mairbek) using state: https://github.com/Netflix/RxJava/pull/229#issuecomment-16115941\n"
    ],
    "20": [
        "Done in pull request #257 \n"
    ],
    "2642": [],
    "6362": [],
    "23": [
        "This operation requires a join-pattern sub-framework to be created (rx.joins). Additionally, due to method arities, this might require Action4...Action9, ActionN classes (I have these in pull #505) if decided.\nHowever, I don't quite understand the join patterns as most of the Rx.NET classes are internal and without documentation; I can convert it to java but no idea what tests to create for them.\n"
    ],
    "25": [],
    "5746": [],
    "3690": [],
    "32": [],
    "34": [],
    "5660": [],
    "575": [],
    "41": [
        "I think this issue can be closed.\n"
    ],
    "1265": [],
    "43": [
        "Here is the test case @mattrjacobs is referring to:\n\n```\n    @Test\n    public void testFinallyError() {\n        Action0 errorAction = new Action0() {\n\n            @Override\n            public void call() {\n                throw new RuntimeException(\"boo\");\n            }\n        };\n\n        try {\n            Observable.create(finallyDo((Observable.toObservable(\"foo\")), errorAction)).subscribe(aObserver);\n            fail();\n        } catch (Exception e) {\n            // pass\n        }\n    }\n```\n",
        "We will address the exception handling in another issue and will close this one out now.  Thank you very much @abliss for you contribution!!\n",
        "@abliss Pull Request https://github.com/Netflix/RxJava/pull/196 was manually merged via @joshgord's Pull Request  https://github.com/Netflix/RxJava/pull/222.  @joshgord is working on unit tests of Exceptions getting thrown by operation in finally block.  Once that's done, this issue will be closed.\n"
    ],
    "2860": [],
    "4601": [],
    "604": [],
    "3694": [],
    "4631": [],
    "3267": [],
    "144": [],
    "55": [
        "It seems like `Interval` shares logic with the `Timer` from issue #92.\n\n`Interval` could be implemented as a [`Timer` call](http://msdn.microsoft.com/en-us/library/hh229652%28v=vs.103%29.aspx) with `dueTime == 0`.\n",
        "Yes, every new subscriber should start the Observable from the beginning. I have tried to make sure that's the case everywhere but apparently missed this one.\n\nIf an Observable does not want that behavior that is what the various `multicast` options are for such as `publish`, `replay`, `cache` etc.\n",
        "Merged in https://github.com/Netflix/RxJava/pull/379 so closing again.\n",
        "Sure, as soon as Timer is implemented or schedulers can do periodic scheduling, the implementation of `Interval` will get a lot simpler.\n",
        "Actually, I'm not sure whether `interval` itself should or shouldn't support this. - However, you should always be able to use `publish`/`connect`. If that doesn't work, then there's definitely something wrong. I can go check that later. I probably didn't think of that when implementing it...\n",
        "What does Rx.NET do when you wait a bit before subscribing the second time?\n\nWill it do this?\n\n```\nsubscriber 1 got 0\nsubscriber 1 got 1\nsubscriber 1 got 2\nsubscriber 2 got 2\nsubscriber 1 got 3\nsubscriber 2 got 3\nsubscriber 1 got 4\nsubscriber 2 got 4\n```\n\nOr will it still start at 0 with subscriber 2?\n",
        "I added a first test for that use case here: https://github.com/jmhofer/RxJava/commit/2fe6da751957b41dd1b89083ec3aaed940042065\n\nIt fails, as expected from your comment above.\n",
        "The Rx Design Guidelines (5.10) say:\n\n> As many observable sequences are cold (see cold vs. hot on Channel 9), each subscription will have a separate set of side-effects. Certain situations require that these side-effects occur only once. The Publish operator provides a mechanism to share subscriptions by broadcasting a single subscription to multiple subscribers.\n\nSo I guess it would be okay for the second subscriber to always start at 0 too when subscribing to the same observable later (and not using `publish`/`connect`)?\n",
        "There are probably other operators that are affected by this, too, because multiple subscribers are currently normally not getting tested by the unit tests...\n",
        "Great, thanks. This means that my PR above should fix this.\n",
        "Is the `interval` operator intended to work if there are several subscribers? It looks as if this was simply forgotten...\n",
        "I just tried it out in C#. This code:\n\n```\nstatic void Main() {\n    var oneNumberPerSecond = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);\n    oneNumberPerSecond.Subscribe(\n    x => Console.WriteLine(\"subscriber 1 got \" + x)\n    );\n    oneNumberPerSecond.Subscribe(\n    x => Console.WriteLine(\"subscriber 2 got \" + x)\n    );\n    Console.ReadLine();\n}\n```\n\nproduces this output:\n\n```\nsubscriber 2 got 0\nsubscriber 1 got 0\nsubscriber 2 got 1\nsubscriber 1 got 1\nsubscriber 2 got 2\nsubscriber 1 got 2\nsubscriber 2 got 3\nsubscriber 1 got 3\nsubscriber 2 got 4\nsubscriber 1 got 4\n```\n\nSo I think we should update the RxJava version to support multiple subscribers.\n",
        "Compare to Java. Code:\n\n```\npublic static void main(String[] args) {\n    Observable<Long> oneNumberPerSecond = Observable.interval(1, TimeUnit.SECONDS).take(5);\n    oneNumberPerSecond.subscribe(new Action1<Long>() {\n        public void call(Long x) {\n            System.out.println(\"subscriber 1 got \" + x);\n        }           \n    });\n    oneNumberPerSecond.subscribe(new Action1<Long>() {\n        public void call(Long x) {\n            System.out.println(\"subscriber 2 got \" + x);\n        }           \n    });     \n}\n```\n\nOutput:\n\n```\nsubscriber 1 got 0\nsubscriber 2 got 1\nsubscriber 1 got 2\nsubscriber 2 got 3\nsubscriber 1 got 4\nsubscriber 2 got 5\nsubscriber 1 got 6\nsubscriber 2 got 7\nsubscriber 1 got 8\nsubscriber 2 got 9\n```\n\nI think this will be used a lot for small examples and so it should be fixed soon. @benjchristensen could you please reopen this issue?\n",
        "Here's another  example from C#:\n\n```\n    static void Main() {\n        var oneNumberPerSecond = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);\n        var watch = new Stopwatch();\n        watch.Start();\n\n        Thread.Sleep(2200);\n\n        Console.WriteLine(\"subscriber 1 subscribes at t=\" + watch.ElapsedMilliseconds);\n        oneNumberPerSecond.Subscribe(\n            x => Console.WriteLine(\"subscriber 1 got \" + x + \" at t=\" + watch.ElapsedMilliseconds)\n        );\n\n        Thread.Sleep(1300);\n\n        Console.WriteLine(\"subscriber 2 subscribes at t=\" + watch.ElapsedMilliseconds);\n        oneNumberPerSecond.Subscribe(\n            x => Console.WriteLine(\"subscriber 2 got \" + x + \" at t=\" + watch.ElapsedMilliseconds)\n        );\n\n        Console.ReadLine();\n    }\n```\n\noutputs:\n\n```\nsubscriber 1 subscribes at t=2200\nsubscriber 1 got 0 at t=3322\nsubscriber 2 subscribes at t=3615\nsubscriber 1 got 1 at t=4319\nsubscriber 2 got 0 at t=4642\nsubscriber 1 got 2 at t=5329\nsubscriber 2 got 1 at t=5643\nsubscriber 1 got 3 at t=6331\nsubscriber 2 got 2 at t=6643\nsubscriber 1 got 4 at t=7344\nsubscriber 2 got 3 at t=7655\nsubscriber 2 got 4 at t=8656\n```\n\nSo each subscriber starts at 0.\n"
    ],
    "694": [],
    "56": [],
    "816": [],
    "3318": [],
    "2825": [],
    "1904": [],
    "6801": [],
    "4586": [],
    "2820": [],
    "3791": [],
    "5457": [],
    "72": [],
    "5578": [],
    "3272": [],
    "927": [],
    "80": [],
    "5454": [],
    "83": [],
    "851": [],
    "88": [],
    "3393": [],
    "1063": [],
    "6582": [],
    "95": [
        "API surface: This method in Rx.NET has about 48 overloads, do we need all of them (0-11 arg Action, 0-11 arg Funcion, x2 with scheduler overloads)?\n\nSchedulers: In Rx.NET the scheduler-less overloads use the SchedulerDefaults.AsyncConversions which in turn is a DefaultScheduler. So do we use the Schedulers.threadPoolForComputation() directly or introduce a Schedulers.threadPoolForAsyncConversions()?\n"
    ],
    "100": [],
    "103": [
        "Included in https://github.com/Netflix/RxJava/pull/331 via commit https://github.com/jmhofer/RxJava/commit/ac6a0a1ad8edd25b3c17a6fbca6960e9bcdda020\n"
    ],
    "104": [
        "Simple performance test to demonstrate performance issue:\n\n``` java\n\npackage testing;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport rx.observables.Observable;\nimport rx.observables.Observer;\nimport rx.util.Func1;\n\npublic class PerformanceTest {\n\n    public static void main(String[] args) {\n        PerformanceTest test = new PerformanceTest();\n        Integer[] values = new Integer[100001];\n        for (int i = 0; i < values.length; i++) {\n            values[i] = i;\n        }\n\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"-------------------------------\");\n            //            test.runFunctionExecutionTest(values);\n            test.runCompositionTest(values);\n            test.runNonCompositionalTestWithDirectLoop(values);\n            test.runNonCompositionalTestWithArrayOfFunctions(values);\n        }\n    }\n\n    public void runCompositionTest(Integer[] values) {\n        System.out.println(\"runCompositionTest\");\n\n        final AtomicInteger onNextSum = new AtomicInteger(0);\n        final long start = System.nanoTime();\n\n        MathFunction m = new MathFunction();\n        // 50 levels of composition (same function so that's not the cost)\n        Observable.from(values)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .subscribe(new TestObserver(onNextSum, start));\n    }\n\n    public void runNonCompositionalTestWithDirectLoop(Integer[] values) {\n        System.out.println(\"runNonCompositionalTestWithDirectLoop\");\n\n        final AtomicInteger onNextSum = new AtomicInteger(0);\n        final long start = System.nanoTime();\n        final MathFunction m = new MathFunction();\n\n        Observable.from(values).map(new Func1<Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t1) {\n                // iterate the 50 times here in a loop rather than via composition\n                for (int i = 0; i < 50; i++) {\n                    t1 = m.call(t1);\n                }\n                return t1;\n            }\n\n        }).subscribe(new TestObserver(onNextSum, start));\n\n    }\n\n    public void runNonCompositionalTestWithArrayOfFunctions(Integer[] values) {\n        System.out.println(\"runNonCompositionalTestWithArrayOfFunctions\");\n\n        final AtomicInteger onNextSum = new AtomicInteger(0);\n        final long start = System.nanoTime();\n        final MathFunction m = new MathFunction();\n        final Func1[] functionCalls = new Func1<?, ?>[50];\n        for (int i = 0; i < 50; i++) {\n            functionCalls[i] = m;\n        }\n\n        Observable.from(values).map(new Func1<Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t1) {\n                // iterate the 50 times here in a loop rather than via composition\n                for (Func1<Integer, Integer> f : functionCalls) {\n                    t1 = f.call(t1);\n                }\n                return t1;\n            }\n\n        }).subscribe(new TestObserver(onNextSum, start));\n\n    }\n\n    private static final class TestObserver implements Observer<Integer> {\n        private final AtomicInteger onNextSum;\n        private final long start;\n\n        private TestObserver(AtomicInteger onNextSum, long start) {\n            this.onNextSum = onNextSum;\n            this.start = start;\n        }\n\n        @Override\n        public void onNext(Integer i) {\n            onNextSum.addAndGet(i);\n        }\n\n        @Override\n        public void onError(Exception e) {\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onCompleted() {\n            long end = System.nanoTime();\n            System.out.println(\"Sum: \" + onNextSum.get() + \" Time: \" + ((double) (end - start)) / 1000 / 1000 + \"ms\");\n        }\n    }\n\n    private static class MathFunction implements Func1<Integer, Integer> {\n\n        @Override\n        public Integer call(Integer t1) {\n            return t1 + 1;\n        }\n\n    }\n\n}\n\n```\n",
        "On existing code the composition of 50 'map' calls takes ~370ms whereas a single call with a list of the same 50 functions takes ~23ms.\n\n```\nrunCompositionTest\nSum: 710082754 Time: 371.601ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 23.814ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 23.925ms\n-------------------------------\nrunCompositionTest\nSum: 710082754 Time: 383.391ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 24.577ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 24.65ms\n-------------------------------\nrunCompositionTest\nSum: 710082754 Time: 376.443ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 24.587ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 26.131ms\n```\n",
        "Playing with different things I got the following numbers:\n\n```\n\n>>> Statically typed <<<\n\nWithout chaining:\n\nSum: 710082754 Time: 130.683ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 21.011ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 20.84ms\n\n\nWith chaining (composition collapsing):\n\nSum: 710082754 Time: 28.787ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 19.525ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 19.175ms\n\n\n>>> Dynamically typed <<<\n\nWhen going via generic Functions.execute even with chained sequence:\n\nrunCompositionTest\nSum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 31.591ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 38.093ms\nrunCompositionTest\n\n\nWith Function memoization so we only pay dynamic price during sequence setup, not in onNext:\n\n\nUsing ArrayList\n\nrunCompositionTest\nSum: 710082754 Time: 27.078ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 18.911ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 18.852ms\n\n\nUsing LinkedBlockingQueue\n\nrunCompositionTest\nSum: 710082754 Time: 46.532ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 18.946ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 18.746ms\n\n```\n",
        "By adding chaining (to collapse composition into a single observable with chain of functions) and improving the handling of dynamic function calls through memoization I get this:\n\n```\nrunCompositionTest\nSum: 710082754 Time: 47.184ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 17.869ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 26.528ms\n-------------------------------\nrunCompositionTest\nSum: 710082754 Time: 47.578ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 21.692ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 18.177ms\n-------------------------------\nrunCompositionTest\nSum: 710082754 Time: 47.93ms\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 18.821ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 20.064ms\n```\n\nI can get the composed version down to around 25-28ms if I use ArrayList but I need to be thread-safe in this case so am using ConcurrentLinkedQueue which adds a little time, but it's still far faster than before.\n\nSame code now takes ~48ms instead of ~370ms.\n",
        "Pretty significant performance improvements came from improved handling of function execution - in particular memoizing the logic for constructing a function, particularly dynamic ones.\n\nThe long if/then conditional block for handling the many different Func/Action/language functions was very expensive in sequence with lots of data.\n\nThis was fixed in https://github.com/Netflix/RxJava/pull/106\n\nI'm still testing the potential gains from chaining.\n",
        "While playing with chaining I found that the actual performance issues were the dynamic function construction/lookup and concurrency/synchronization costs - not the depth of stack.\n\nHere is code that demonstrates that the stack depth is not a problem for performance. In fact, the composed version performs better than the loops:\n\n``` java\n\npackage testing;\n\nimport java.util.ArrayList;\nimport java.util.concurrent.Callable;\n\nimport rx.util.Func1;\n\npublic class TestChainPerformance {\n\n    public static void main(String[] args) {\n        TestChainPerformance test = new TestChainPerformance();\n        Integer[] values = new Integer[100001];\n        for (int i = 0; i < values.length; i++) {\n            values[i] = i;\n        }\n\n        try {\n            for (int i = 0; i < 100; i++) {\n                System.out.println(\"-------------------------------\");\n                test.runChained(values);\n                test.runComposed(values);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void runComposed(final Integer[] values) throws Exception {\n        long start = System.nanoTime();\n\n        Callable<Integer> c = null;\n        for (int i = 0; i < 250; i++) {\n            final Callable<Integer> previousC = c;\n            c = new Callable<Integer>() {\n\n                @Override\n                public Integer call() throws Exception {\n                    MathFunction f = new MathFunction();\n                    int sum = 0;\n                    for (int v : values) {\n                        sum += f.call(v);\n                    }\n                    if (previousC != null) {\n                        sum += previousC.call();\n                    }\n                    return sum;\n                }\n\n            };\n        }\n\n        int sum = c.call();\n\n        long end = System.nanoTime();\n        System.out.println(\"Composed => Sum: \" + sum + \" Time: \" + ((double) (end - start)) / 1000 / 1000 + \"ms\");\n    }\n\n    public void runChained(Integer[] values) {\n        long start = System.nanoTime();\n        int sum = 0;\n\n        ArrayList<Func1<Integer, Integer>> functions = new ArrayList<Func1<Integer, Integer>>();\n        for (int i = 0; i < 250; i++) {\n            functions.add(new MathFunction());\n        }\n\n        for (int v : values) {\n            for (Func1<Integer, Integer> f : functions) {\n                sum += f.call(v);\n            }\n        }\n\n        long end = System.nanoTime();\n        System.out.println(\"Iterative => Sum: \" + sum + \" Time: \" + ((double) (end - start)) / 1000 / 1000 + \"ms\");\n    }\n\n    private static class MathFunction implements Func1<Integer, Integer> {\n\n        @Override\n        public Integer call(Integer t1) {\n            return t1 + 1;\n        }\n\n    }\n}\n```\n\nThe performance numbers on my machine are\n\n```\nIterative => Sum: 202017114 Time: 227.288ms\nComposed => Sum: 202017114 Time: **172.856ms**\n-------------------------------\nIterative => Sum: 202017114 Time: 230.235ms\nComposed => Sum: 202017114 Time: **173.917ms**\n-------------------------------\nIterative => Sum: 202017114 Time: 226.337ms\nComposed => Sum: 202017114 Time: **172.932ms**\n```\n\nThat is with JDK 7. JDK 6 is slower but similar difference between the two.\n\nDue to this I'm abandoning pursuit of chaining as a performance enhancement and focusing on functions and synchronization.\n",
        "In pull request https://github.com/Netflix/RxJava/pull/106 with function memoization we went from this:\n\n```\nSum: 710082754 Time: 437.936ms\n```\n\nto this:\n\n```\nSum: 710082754 Time: 60.605ms\n```\n\nBy reducing the nested synchronization (eliminating most of it) it is now running at:\n\n```\nSum: 710082754 Time: 22.429ms\n```\n",
        "Performance is now very close to what it is without Rx:\n\n```\nSum: 710082754 Time: 22.429ms\n```\n\nvs\n\n```\nrunNonCompositionalTestWithDirectLoop\nSum: 710082754 Time: 17.248ms\nrunNonCompositionalTestWithArrayOfFunctions\nSum: 710082754 Time: 17.311ms\n```\n\nI am considering this overhead acceptable right now and not spending further time on this issue.\n"
    ],
    "6817": [],
    "6507": [],
    "6305": [],
    "1768": [],
    "4582": [],
    "982": [],
    "6148": [],
    "481": [],
    "2609": [],
    "1749": [],
    "5627": [],
    "1403": [],
    "5427": [],
    "6813": [],
    "990": [],
    "6236": [],
    "3329": [],
    "5006": [],
    "3354": [],
    "4269": [],
    "154": [
        "This plugin looks similar enough to the felix plugin (which also uses BND) that it should work. The import/exports of RxJava are minimal and discoverable by the java code. There aren't any Class.forName() calls right?\n",
        "Interesting. This means the language plugins are going to have to be \"bundle fragments\" instead of plain bundles. That means that the plugin jars will be bound to the main rxjava-core jar at runtime as a logically-merged bundle. I haven't used gradle so my best-guess addendum for the language plugins would be:\n\n instruction 'Fragment-Host', 'com.netflix.rxjava.rxjava-core'\n\nThis means the jar being built (like the groovy plugin) is a fragment, whose host is rxjava-core. At runtime OSGi will fit the two together.\n",
        "If you set up the gradle changes I am happy to test.\n",
        "NP, gives me a chance to experience gradle. :)\n\nOn Fri, Feb 22, 2013 at 6:07 PM, Ben Christensen\nnotifications@github.comwrote:\n\n> I'd appreciate that as I have no way to know if it's successful or not, so\n> I'll create a branch with the gradle changes and then if you can play with\n> and modify the values as necessary that would be great. I'm working on\n> something else right now that I need to get done and then can work on this.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/154#issuecomment-13978672.\n",
        "Hi Ben, I will give it a go next week.\n\nOn Wed, Feb 27, 2013 at 2:49 PM, Ben Christensen\nnotifications@github.comwrote:\n\n> I've got a jar building with the OSGi headers but that's where I stop\n> having any idea what to put in as the headers, so I'd appreciate you\n> getting it working as needed and submitting the pull request.\n> \n> Here is how I did it:\n> \n> 1) Edit build.gradle of the module to change. For example,\n> ./rxjava-core/build.gradle\n> \n> I added this line at the top:\n> \n> apply plugin: 'osgi'\n> \n> and this at the bottom:\n> \n> jar {\n>     manifest {\n>         name = 'rxjava-core'\n>         instruction 'Bundle-Vendor', 'Netflix'\n>         instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'\n>     }}\n> \n> I then run a build:\n> \n> $ ./gradlew clean build\n> \n> I then see the MANIFEST file by doing this:\n> \n> $ cd ./rxjava-core/build/libs/\n> $ jar xvf rxjava-core-0.5.4-SNAPSHOT.jar\n> $ cat META-INF/MANIFEST.MF\n> \n> I see the new manifest headers that normally aren't there without the\n> build.grade changes above.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/154#issuecomment-14205447\n> .\n",
        "I added in your jar {} section and it does generate OSGi headers in the manifest.\n\nHowever, the unit tests are in the source code so it inserts dependencies for junit and mockito. I can strip them out with custom BND instructions to the OSGi plugin, but are these tests going to stay in the main src dir or will they move to a separate tests dir?\n",
        "Please add this one line to the jar {} section:\n\n```\n    instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*'\n```\n\nThis should mask out the unit testing packages.\n\nNOTE: Make sure you set your version to a release name (non-SNAPSHOT) before building the project. The manifest exports specific versions of rx; right now that version is \"version=\"0.5.5.SNAPSHOT\" which will fail if the actual maven artifact version is 0.5.5.\n\nThanks, if you do move the tests out of the main source dir then the Import-Package instruction can be removed.\n",
        "The 'provided' scope still means a runtime dependency rather than a test time dependency. I don't understand why they are not separated but that doesn't matter as long as it can be managed out of the dependencies.\n\nAs for the language adapters, let me have a look at them. They will need their own instructions for gradle including the fragment instruction.\n",
        "...and to answer the question for core, yes that manifest instruction set is good.\n",
        "How do you build the language adaptors, or where do they land?\n",
        "BenI(jamin?) I am not having much luck building the language adaptors. I am using both the top-level build command as described above as well as the subproject build like this:\n\nProjects/RxJava$ ./gradlew :language-adaptors:build\n\nWhat I get in language-adaptors/build/libs is an anemic jar file (261 bytes) with only a one-line manifest. Is there another way to generate the adaptor jars?\n",
        "Is scala/groovy/clojure supposed to be available or installed or such? It could be the reason I am getting such a small jar is that it gradle doesn't know what do to with these files? I built with -d to see if any error messages would surface but I couldn't spot anything obvious.\n\nTo wit: ./gradlew clean build  generates this:\n\nProjects/RxJava$ ls -la language-adaptors/build/libs/\ntotal 24\ndrwxr-xr-x  5 matt  staff  170 Mar 11 19:16 .\ndrwxr-xr-x  6 matt  staff  204 Mar 11 19:16 ..\n-rw-r--r--  1 matt  staff  261 Mar 11 19:16 language-adaptors-0.5.5-SNAPSHOT-javadoc.jar\n-rw-r--r--  1 matt  staff  261 Mar 11 19:16 language-adaptors-0.5.5-SNAPSHOT-sources.jar\n-rw-r--r--  1 matt  staff  261 Mar 11 19:16 language-adaptors-0.5.5-SNAPSHOT.jar\n\nWhich, as you can see, is a set of 261-byte jars. Each jar contains only an empty manifest file. So until I can actually build something from the git codebase, the language-adaptors can't be turned into OSGi bundles.\n\nI'm happy to not be concerned with them in this issue as they are only used for people wanting to use them, which can be considered a separate path. Perhaps someone can raise a new issue when they want to use these languages? That would allow you to commit your change and close this issue.\n",
        "For the language modules, please add the following instruction to the jar manifest config:\n\ninstruction 'Fragment-Host', 'com.netflix.rxjava.core'\n\nThis will give the language modules the name of the rxjava-core jar to attach themselves to, thereby allowing their classes to be joined to core's class path and thus discoverable.\n\nOtherwise, looks great! \n",
        "That's the symbolic name of the rxjava-core bundle (jar).  It is generated by the OSGi plugin.\n\n## \n\nMatt Bishop\n\nOn 2013-03-12, at 9:47 AM, Ben Christensen notifications@github.com wrote:\n\n> What does this represent => com.netflix.rxjava.core\n> \n> That is not a package or module name.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "Ben, thank you for taking the time to engage this issue so decisively even though your use has no need of OSGi. It's great to see. I'll pay attention to the issues and pitch in when OSGi comes up in the future.\n\nOn 2013-03-12, at 1:27 PM, Ben Christensen notifications@github.com wrote:\n\n> This will go out in the next release.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "This looks pretty straight-forward to do with Gradle: http://www.gradle.org/docs/current/userguide/osgi_plugin.html\n\nSince I have not used OSGi before, is there anything special about what the headers need to contain or is it basically the same information used to post to Maven Central? \n\nFor example, this pom file: http://search.maven.org/#artifactdetails%7Ccom.netflix.rxjava%7Crxjava-core%7C0.5.3%7Cjar\n",
        "There is one place Class.forName is used \u2013 to automatically load the plugins when they are in the classpath:\n\nhttps://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/util/functions/Functions.java#L49\n\nLanguage adaptors can also be manually loaded using `Functions.registerLanguageAdaptor(Class<?>[] functionClasses, FunctionLanguageAdaptor adaptor)`\n\nhttps://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/util/functions/Functions.java#L63\n",
        "I'd appreciate that as I have no way to know if it's successful or not, so I'll create a branch with the gradle changes and then if you can play with and modify the values as necessary that would be great. I'm working on something else right now that I need to get done and then can work on this.\n",
        "I've got a jar building with the OSGi headers but that's where I stop having any idea what to put in as the headers, so I'd appreciate you getting it working as needed and submitting the pull request.\n\nHere is how I did it:\n\n1) Edit build.gradle of the module to change. For example, ./rxjava-core/build.gradle\n\nI added this line at the top:\n\n``` groovy\napply plugin: 'osgi'\n```\n\nand this at the bottom:\n\n``` groovy\njar {\n    manifest { \n        name = 'rxjava-core'\n        instruction 'Bundle-Vendor', 'Netflix'\n        instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'\n    }\n}\n```\n\nI then run a build:\n\n```\n$ ./gradlew clean build\n```\n\nI then see the MANIFEST file by doing this:\n\n```\n$ cd ./rxjava-core/build/libs/\n$ jar xvf rxjava-core-0.5.4-SNAPSHOT.jar \n$ cat META-INF/MANIFEST.MF \n```\n\nI see the new manifest headers that normally aren't there without the build.grade changes above.\n",
        "The unit tests will not be moved out. They are there on purpose.\n\nThe JUnit dependency is marked as 'provided' (https://github.com/Netflix/Hystrix/blob/master/hystrix-core/build.gradle#L9) but not included as part of the runtime dependencies when published to Maven Central:  http://search.maven.org/#artifactdetails%7Ccom.netflix.hystrix%7Chystrix-core%7C1.2.12%7Cjar\n\nDoes the addition of just the following OSGi headers satisfy your requirements?\n\n```\njar {\n    manifest { \n        name = 'rxjava-core'\n        instruction 'Bundle-Vendor', 'Netflix'\n        instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'\n        instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*'\n    }\n}\n```\n\nWhat about the 'bundle fragments' that you mentioned would be needed for the language-adaptors? Or do I simply just add these same headers to each of those other jars as well (with their appropriate names of course)?\n",
        "I'll wait on your answer for the language-adaptors and then commit the changes.\n\nYes, it's \"runtime\" for running the tests, but not for production usage which is why they are marked as provided and not needed as transitive dependencies. Reasons if you care are here: http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/\n",
        "You can either build the entire project from the root like this:\n\n```\ncd RxJava\n$ ./gradlew build\n...\n$ ls -al language-adaptors/rxjava-groovy/build/libs/rxjava-groovy-0.5.5-SNAPSHOT.jar \n-rw-r--r--  1 bechristensen  CORP\\Domain Users  1115 Mar 11 13:08 build/libs/rxjava-groovy-0.5.5-SNAPSHOT.jar\n```\n\nOr you can go into an individual project and build it:\n\n```\n$ cd language-adaptors/rxjava-groovy/\n$ ../../gradlew build\n```\n\nThe contents are like this:\n\n```\n$ jar tvf build/libs/rxjava-groovy-0.5.5-SNAPSHOT.jar \n     0 Mon Mar 11 13:08:14 PDT 2013 META-INF/\n    25 Mon Mar 11 13:08:14 PDT 2013 META-INF/MANIFEST.MF\n     0 Thu Feb 28 12:09:40 PST 2013 rx/\n     0 Thu Feb 28 12:09:40 PST 2013 rx/lang/\n     0 Mon Mar 11 13:08:14 PDT 2013 rx/lang/groovy/\n   809 Mon Mar 11 13:08:14 PDT 2013 rx/lang/groovy/GroovyAdaptor.class\n```\n",
        "Each language-adaptor will have a build.grade file which would be changed.\n\nFor example, https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/build.gradle\n",
        "There is nothing beyond Java needed to build the project so I don't know what's going on with your build.\n\nI have submitted a pull request with the discussed changes. Please review and let me know if they look right.\n\nHere is the rxjava-core manifest:\n\n```\nManifest-Version: 1.0\nExport-Package: rx.subjects;uses:=\"rx.util,rx,rx.util.functions\";versi\n on=\"0.5.6.SNAPSHOT\",rx.util;uses:=\"rx,rx.util.functions\";version=\"0.5\n .6.SNAPSHOT\",rx.util.functions;uses:=\"org.slf4j\";version=\"0.5.6.SNAPS\n HOT\",rx.observables;uses:=\"rx.util.functions,rx\";version=\"0.5.6.SNAPS\n HOT\",rx.operators;uses:=\"rx,rx.util.functions,rx.util,rx.observables\"\n ;version=\"0.5.6.SNAPSHOT\",rx.plugins;version=\"0.5.6.SNAPSHOT\",rx;uses\n :=\"rx.util.functions,rx.util,rx.plugins,rx.operators\";version=\"0.5.6.\n SNAPSHOT\"\nIgnore-Package: junit.framework,org.mockito,org.mockito.verification,o\n rg.mockito.stubbing,org.junit\nTool: Bnd-1.50.0\nBundle-Name: rxjava-core\nCreated-By: 1.7.0_13 (Oracle Corporation)\nBundle-Vendor: Netflix\nBundle-Version: 0.5.6.SNAPSHOT\nBnd-LastModified: 1363058955000\nBundle-ManifestVersion: 2\nBundle-DocURL: https://github.com/Netflix/RxJava\nImport-Package: org.slf4j;version=\"[1.7,2)\"\nBundle-SymbolicName: com.netflix.rxjava.core\n```\n\nHere is a manifest for rxjava-groovy to show a language adaptor:\n\n```\nManifest-Version: 1.0\nExport-Package: rx.lang.groovy;uses:=\"groovy.lang,rx.util.functions\";v\n ersion=\"0.5.6.SNAPSHOT\"\nBundle-Vendor: Netflix\nBundle-Version: 0.5.6.SNAPSHOT\nTool: Bnd-1.50.0\nBundle-Name: rxjava-groovy\nBnd-LastModified: 1363058977000\nCreated-By: 1.7.0_13 (Oracle Corporation)\nBundle-ManifestVersion: 2\nBundle-DocURL: https://github.com/Netflix/RxJava\nBundle-SymbolicName: com.netflix.rxjava.groovy\nImport-Package: groovy.lang;version=\"[2.1,3)\",rx.util.functions;versio\n n=\"[0.5,1)\"\n```\n\nOf course when released the version with be correct and not have SNAPSHOT in it.\n",
        "Okay, I'll add that.\n",
        "What does this represent => com.netflix.rxjava.core\n\nThat is not a package or module name.\n",
        "I see that it shows up as `Bundle-SymbolicName` but I don't understand where that comes from as the module name is `rxjava-core`.\n",
        "@mattbishop Is that pull request correct?\n",
        "Okay ... merging now.\n",
        "This will go out in the next release.\n",
        "You're welcome, I appreciate your patience (a week of travel in the middle didn't help in that regard) while I got to it.\n\nI hope ~~Hystrix~~ RxJava can create value for you as it has for us.\n",
        "Ugh ... yes :-)\n",
        "That's what I get for flipping between two projects so much ... they morph into the same!\n",
        "@mattbishop Now that the code is released have you been able to confirm that it works as needed via Maven Central?\n",
        "Considering this completed as I have received no updates or complaints since releasing it.\n",
        "@benjchristensen  and by Hystrix, you meant RxJava ;)\n",
        "Hi in case you're interested I am usually using a gradle plugin to convert normal jars to osgi bundles.\r\nSee https://github.com/SimonScholz/rxjava-osgi/\r\n\r\nI've also written a tutorial how to do that: http://www.vogella.com/tutorials/EclipseJarToPlugin/article.html#convert-jar-files-to-osgi-bundles-with-gradle"
    ],
    "1882": [],
    "3981": [],
    "348": [],
    "926": [],
    "318": [],
    "2809": [],
    "3196": [],
    "781": [],
    "584": [],
    "5256": [],
    "3363": [],
    "401": [],
    "706": [],
    "1893": [],
    "4903": [],
    "6868": [],
    "4731": [],
    "3019": [],
    "5624": [],
    "4629": [],
    "3759": [],
    "956": [],
    "1094": [],
    "5753": [],
    "1100": [],
    "4250": [],
    "5861": [],
    "204": [
        "Would it be possible to use the @Deprecated annotation for the Object versions? This would cause java/scala to atleast warn when we are accidentally using the Object overload but might not translate out to the dynamic languages.\n",
        "Some background on why the current design was chosen rather than having each language with a separate version of Observable:\n\n---\n\nThe approach of having language specific packages/classes was pursued but did not work well because Rx is a composable library. It means that every time an `Observable` is used it needs to be re-wrapped or un-wrapped by whichever language is using it.\n\nFor example ...\n\nFrom Java a library is exposed that has a method like this:\n\n``` java\nrx.Observable getData()\n```\n\nFrom Groovy a library is exposed with a method like:\n\n``` java\nrx.groovy.GroovyObservable getOtherData()\n```\n\nThen from Scala you need to wrap them again:\n\n``` java\nrx.scala.ScalaObservable.from(getOtherData())\n```\n\nThis means we have an `rx.Observable` wrapped as `rx.groovy.GroovyObservable` wrapped as `rx.scala.ScalaObservable`.\n\nTo compose the two we would have:\n\n``` java\nrx.scala.ScalaObservable.zip(rx.scala.ScalaObservable.from(\n      getOtherData()), \n      rx.scala.ScalaObservable.from(getData()),\n       ... scala closure here ...);\n```\n\nNow what does `ScalaObservable` return from its operators? `ScalaObservable` or `Observable`?\n\nShould the above zip operator return `rx.scala.ScalaObservable` or `rx.Observable`? What happens if this library is consumed from another language?\n\nIf `Observable` each step along the way it must be wrapped yet again. If `ScalaObservable` it has now changed all of the return types of `rx.Observable` to a subtype.\n\nIn short, for interop between languages it very quickly becomes a mess and our primary polyglot goal was that `rx.Observable` was usable across all libraries as the single type and because the whole point of Rx is chained composition it's not as simple as just a single decoration at the beginning. It affects every single method in an API and step of the chaining.\n\nFor this reason we chose the current language-adaptor model where it is made to understand the closure/lambda types of each of the languages so `rx.Observable` can remain the sole interface across languages.\n\nThe reason we did not use an interface such as `FuntionalLanguageAdaptor` instead of `Object` is that not all languages automatically reify to \"functional interfaces\". Java8 does - but it's already type-safe and works fine with the Func/Action interfaces. Clojure, Groovy, JRuby and Scala all require awkward non-idiomatic java-interop or interface implementation syntax instead of their native lambda/closure syntax - thus `Object` is unfortunately the first super-type they all have in common - especially to handle the different arities (`Func1`, `Func2`, `Func3` etc) that can be passed in.\n",
        "Playing with this the 3 approaches I can see are:\n\n1) Java agent (can be loaded dynamically without manually injecting -javaagent at command line) to use the Java Attach API to intercept `rx.Observable` being loaded and do bytecode generation\n2) Custom classloader to intercept `rx.Observable` being loaded and do bytecode generation\n3) Compile time step to perform bytecode generation after compiling `rx.Observable` and replace Observable.class with the new typed methods for each language before packaging as a Jar\n\nOptions 1 and 2 are nice in that they only add the methods needed by the desired languages at runtime, but they are bad in that they both need an initialization hook - something that is a lot to ask for a plain library, not a full framework controlling entire lifecycle so I don't think they are appropriate here.\n\nOption 3 would include at compile time all of the methods needed for each language. This means that all runtimes would have that bytecode but if they don't have a particular language runtime loaded those methods could never be invoked.\n\nThe benefit is that all languages would use static types for method dispatch. The downside is that all the overloads would always exist even if someone is using just one of the languages.\n\nA possible solution would be to generate different versions of the binary for each language - which would work fine if an environment is using only one language, but if more than one is being used it would be very confusing because someone couldn't just load the two separate binaries, they'd collide in the same namespace. A single binary with support for each language would need to be used.\n\nI think the drawbacks of having all overloads for all languages in a single binary are small enough that it's worth pursuing to see how it works. \n\nThe only awkward drawback I know of that can't easily be overcome is that while working on the RxJava source itself in an IDE and running Groovy/Clojure/JRuby etc it would be hitting directly compiled classes, not the binaries put through bytecode generation so they would fail. It would mean that tests can only be run from the full build process, or by supporting option 1 or 2 for the development cycle while in an IDE. This impacts a limited number of people though so is not a big enough reason to avoid pursuing the bigger benefits of maintain static typing and avoiding use of instanceof for dynamically determining what language adaptor to use to execute a function.\n\nThis is very exploratory and something I'm researching as I go (I generally do not like code generation or bytecode manipulation so have not used this approach before) so feedback is much appreciated.\n",
        "We could add all of the overloads directly to the source - but we're talking about 48 methods already and eventually probably double that and then multiplying that by the number of languages.\n\nIt makes the javadoc, source code and maintenance rather ridiculous and it becomes very error prone that every time a method is added or touched the overload for every language must also be done. It would severely impede people getting involved and touching the Observable.java class.\n\nFor these reasons I feel it's not a great approach - though it is a valid one.\n\nI also strongly want to avoid different names - as that breaks the API across languages and doesn't really solve the real problem as people now need to know the different naming conventions in order to stay \"type safe\".\n\nThe amount of code to generate the methods is actually quite small, here's a prototype of me playing with it:\n\n``` java\npublic class LanguageAdaptorCodeGenerator {\n\n    static ClassPool pool = ClassPool.getDefault();\n\n    public static void addSupportFor(Class<?>[] types) {\n        CtClass cc;\n        try {\n            cc = pool.get(rx.Observable.class.getName());\n        } catch (NotFoundException e) {\n            throw new RuntimeException(\"Failed to add language adaptor methods as could not find rx.Observable.\", e);\n        }\n        try {\n            for (CtMethod method : cc.getMethods()) {\n                CtClass[] argTypes = method.getParameterTypes();\n                boolean containsFunctionType = false;\n                for (CtClass argType : argTypes) {\n                    if (isRxFunctionType(argType)) {\n                        containsFunctionType = true;\n                    }\n                }\n                if (containsFunctionType) {\n                    try {\n                        addMethod(cc, method, types);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        throw new RuntimeException(\"Failed to add language adaptor method: \" + method.getName(), e);\n                    }\n                }\n            }\n\n            // will need to output to filesystem here\n            //cc.toClass();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Failed to add language adaptor methods.\", e);\n        }\n    }\n\n    private static boolean isRxFunctionType(CtClass type) throws Exception {\n        // look for the Function argument\n        if (type.getName().equals(Function.class.getName())) {\n            return true;\n        }\n        // look for arguments implementing Function\n        for (CtClass implementedInterface : type.getInterfaces()) {\n            if (implementedInterface.getName().equals(Function.class.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static void addMethod(CtClass ctClass, CtMethod method, Class<?>[] types) throws Exception {\n        for (Class<?> cls : types) {\n            ArrayList<CtClass> parameters = new ArrayList<CtClass>();\n            CtClass[] argTypes = method.getParameterTypes();\n\n            System.out.print(\">>>>>> method: \" + method.getName() + \" args: \");\n            for (CtClass argType : argTypes) {\n                System.out.print(argType.getName() + \" \");\n                if (isRxFunctionType(argType)) {\n                    // needs conversion\n                    parameters.add(pool.get(cls.getName()));\n                } else {\n                    // no conversion, copy through\n                    parameters.add(argType);\n                }\n            }\n            System.out.println(\"\");\n\n            CtClass[] newArgs = parameters.toArray(new CtClass[parameters.size()]);\n            String params = \"\";\n            for (CtClass a : newArgs) {\n                params += a.getName() + \" \";\n            }\n            System.out.println(\"Add method => \" + method.getName() + \" => \" + params + \"  --> with arg type converted to: \" + cls.getName());\n            CtMethod newMethod = new CtMethod(method.getReturnType(), method.getName(), newArgs, ctClass);\n            newMethod.setModifiers(method.getModifiers());\n            newMethod.setBody(\"{ System.out.println(\\\"hello world!\\\");return null; }\");\n            ctClass.addMethod(newMethod);\n        }\n    }\n}\n```\n\nHere are the methods that get overloads (for just Groovy in this output):\n\n```\nAdd method => create => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => defer => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => filter => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => filter => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => forEach => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => groupBy => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => groupBy => groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => groupBy => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => groupBy => rx.Observable groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => last => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => last => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => lastOrDefault => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => lastOrDefault => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => map => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => map => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => mapMany => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => mapMany => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => onErrorResumeNext => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => onErrorResumeNext => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => onErrorReturn => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => onErrorReturn => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => reduce => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => reduce => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => reduce => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => reduce => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => scan => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => scan => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => scan => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => scan => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => sequenceEqual => rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => single => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => single => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => singleOrDefault => java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => singleOrDefault => rx.Observable java.lang.Object groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => subscribe => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => subscribe => groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => subscribe => groovy.lang.Closure groovy.lang.Closure groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => takeWhile => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => takeWhile => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => takeWhileWithIndex => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => takeWhileWithIndex => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => toSortedList => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => toSortedList => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => where => groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => where => rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => zip => rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => zip => rx.Observable rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\nAdd method => zip => rx.Observable rx.Observable rx.Observable rx.Observable groovy.lang.Closure   --> with arg type converted to: groovy.lang.Closure\n```\n\nI haven't yet made the method body do the right thing (it's printing hello world right now), but it's basically taking what is already in the language adaptors and just inlining it.\n\nThe part I haven't figured out yet is hooking into the Gradle build process - but it's just busy work I need to spend time on.\n",
        "Another option a colleague suggested is to generate the source code before compilation instead of doing bytecode manipulation after. Generating source code isn't as \"clean\" as using Javassist like that code above, but the benefit would be that source code is then shipped that matches the bytecode so that stacktraces and clicking through to source goes to the right place when debugging.\n\nThat may be a strong enough value to do source code generation rather than bytecode generation.\n",
        "We are getting close to eliminating these methods (week or two more at most\nI hope). I was planning on providing an update on it tonight or tomorrow to\ngive people a heads up.\n\nOn Tue, Jul 2, 2013 at 9:55 PM, samhendley notifications@github.com wrote:\n\n> Would it be possible to use the @Deprecatedhttps://github.com/Deprecatedannotation for the Object versions? This would cause java/scala to atleast\n> warn when we are accidentally using the Object overload but might not\n> translate out to the dynamic languages.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/204#issuecomment-20395690\n> .\n\n## \n\nBen Christensen - API Team\n+1-310-781-5511  @benjchristensen\n",
        "After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. \n\nOur goals are:\n- support static typing for Java/Scala/Kotlin etc by removing the Object overloads\n- support any JVM language, static or dynamically typed\n- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop\n- do not require special classloaders or agents to enable runtime bytecode generation\n- do not remove static operators to enable proxying\n- small jars and limited or no dependencies\n\nThe solution we have arrived at will work as follows:\n- The rxjava-core source code will delete all Object overload methods and be pure static java.\n  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.\n- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.\n  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.\n\nFor example:\n\nThe default Java version:\n\n``` java\npublic static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)\n```\n\nA Groovy version:\n\n``` java\npublic static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)\n```\n- A jar per language will be created as follows:\n  - rxjava-x-y-z.jar \n  - rxjava-groovy-x-y-z.jar \n  - rxjava-clojure-x-y-z.jar \n  - rxjava-scala-x-y-z.jar \n  - rxjava-jruby-x-y-z.jar \n  - rxjava-kotlin-x-y-z.jar \n\nA project will include just the jar that meets their language needs, there will no longer be a \"core\" jar plus the language adaptor.\n\nThe drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.\n- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:\n  - include an rxjava-dynamic.jar version that re-adds the Object overloads\n  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar\n- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.\n\nThis should not break any code but will require a slight change to the build dependencies in your project when we release this. \n\nWe hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.\n",
        "Byte code generation ended up not being used. We instead went with the solution in https://github.com/Netflix/RxJava/pull/323\n",
        "If you're going with option 3, why not directly add these methods in the source, instead of adding them after compilation? - Probably I'm missing something here.\n\nAnyway, instead of overloading the method with a single one where closures are mapped to `java.lang.Object`, you could add a method for each supported JVM language closure type. Let's take `subscribe` as an example.\n\nInstead of\n\n``` java\npublic Subscription subscribe(final Object o)\n```\n\nfor all dynamic languages, you could introduce\n\n``` java\npublic Subscription subscribe(final groovy.lang.Closure<?> cls)\n```\n\nand\n\n``` java\npublic Subscription subscribe(final org.jruby.RubyProc proc)\n```\n\nand\n\n``` java\npublic Subscription subscribe(final clojure.lang.IFn cls)\n```\n\nfor each dynamic language.\n\nIt wouldn't even be absolutely necessary to support Scala directly, as Scala can always hook itself in via implicits.\n\nNow, undoubtedly that's a lot of work, but I don't think you can get around that anyway. - But probably I'm overlooking something which makes this impossible? - The only big drawback I can think of atm is that it's not possible in that way to add another JVM-based language without touching the core. This doesn't worry me much, but maybe that's just me.\n\nAlso, there would be another \"easy way out\". You probably already thought of that. It's not pretty, though: Keep the methods taking objects, but instead of overloading the typesafe methods, name those differently. For example, pair\n\n``` java\npublic Subscription subscribe(final Object o)\n```\n\nwith\n\n``` java\npublic Subscription typedSubscribe(final Action1<T> onNext)\n```\n\nThough it's certainly not ideal, I could live with that...\n",
        "Awesome. - I expected a lot more work to be necessary to generate those additional methods. But this looks quite manageable. \n\nYou're right, the code generation approach looks better in this case than manually adding all those methods.\n",
        "I've got some work-in-progress up on my fork at: https://github.com/mattrjacobs/RxJava/commit/f5f84a8de6e96005a42ee4164c753d2cda3ed460.  The commit log describes what's been done and what's left to do before I'll feel comfortable submitting it.\n"
    ],
    "4468": [],
    "4928": [],
    "216": [
        "@johngmyers This is an interesting observation ... I hadn't noticed that note at the end of guideline 6.4 before. We added this wrapping code close to 1 year ago as a result of dealing with errors being thrown in random places because of bad `Observer` implementations subscribing to sequences.\n\nI don't yet fully understand the principle this note is trying to say nor the issue it claims it will cause.\n\nThe reason why the `AtomicObserver` exists is because \"non-trusted\" `Observer` implementations (via an actual `Observer` or one created via the use of `Action` or `Func` classes or the various language lambas/closures) often are a risk for throwing exceptions.\n\nFor example:\n\n``` java\npublic void onNext(String v) {\n    int num = Integer.parseInt(v);\n    doSomething(num);\n}\n```\n\nThat code is very easy to have result in a `NumberFormatException` being thrown.\n\nWe had `NullPointerExceptions` also being thrown, and what was happening is that they throw an exception off on some random thread because it's all asynchronous and things seem to just fail silently.\n\nOperator implementations as part of the RxJava library all should comply with the Rx Guidelines but users of the library don't do that very well and thus attempts have been made to be resilient to incorrect behavior.\n\nThe two most obvious examples are:\n\n**1) exceptions being thrown from code passed in by users**\n\nGuideline 6.4 covers functions, comparators, and other such obvious things (Func\\* and Action\\* implementations predominantly), but the `Observer` is by far the biggest one we had issues with.\n\n**2) Observables calling onNext concurrently or from multiple threads even when sequential (not concurrent)**\n\nThis is why we still implement the operators as if they are going to be called concurrently and use volatile, atomic and java.util.concurrent.\\* data structures. \n\nWe understand Guideline 6.8 and thus do not synchronize anything (except where the operator requires it such as `merge`/`zip`) but we still assume we need to handle visibility across threads.\n\nI'm going to ignore the second one for this discussion as that's not related to Guideline 6.4 which this issue is about.\n\nFor errors occurring in `onNext`/`onError`/`onCompleted` when they are provided by the user I see 3 options:\n\n**1) Throw**\n We can just let it throw exceptions off on whatever thread occurs\n\nThis is bad and not the solution we can accept. The only time I know of when that's the only acceptable option is documented here: https://github.com/Netflix/RxJava/issues/198\n\n**2) Try/Catch Everywhere**\n\nEvery Rx operator implementation needs to try/catch on every call to `Observer` `onNext`/`onError`/`onCompleted` methods\n\n**3) Single Wrapper**\n\nHave a single wrapping class such as the current `AtomicObserver` that is wrapped around `Observers` passed in from the user code.\n\nOption 2 means a lot of verbose error handling must be reproduced in every operator and it's error prone to make sure every single one does it in all the right places.\n\nWhat we found in experience was we would have some operators doing okay but then one would not and result in bad error handling for the user.\n\nOption 3 evolved out of wanting a single place to ensure proper error handling occurred regardless of whatever every single Rx operator was implemented without bugs in having a try/catch around every single call to the `Observer`.\n\n---\n\nAll this said I am not beholden to any particular implementation approach. My goals are:\n- comply with Rx contract unless the JVM prevents it or it doesn't match Java idioms and in that case match it as closely as possible \n  - naming conventions (lower-case vs capitalized)\n  - some names used by Rx.Net are reserved (do/finally)\n  - lack of extension methods requires a different approach for `Observable` (that's why it's a class and not an interface)\n  - lack of `yield` means synchronous Observables aren't easily made lazy (and I'd love for someone to implement a lazy Iterable to deal with this)\n- focus on getting the public API right and let the underlying implementations evolve as needed to improve performance, resilience and compliance\n- target the JVM and not any specific language so that any and all should be capable of being supported (already significant improvements are coming from community feedback and involvement (https://github.com/Netflix/RxJava/pull/213 and https://github.com/Netflix/RxJava/issues/204)\n\n---\n\nOn to an example ...\n\nThe recently updated (https://github.com/Netflix/RxJava/pull/212) `take` operator that will blow up if a user passes in a bad Observer ( bug https://github.com/Netflix/RxJava/issues/217 ):\n\n``` java\n            @Override\n            public void onError(Exception e) {\n                if (counter.getAndSet(num) < num) {\n                    observer.onError(e);\n                }\n            }\n\n            @Override\n            public void onNext(T args) {\n                System.out.println(\"Take: \" + args);\n                final int count = counter.incrementAndGet();\n                if (count <= num) {\n                    System.out.println(\"Take sending to onNext: \" + args);\n                    observer.onNext(args);\n                    System.out.println(\"Take AFTER sending to onNext: \" + args);\n                    if (count == num) {\n                        observer.onCompleted();\n                    }\n                }\n                if (count >= num) {\n                    // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable\n                    subscription.unsubscribe();\n                }\n            }\n```\n\nHere is the unit test that breaks it:\n\n``` java\n        @Test\n        public void testTakeWithError() {\n            final AtomicInteger count = new AtomicInteger();\n            final AtomicReference<Exception> error = new AtomicReference<Exception>();\n            Observable.from(\"1\", \"2\", \"three\", \"4\").take(3).subscribe(new Observer<String>() {\n\n                @Override\n                public void onCompleted() {\n                    System.out.println(\"completed\");\n                }\n\n                @Override\n                public void onError(Exception e) {\n                    error.set(e);\n                    System.out.println(\"error\");\n                    e.printStackTrace();\n                }\n\n                @Override\n                public void onNext(String v) {\n                    int num = Integer.parseInt(v);\n                    System.out.println(num);\n                    // doSomething(num);\n                    count.incrementAndGet();\n                }\n\n            });\n            assertEquals(2, count.get());\n            assertNotNull(error.get());\n            if (!(error.get() instanceof NumberFormatException)) {\n                fail(\"It should be a NumberFormatException\");\n            }\n        }\n```\n\nThat will print out 1 and 2 and then silently fail.\n\nNote how the `onNext` in the `take` implementation does not have a try/catch around `observer.onNext` and then the `onError` has logic that prevents `observer.onError` from getting calling after the count increments - which happened in the `onNext` that failed - thus it skips sending the error to the observer.\n\nFunny enough this test case even shows that the way `AtomicObserver` is currently being used doesn't handle this scenario! This is because the \"isTrusted\" decision point is for the `Observable` not the incoming `Observer`.\n\nIf I force the `AtomicObserver` to be used for this test case then the `onError` is correctly called even with the bugs in the `take` operator.\n\nThis particular `take` operator is heavily unit tested and at least 2 sets of eyes reviewed it and both missed it.\n\nI've had this `AtomicObserver` in place for over a year and didn't realize this particular type of case was still a gaping hole - probably explains why I still hear in production about \"silent failures\" occasionally happening - not even a log entry showing up.\n\nAs for how having `AtomicObserver` may cause issues that the Rx Guideline 6.4 note warns of? It must be related to the `unsubscribe` chain but I haven't thought through all of the implications and it's not jumping out to me.\n\nWe obviously need some way of improving the libraries resilience against error handling bugs - even the current attempt with `AtomicObserver` isn't covering all of the scenarios as I just discovered by doing this test.\n\nIt is very easy to have holes in the error handling in all of the Rx operator implementations so I'd like to know how we can achieve Guideline 6.4 while admitting it's near impossible to have bug-free Rx operators and accomplish the goal of never having an exception be swallowed or lost on a random thread.\n\nI'd very much appreciate your or anyone else's assistance in figuring out the approach to take and then getting there.\n",
        "Here are unit tests demonstrating various use cases.\n- Synchronous with error in Observer -> Passes because `subscribe` method has a try/catch that works with synchronous sequences\n- Synchronous with error in Observable -> Passes because `subscribe` method has a try/catch that works with synchronous sequences\n- Asynchronous with error in Observer and no composition -> Passes because AtomicObserver catches the error\n- Asynchronous with error in Observer and composition -> Fails because AtomicObserver doesn't get used in the right place ... it wraps the composed operator rather than the user provided Observer\n- Asynchronous with error in Observable -> Fails because exception is thrown on the user provided thread. Not sure if there is anything that can be done in that situation.\n\n2 of these 5 can be helped by the AtomicObserver but it's only helping 1 of the 2 right now. These 2 use cases are the most common of the 5 so it's valid to pursue a solution I think. The use case that doesn't work could be fixed by using a better approach for deciding when to wrap (or of course finding a completely different approach which is the point of this issue).\n\n``` java\n/**\n * The error from the user provided Observable is not handled because this is\n * asynchronous and the Exception throws on the thread.\n * \n * Result: Fails\n */\n@Test\npublic void testCustomObservableWithErrorInObservableAsynchronous() throws InterruptedException {\n    final CountDownLatch latch = new CountDownLatch(1);\n    final AtomicInteger count = new AtomicInteger();\n    final AtomicReference<Exception> error = new AtomicReference<Exception>();\n    Observable.create(new Func1<Observer<String>, Subscription>() {\n\n        @Override\n        public Subscription call(final Observer<String> observer) {\n            final BooleanSubscription s = new BooleanSubscription();\n            new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (!s.isUnsubscribed()) {\n                            observer.onNext(\"1\");\n                            observer.onNext(\"2\");\n                            throw new NumberFormatException();\n                        }\n                    } finally {\n                        latch.countDown();\n                    }\n                }\n            }).start();\n            return s;\n        }\n    }).subscribe(new Observer<String>() {\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"completed\");\n        }\n\n        @Override\n        public void onError(Exception e) {\n            error.set(e);\n            System.out.println(\"error\");\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onNext(String v) {\n            System.out.println(v);\n            count.incrementAndGet();\n        }\n\n    });\n\n    // wait for async sequence to complete\n    latch.await();\n\n    assertEquals(2, count.get());\n    assertNotNull(error.get());\n    if (!(error.get() instanceof NumberFormatException)) {\n        fail(\"It should be a NumberFormatException\");\n    }\n}\n\n/**\n * The error from the user provided Observer is not handled by the subscribe method try/catch.\n * \n * It is handled by the AtomicObserver that wraps the provided Observer.\n * \n * It doesn't compose well though ... if `take(1)` is put between the Observable and\n * subscribe then it still fails.\n * \n * Result: Passes (if AtomicObserver functionality exists)\n */\n@Test\npublic void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {\n    final CountDownLatch latch = new CountDownLatch(1);\n    final AtomicInteger count = new AtomicInteger();\n    final AtomicReference<Exception> error = new AtomicReference<Exception>();\n    Observable.create(new Func1<Observer<String>, Subscription>() {\n\n        @Override\n        public Subscription call(final Observer<String> observer) {\n            final BooleanSubscription s = new BooleanSubscription();\n            new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (!s.isUnsubscribed()) {\n                            observer.onNext(\"1\");\n                            observer.onNext(\"2\");\n                            observer.onNext(\"three\");\n                            observer.onNext(\"4\");\n                            observer.onCompleted();\n                        }\n                    } finally {\n                        latch.countDown();\n                    }\n                }\n            }).start();\n            return s;\n        }\n    }).subscribe(new Observer<String>() {\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"completed\");\n        }\n\n        @Override\n        public void onError(Exception e) {\n            error.set(e);\n            System.out.println(\"error\");\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onNext(String v) {\n            int num = Integer.parseInt(v);\n            System.out.println(num);\n            // doSomething(num);\n            count.incrementAndGet();\n        }\n\n    });\n\n    // wait for async sequence to complete\n    latch.await();\n\n    assertEquals(2, count.get());\n    assertNotNull(error.get());\n    if (!(error.get() instanceof NumberFormatException)) {\n        fail(\"It should be a NumberFormatException\");\n    }\n}\n\n/**\n * The error from the user provided Observer is not handled by the subscribe method try/catch.\n * \n * It is also not handled by the AtomicObserver because composition defeats it.\n * \n * Result: Fails\n */\n@Test\npublic void testCustomObservableWithErrorInObserverAsynchronousWithComposition() throws InterruptedException {\n    final CountDownLatch latch = new CountDownLatch(1);\n    final AtomicInteger count = new AtomicInteger();\n    final AtomicReference<Exception> error = new AtomicReference<Exception>();\n    Observable.create(new Func1<Observer<String>, Subscription>() {\n\n        @Override\n        public Subscription call(final Observer<String> observer) {\n            final BooleanSubscription s = new BooleanSubscription();\n            new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (!s.isUnsubscribed()) {\n                            observer.onNext(\"1\");\n                            observer.onNext(\"2\");\n                            observer.onNext(\"three\");\n                            observer.onNext(\"4\");\n                            observer.onCompleted();\n                        }\n                    } finally {\n                        latch.countDown();\n                    }\n                }\n            }).start();\n            return s;\n        }\n    }).take(1).subscribe(new Observer<String>() {\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"completed\");\n        }\n\n        @Override\n        public void onError(Exception e) {\n            error.set(e);\n            System.out.println(\"error\");\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onNext(String v) {\n            int num = Integer.parseInt(v);\n            System.out.println(num);\n            // doSomething(num);\n            count.incrementAndGet();\n        }\n\n    });\n\n    // wait for async sequence to complete\n    latch.await();\n\n    assertEquals(2, count.get());\n    assertNotNull(error.get());\n    if (!(error.get() instanceof NumberFormatException)) {\n        fail(\"It should be a NumberFormatException\");\n    }\n}\n\n/**\n * The error from the user provided Observer is handled by the subscribe \n * try/catch because this is synchronous\n * \n * Result: Passes\n */\n@Test\npublic void testCustomObservableWithErrorInObserverSynchronous() {\n    final AtomicInteger count = new AtomicInteger();\n    final AtomicReference<Exception> error = new AtomicReference<Exception>();\n    Observable.create(new Func1<Observer<String>, Subscription>() {\n\n        @Override\n        public Subscription call(Observer<String> observer) {\n            observer.onNext(\"1\");\n            observer.onNext(\"2\");\n            observer.onNext(\"three\");\n            observer.onNext(\"4\");\n            observer.onCompleted();\n            return Subscriptions.empty();\n        }\n    }).subscribe(new Observer<String>() {\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"completed\");\n        }\n\n        @Override\n        public void onError(Exception e) {\n            error.set(e);\n            System.out.println(\"error\");\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onNext(String v) {\n            int num = Integer.parseInt(v);\n            System.out.println(num);\n            // doSomething(num);\n            count.incrementAndGet();\n        }\n\n    });\n    assertEquals(2, count.get());\n    assertNotNull(error.get());\n    if (!(error.get() instanceof NumberFormatException)) {\n        fail(\"It should be a NumberFormatException\");\n    }\n}\n\n/**\n * The error from the user provided Observable is handled by the \n * subscribe try/catch because this is synchronous\n * \n * \n * Result: Passes\n */\n@Test\npublic void testCustomObservableWithErrorInObservableSynchronous() {\n    final AtomicInteger count = new AtomicInteger();\n    final AtomicReference<Exception> error = new AtomicReference<Exception>();\n    Observable.create(new Func1<Observer<String>, Subscription>() {\n\n        @Override\n        public Subscription call(Observer<String> observer) {\n            observer.onNext(\"1\");\n            observer.onNext(\"2\");\n            throw new NumberFormatException();\n        }\n    }).subscribe(new Observer<String>() {\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"completed\");\n        }\n\n        @Override\n        public void onError(Exception e) {\n            error.set(e);\n            System.out.println(\"error\");\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onNext(String v) {\n            System.out.println(v);\n            count.incrementAndGet();\n        }\n\n    });\n    assertEquals(2, count.get());\n    assertNotNull(error.get());\n    if (!(error.get() instanceof NumberFormatException)) {\n        fail(\"It should be a NumberFormatException\");\n    }\n}\n```\n",
        "> If this semantic is to be kept, it should be implemented by having Observable.subscribe() wrap a ProtectObserver around trusted Observables, not by trying to have each protected operation independently implement and test this semantic.\n\nI agree which is what was seeking to be accomplished with AtomicObserver. It's concept is similar to how every operator shouldn't have to synchronize everything - error handling should if possible be abstracted to a single place.\n\nI was looking back through the history of our refactoring from internal code to open source RxJava and found where it broke down. We wrapped every `Observer` passed in to `subscribe` so it handled both of the \"asynchronous  observer with errors\" use cases. \n\nThis code got mangled while doing performance optimizations (https://github.com/Netflix/RxJava/issues/104) by reducing extraneous wrapping and synchronization and unit tests didn't exist for the error handling use case we lost and I rediscovered while investigating this issue.\n\n> Perhaps a ProtectObserver that Observable.subscribe() wraps around all subscriptions should feed a copy of all Throwables thrown by Observer notification callbacks to a plugin. Monitoring could then use the plugin to identify Observer bugs that need to be fixed.\n\nThis is the reason for the [RxJavaErrorHandler](https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/plugins/RxJavaErrorHandler.java) plugin. We use this in production to capture any errors that occur so we see them even if an `Observer` implementation doesn't correctly implement `onError`.\n\n---\n\nI'll work on this further to get improved unit testing around error handling and explore a clean way to provide the protection without hurting the performance benefits we got in https://github.com/Netflix/RxJava/issues/104.\n",
        "So you're suggesting a separate plugin (or method/type on the existing plugin) that specifically handles only errors thrown by the Observer. That's an interesting idea. I can see the value in knowing the difference.\n",
        "Enforcing the requirements is the intent of things like `AtomicObserver` and `AtomicObservableSubscription`. Tools for testing conformance is nice and an interesting idea but it obviously does nothing to deal with non-conformance in a running system. We can take that on elsewhere (such as the discussion on the other issue about your dislike of my removal of rx.testing).\n\nI have a question about implementation details for wrapping an incoming Observer ... I've asked around several folks internally as well. All approaches have drawbacks I think.\n\nThe simplest and cleanest option is to wrap every `Observer` passed into subscribe. This is what we did prior to https://github.com/Netflix/RxJava/issues/104. The drawback is an extra wrapping at every level of composition.\n\nSince it is ensuring conformance of the contract and not just try/catch behavior this also means it is doing volatile checks which in a tight-loop and deep composition chain causes performance impacts.\n\n```\n# wrapping at every level of composition (50 deep)\ncompositionTestTotalTime: 4392\nnonCompositionalTestWithDirectLoopTotalTime: 1913\nnonCompositionalTestWithArrayOfFunctionsTotalTime: 1826\n\n# wrapping only one Observer of the 50\ncompositionTestTotalTime: 2248\nnonCompositionalTestWithDirectLoopTotalTime: 1887\nnonCompositionalTestWithArrayOfFunctionsTotalTime: 1813\n```\n\nThe numbers are in milliseconds but only mean anything relative to each other. It makes a difference though: 4392 vs 2248.\n\nSo, to avoid wrapping every layer it would be nice to only wrap the final Observer passed in by user code.\n\nTo know if an Observer is from internal or external can be done by:\n\n1) Inspecting the package of the Observer implementation\n\nThis is the cleanest of the 4 options but I question the performance impact (need to test this) of checking every single time.\n\n2) Using a marker interface on internally implemented Observers (i.e. OperatorObserver extends Observer)\n\nI dislike marker interfaces but it would perform well.\nIt also requires every operator correctly doing this which is error prone (though limited impact if someone forgets).\n\n3) Annotations on internally implemented Observers\n\nAnnotations are basically just a different flavor of a marker interface. It adds more complexity to scanning them.\nAt runtime I would need to test their performance. \nIt also requires every operator correctly doing this which is error prone (though limited impact if someone forgets).\n\n4) Separate `subscribeNonProtected` method on Observable\n\nI don't like this because it would have to be a public method as Java can't allow me to make a method only accessible to certain packages.\n\nRight now I'm pursuing either option 1 or 2 and will report back on my findings on option 1 which I'd prefer if it performs well.\n\nAny other approaches that you feel are better or what is your opinion on these 4?\n",
        "This code for option 1 appears to perform fine:\n\n``` java\n            /**\n             * See https://github.com/Netflix/RxJava/issues/216 for discussion on \"Guideline 6.4: Protect calls to user code from within an operator\"\n             */\n            if (observer.getClass().getPackage().getName().startsWith(\"rx\")) {\n                Subscription s = onSubscribe.call(observer);\n                if (s == null) {\n                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens\n                    // we want to gracefully handle it the same as AtomicObservableSubscription does\n                    return Subscriptions.empty();\n                } else {\n                    return s;\n                }\n            } else {\n                AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n                return subscription.wrap(onSubscribe.call(new AtomicObserver<T>(subscription, observer)));\n            }\n```\n\nI was expecting `observer.getClass().getPackage().getName().startsWith(\"rx\")` to be a problem but the performance test shows this:\n\n```\ncompositionTestTotalTime3: 2361\nnonCompositionalTestWithDirectLoopTotalTime: 1879\nnonCompositionalTestWithArrayOfFunctionsTotalTime: 1940\n```\n\nSince it's in the right order of magnitude (and faster than wrapping everything) I'm proceeding with option 1 for now unless someone comes up with a better solution.\n",
        "They don't do synchronization. They use java.util.concurrent.atomic.\\* classes which use compareAndSet or volatile - not synchronization. \n",
        "Volatile and Atomic\\* classes in Java affect visibility with memory effects across threads and CPUs, but they don't `synchronize` as the word is used in Java to cause blocking sequential access by a single thread by synchronizing or locking a method or block of code.\n\nAs per the JDK http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/package-summary.html which represents atomics as being \"lock-free\":\n\n> Package java.util.concurrent.atomic Description\n> \n> A small toolkit of classes that support **lock-free** thread-safe programming on single variables. In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form:\n> \n> boolean compareAndSet(expectedValue, updateValue);\n\nThe volatile and atomic functionality is non-blocking (especially since the use in `AtomicObserver` never does spin-locks on a compareAndSet) and does not synchronize threads.\n\n---\n\nI'll be submitting a pull request shortly for this issue ...\n",
        "Yep I know about the visibility and memory affects and their performance cost. \n\nThanks for your input on the options.\n",
        "I've submitted a pull request to resolve the most glaring issues: https://github.com/Netflix/RxJava/pull/221\n\nI have not explored separating `AtomicObserver` into a `ProtectedObserver` just for error handling and another for ensuring contract compliance.\n",
        "I merged https://github.com/Netflix/RxJava/pull/221 which solves these:\n- Asynchronous with error in Observer and no composition -> Passes because AtomicObserver catches the error\n- Asynchronous with error in Observer and composition -> Fails because AtomicObserver doesn't get used in the right place ... it wraps the composed operator rather than the user provided Observer\n\nIt does not solve this one and I don't know if there's anything we can do:\n- Asynchronous with error in Observable -> Fails because exception is thrown on the user provided thread. Not sure if there is anything that can be done in that situation.\n\nI also added fixes to wrap around the `forEach` and `subscribe` overloads where user-provided `Function` implementations (`Func` and `Action`) where being passed in and not protected against errors.\n\nIs there anything more that we should do on this subject?\n",
        "If this semantic is to be kept, it should be implemented by having `Observable.subscribe()` wrap a `ProtectObserver` around trusted Observables, not by trying to have each protected operation independently implement and test this semantic.\n\nI think what the guidelines are getting at is that protecting onNext() is going to produce onError() notifications that the Observer isn't going to expect to be recieving (especially since the Observer is by definition buggy).\n\nFor example, consider an Observer that subscribes to `materialize()`. It isn't going to expect to get any onError() calls at all, as `materialize()` has a contract stating that it never emits onError(). The implementations of `materialize()` consumers that I've seen do nothing on onError() calls*, so that means the exception would be silently ignored and the bug likely never discovered.\n\n\\* In my opinion, they should instead throw `UnsupportedOperationExcetion()`\n\nPut another way, I think the guidelines are trying to say that attempting to protect notification callbacks leads you down a rabbit hole, which I think you're starting to discover.\n\nIt is, however, hard to argue against operational experience. It doesn't work to monitor the exceptions coming out of \"random\" threads, using them to identify the Observer bugs so they can be fixed?\n\nPerhaps a ProtectObserver that `Observable.subscribe()` wraps around all subscriptions should feed a copy of all Throwables  thrown by Observer notification callbacks to a plugin. Monitoring could then use the plugin to identify Observer bugs that need to be fixed.\n",
        "> This is the reason for the RxJavaErrorHandler plugin. We use this in production to capture any errors that occur so we see them even if an Observer implementation doesn't correctly implement onError.\n\nThat's not the same thing. `RxJavaErrorHandler` captures exceptions passed through `onError()` notifications to a particular set of Observers. I'm talking about something that captures exceptions thrown from any Observer notification.\n",
        "...an exception passed through `onError()` into `RxJavaErrorHandler` is likely to be an operational error, such as a transient network failure. An exception thrown from an Observer notification is guaranteed to be the result of a coding bug.\n",
        "> This particular take operator is heavily unit tested and at least 2 sets of eyes reviewed it and both missed it.\n\nI hope you're not counting my set of eyes here. I noticed this hole in most trusted operators when writing `assertTrustedObservable()`. What I didn't notice is that `Observable.subscribe()` partially papers over the hole for the case of synchronous trusted Observables.\n\nIf you want users of an interface to comply with a contract requirement, it helps to either enforce the requirement or at least to provide tools to allow implementers to unit test conformance to the requirement.\n",
        "`AtomicObserver` and `AtomicObservableSubscription` have to do synchronization, so have to pay the synchronization cost. A `ProtectObserver` would not have to do synchronization, so should be much cheaper.\n",
        "java.util.concurrent.\\* and volatile are synchronization.\n",
        "The visibility and memory effects have a performance cost and are within the meaning of the word \"synchronization\" as used in RX Design Guideline 6.8.\n\nMy opinion on the proposals:\n\n1) External Observers can happen to be in a package having a name starting with the two characters \"rx\". If you go this route, you still take the risk of internal Observers that throw. This is not a semantic that can be systematically unit tested for.\n\n2) A marker interfaces has the advantage that its presence indicates a reasonable likelihood that the implementer of the Observer has thought about the problem. Unless, of course, the implementer has cargo-cult-copied the marker.\n\n3) I see little advantage over a marker interface.\n\n4) Unsafe as it puts the decision on the user of the Observer, not the implementer of the Observer.\n",
        "Not all forms of protection need to fix up buggy implementations so that they work. An alternative form of protection is to make failures happen earlier, with higher probability, and/or higher visibility. That way, bugs get noticed and fixed earlier in the deployment process.\n"
    ],
    "217": [
        "@johngmyers can you take a look at this please since you have been involved in this code?\n",
        "See https://github.com/Netflix/RxJava/issues/216 for a discussion related to this.\n",
        "Operators must work on both synchronous and asynchronous sequences, including error handling, and I understand that this issue exists on all kinds of operators. This issue is to demonstrate that there are challenging implementation details and nuanced behavior even when an operator implementation \"looks correct\". The discussion at https://github.com/Netflix/RxJava/issues/216 will carry this forward ...\n\n> In the supplied unit test, the take operator has already delivered three onNext() notifications, so it has completed. It can't deliver an onError() after onComplete(). Change the test to a take(4) and it passes.\n\nWith `take(3)` it does not successfully deliver 3 `onNext` notifications. It delivers 2 and attempts the 3rd and fails and then when `onError` is invoked it thinks it has terminated based solely on the count but it has not because the 3rd `onNext` failed and should have instead emitted an `onError`. \n\nWhether this gets fixed in the operator or part of https://github.com/Netflix/RxJava/issues/216 is an open question. I think it should be done outside of the operator because too much error-prone boilerplate will need to exist in every single operator to try and get every use case handled.\n\nI'll hold this issue open until https://github.com/Netflix/RxJava/issues/216 is finalized but theoretically no code changes should be needed for the `take` operator directly.\n",
        "I just tested the unit test above and it works.\n\n```\n1\n2\nerror\njava.lang.NumberFormatException: For input string: \"three\"\n    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n    at java.lang.Integer.parseInt(Integer.java:492)\n    at java.lang.Integer.parseInt(Integer.java:527)\n    at rx.TestIssue$1.onNext(TestIssue.java:32)\n    at rx.TestIssue$1.onNext(TestIssue.java:1)\n    at rx.operators.SafeObserver.onNext(SafeObserver.java:121)\n    at rx.operators.OperationTake$Take$ItemObserver.onNext(OperationTake.java:140)\n    at rx.operators.OperationToObservableIterable$ToObservableIterable.onSubscribe(OperationToObservableIterable.java:55)\n    at rx.Observable.subscribe(Observable.java:186)\n    at rx.operators.OperationTake$Take.onSubscribe(OperationTake.java:110)\n    at rx.operators.OperationTake$1.onSubscribe(OperationTake.java:59)\n    at rx.Observable.subscribe(Observable.java:196)\n    at rx.TestIssue.testTakeWithErrorInObserver(TestIssue.java:16)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n```\n\nfor\n\n``` java\n@Test\n    public void testTakeWithErrorInObserver() {\n        final AtomicInteger count = new AtomicInteger();\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        Observable.from(\"1\", \"2\", \"three\", \"4\").take(3).subscribe(new Observer<String>() {\n\n            @Override\n            public void onCompleted() {\n                System.out.println(\"completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(e);\n                System.out.println(\"error\");\n                e.printStackTrace();\n            }\n\n            @Override\n            public void onNext(String v) {\n                int num = Integer.parseInt(v);\n                System.out.println(num);\n                // doSomething(num);\n                count.incrementAndGet();\n            }\n\n        });\n        assertEquals(2, count.get());\n        assertNotNull(error.get());\n        if (!(error.get() instanceof NumberFormatException)) {\n            fail(\"It should be a NumberFormatException\");\n        }\n    }\n```\n",
        "Unit test added in https://github.com/Netflix/RxJava/pull/353\n",
        "In the supplied unit test, the take operator has already delivered three `onNext()` notifications, so it has completed. It can't deliver an `onError()` after `onComplete()`. Change the test to a `take(4)` and it passes.\n\nSo in my opinion it's an invalid test.\n\nNote that none of the trusted operators handle asynchronous `Observer.onNext()` notifications throwing exceptions. It is `Observer.subscribe()` that is catching the exception and delivering it through `onNext()` and that only works because the notifications are synchronous.\n",
        "For an amusing test, replace the `take(3)` with `materialize()`.\n",
        "> So in my opinion it's an invalid test.\n\nLet me amend that statement. The test was bug-dependent: it depended on the very bug that was fixed in order to pass. Furthermore, if the test had applied `take(3)` to an _asynchronous_ trusted Observer generating the same sequence, it would not have passed. \n"
    ],
    "5710": [],
    "3467": [],
    "3328": [],
    "6049": [],
    "599": [],
    "1387": [],
    "5740": [],
    "4506": [],
    "4018": [],
    "2975": [],
    "3686": [],
    "6431": [],
    "838": [],
    "6137": [],
    "566": [],
    "6366": [],
    "772": [],
    "3078": [],
    "4276": [],
    "503": [],
    "1687": [],
    "1650": [],
    "3326": [],
    "1454": [],
    "6600": [],
    "5486": [],
    "6432": [],
    "1784": [],
    "2772": [],
    "3212": [],
    "4422": [],
    "1049": [],
    "4378": [],
    "6827": [],
    "567": [],
    "4538": [],
    "4062": [],
    "296": [
        "Throwable only has 2 sub-classes `Error` and `Exception` and generally the convention is to not catch `Error`. \n\n> An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\n> http://docs.oracle.com/javase/6/docs/api/java/lang/Error.html\n\nThus, all application Exceptions capable of being handled should extend from `Exception` not `Throwable` or `Error`. This was the reasoning behind not using Throwable. \n\nWhat are the use cases in which we should be catching and passing `Error` via `Observer#onError` and thus require `Throwable` as the signature?\n\nAlso of note, this is a breaking change (not a deal breaker since we are pre-1.0, but it's a factor).\n",
        "I have handled that use case before (years ago when working on search engines where it made sense to catch OOME). However, I'd suggest that is an edge case that should be caught by the specific code and turned into an `Exception` or `RuntimeException` before being thrown to other code to handle.\n\nDevelopers should not be expected to handle an `Error`, including an OOME as they wouldn't know it could be handled.\n\nHere is an example of what I'd suggest to comply with the principle of not throwing `Error` for developers to handle while still handling the OOME for this edge case.\n\n``` groovy\nreturn Observable.create(new Func1<Observer<String>, Subscription>() {\n    def Subscription call(Observer<String> observer) {\n        try {\n            // allocate memory\n\n            observer.onNext(\"some value\");\n            observer.onCompleted();\n        } catch(OutOfMemoryError e) {\n          observer.onError(new RuntimeException(\"Recoverable OutOfMemory on optional ... \"));\n        }\n\n        return Subscriptions.empty();\n    };\n});\n```\n",
        "Those are some very strong arguments and I'm mostly convinced that it's worth changing to `Throwable`. I still don't think `Error`s should be handled (most of the time) but I agree that wrapping an Observable around something that throws a `Throwable` is very awkward if `onError` only supports `Exception` as that means contrived `Exceptions` wrapping `Throwable' or they are thrown from somewhere else and could leave the Observable/Observer permanently blocked waiting on a terminal state.\n\nTo adopt `onError(Throwable)` means a breaking change, but version 0.10.0 is a good time for this since we're changing the builds significantly and requiring people to change their build target from `rxjava-core` to `rxjava` as part of it, and that's why we're still not at version 1.x.\n\nI don't like however that `onErrorResumeNext` will now start handling `Throwable` and `Error`, not just `Exception`.\n\nPerhaps we should create a new `onExceptionResumeNext` that should be what people normally use? I'd love to make `onErrorResumeNext` be that way, but the naming is wrong, so `onErrorResumeNext` needs to receive all errors passed by `onError` which means `Throwable` whereas `onExceptionResumeNext` could catch only `Exception` and allow `Throwable`/`Error` past.\n\nWhat other implications are there if we proceed with this change?\n",
        "Anyone have further thoughts on this issue, particularly the use cases I explained in my last comment regarding `onErrorResumeNext` and `onExceptionResumeNext`?\n",
        "@Andrei-Pozolotin @adriancole @jmhofer @mttkay @michaeldejong @mairbek\n\nI have submitted a pull request https://github.com/Netflix/RxJava/pull/315 with the breaking change of `onError(Exception)` to `onError(Throwable)` based on the discussion in this issue. I would appreciate your review and confirmation before I proceed. \n\nI would like to merge and release within 24 hours if possible.\n",
        "My 2p on the issue.\n\nIf there's a chance of \"user code\" being in the stack leading to `onError()` then we should prefer Throwable as devs can and do raise AssertionErrors intentionally or unintentionally.\n\nOther reasons to prefer Throwable is that the cause of any exception is a throwable.  Apis that try to coerce to exception often wrap throwables (sometimes incorrectly) just to handle exception.getCause.  This implies that those using or maintaining the system need to carefully review all try-catch blocks before they know that onError will in fact be called and not just propagate stuff and leave them hanging.  While there are still cases onError won't be called, due to JVM crash, etc, I think it is still an advantage.\n\nIt is possible that Observer writers could be turned off due to throwable.  This could be good or bad.. I see this as \"hey.. you really should pay attention!!\".   Those who insist they don't like to receive throwable can punt using or making utilities such as [propagate](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Throwables.html#propagateIfInstanceOf(java.lang.Throwable, java.lang.Class).\n\nSummary is that if we allow onError to receive a throwable, we are being more honest to the observer about their failures.  It will be called more often (for example, it can accept an Error) or would be called with less wrapped things.  The try blocks maintaining the stack until onError are simpler and can directly correspond to exception.getCause.\n\nThe benefits of `onError(Throwable)` are worth it.\n",
        "One thing to clarify here is that whether or not to send a throwable signal to the observer is a different issue than whether the code managing the observer propagates errors.  If we decide to notify observers when an error (or any other throwable) caused their request to cease, this doesn't imply we are swallowing errors in the RXjava code that calls `onError`, if that makes sense.\n",
        "@jmhofer onError() is basically a message.  It doesn't imply the receiver should propagate it.  It only informs them what happened, right?  Choosing to restrict onError from accepting throwable is a choice to not know why or if your observer was cancelled.  I can't side with that.\n",
        "wrt \"Also, calling onError for an Error and at the same time rethrowing it would be confusing, imho.\"  It isn't confusing if we understand `onError` is a signal.  Without a callback, the observer could block forever (wait some timeout etc), as they were not informed they will never complete.  The Observable can certainly raise an error after signaling its observers. I don't see a disconnect, if we agree on the intent of `onError`.\n",
        "@jmhofer do you mean stick to traditional single-method observer and don't have an onError callback? (hence no discussion about it)\n",
        "there's several examples of where Throwable is validly sent to callers\n(even defined by Oracle [1] and former JCP members [2]).  I'll defer to Ben\nfor the final decision, but I am obviously not in favor of status quo, and\nwouldn't want to be a consumer of it with this in mind.\n\n[1]\nhttp://docs.oracle.com/javaee/7/api/javax/websocket/Endpoint.html#onError(javax.websocket.Session,\njava.lang.Throwable)\n[2]\nhttps://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/RestAdapter.java\n\n } catch (Throwable t) {\n        throw RetrofitError.unexpectedError(url, t);\n",
        "If we wished to keep the interface, and avoid the \"error made me hang\nforever\" problem, we could update the javadoc and impl such that\nonCompleted() will also be called on an Error (admittedly a confusing\ncompromise).\n",
        "Possibly dead horse, at this point, but _every_ current java async web callback chose throwable, not exception, for error signals.  If we chose to retain Exception as opposed to Throwable, converting to or from these interfaces will be lossy.\n- [Servlet 3.0 AsyncListener](http://docs.oracle.com/javaee/6/api/javax/servlet/AsyncListener.html)\n- [JAX-RS 2.0 InvocationCallback](https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html)\n- [Websocket Endpoint](http://docs.oracle.com/javaee/7/api/javax/websocket/package-summary.html)\n",
        "I agree with the general sentiment that `Error` isn't something you recover from as part of your business logic, but rather a fundamental flaw in app execution, usually due to developer failure (think divide by zero). That said, I don't think onError should take a `Throwable`.\n\nOne problem we ran into, however, was that throwing `Error`s such as `AssertionError` in an observable scheduled on a background thread didn't terminate the app. It would simply continue to execute in what I guess can only be called undefined state. I am not sure yet whether this is something particular about our app or RxJava.\n",
        "I'm strongly against catching `Error`s. A library shouldn't encourage or even tolerate that its users use `Error`s in a wrong way (sticking to Oracle's definition here). In all normal use cases, I wouldn't want to handle any errors in `onError` (which makes the name a bit strange, admittedly). Also, calling `onError` for an `Error` and at the same time rethrowing it would be confusing, imho.\n",
        "I agree that raising the error after signaling is better than swallowing it. -  Still wouldn't want to handle what basically comes down to a developer's error in `onError` though.\n",
        "@adriancole No, I just think that `onError` should keep signalling exceptions, not errors, as it does right now.\n",
        "theoretically speaking, you are right.\n\none practical use case would be when I want to allow observer \nto react to OOME as a way to preserve jvm when \"OOME is not really that bad\".\n\nthere are cases when it is OK for large block heap allocations to fail\nwith OOME for a given \"large\" object, which affects only given object execution path\nand is not detrimental the rest of the JVM\n",
        "sounds like a good idea: using only one: onExceptionResumeNext\n"
    ],
    "3200": [],
    "299": [
        "Not sure how I missed responding to this ... can you provide a unit test to demonstrate the issue?\n",
        "Anyone able to replicate this?\n",
        "No response on this in 6+ months so closing out ... re-open if still an issue. \n\nMany improvements occurred related to error handling in that time.\n\nThis test is passing now:\n\n``` java\n@Test \n    public void testFailOnNextScheduled() throws InterruptedException {\n        Observable<Integer> source = Observable.from(Arrays.asList(1, 2, 3)).observeOn(Schedulers.computation());\n\n        @SuppressWarnings(\"unchecked\")\n        final Observer<Object> observer = mock(Observer.class);\n\n        Observer<Integer> failer = new Observer<Integer>() {\n            @Override\n            public void onNext(Integer args) {\n                if (args > 1) {\n                    throw new RuntimeException(\"Forced failure\");\n                }\n                observer.onNext(args);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                observer.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                observer.onCompleted();\n            }\n\n        };\n        source.subscribe(failer);\n\n        Thread.sleep(1000);\n\n        verify(observer, times(1)).onNext(1);\n        verify(observer, times(1)).onError(any(RuntimeException.class));\n        verify(observer, never()).onCompleted();\n    }\n```\n",
        "This test succeeds due to the fact that `Observable.subscribe` catches the exception from the immediate iteration of the source sequence.\n\n``` java\n@Test \npublic void testFailOnNext() {\n    Observable<Integer> source = Observable.create(toObservableIterable(\n       Arrays.asList(1, 2, 3)));\n\n    @SuppressWarnings(\"unchecked\")\n    final Observer<Object> observer = mock(Observer.class);\n\n    Observer<Integer> failer = new Observer<Integer>() {\n        @Override\n        public void onNext(Integer args) {\n            if (args > 1) {\n                throw new RuntimeException(\"Forced failure\");\n            }\n            observer.onNext(args);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            observer.onError(e);\n        }\n\n        @Override\n        public void onCompleted() {\n            observer.onCompleted();\n        }\n\n    };\n    source.subscribe(failer);\n    verify(observer, times(1)).onNext(1);\n    verify(observer, times(1)).onError(any(RuntimeException.class));\n    verify(observer, never()).onCompleted();\n}\n```\n\nBut when moved to another thread via observeOn, the exception is just swallowed by the threadpool. It is not a problem with the toObservableIterable but with the observeOn not expecting `not.accept(observer)` to throw.\n\n``` java\n@Test \npublic void testFailOnNextScheduled() throws InterruptedException {\n    Observable<Integer> source = Observable.create(toObservableIterable(\n        Arrays.asList(1, 2, 3))).observeOn(Schedulers.threadPoolForComputation());\n\n    @SuppressWarnings(\"unchecked\")\n    final Observer<Object> observer = mock(Observer.class);\n\n    Observer<Integer> failer = new Observer<Integer>() {\n        @Override\n        public void onNext(Integer args) {\n            if (args > 1) {\n                throw new RuntimeException(\"Forced failure\");\n            }\n            observer.onNext(args);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            observer.onError(e);\n        }\n\n        @Override\n        public void onCompleted() {\n            observer.onCompleted();\n        }\n\n    };\n    source.subscribe(failer);\n\n    Thread.sleep(1000);\n\n    verify(observer, times(1)).onNext(1);\n    verify(observer, times(1)).onError(any(RuntimeException.class));\n    verify(observer, never()).onCompleted();\n}\n```\n"
    ],
    "4360": [],
    "4385": [],
    "1363": [],
    "4525": [],
    "6910": [],
    "4278": [],
    "4533": [],
    "508": [],
    "313": [
        "If this is still an issue can you provide a unit test?\n",
        "Under what circumstances can the parent emit an error? The use cases you provide seem contrived, as `mergeDelayError` is a static method and therefore there is not a parent `Observable` to emit an error.\n\n``` java\nObservable.mergeDelayError(o1, o2, o3).subscribe()\n```\n\nIn that code there are 3 `Observable` instances being merged, but no parent to emit an error.\n",
        "Reviewing this again ... the signature where this could be an issue is:\n\n``` java\npublic final static <T> Observable<T> mergeDelayError(Observable<? extends Observable<? extends T>> source)\n```\n",
        "Marking to be included in 1.0 work.\n",
        "Marking as 1.x as this doesn't require a signature change so can be fixed without holding up 1.0\n",
        "I wrote a unit test. An Observable of asynchronous child Observables is calling onError after emitting the child Observables.\n\nI created 2 branches:\n- https://github.com/EmteZogaf/RxJava/tree/mergeDelayErrorNotDelayingParentOnError having the unit test added and is failing.\n- https://github.com/EmteZogaf/RxJava/tree/mergeDelayErrorFix having the unit test and my proposed fix added and is succeeding.\n",
        "I'm sorry for this late reply. I haven't looked into this issue for a while as our project using RxJava is running without any problems. But I will try to update to the new version next month and use base RxJava only without any customizations we made to it back then. If this is still an issue I'll report here.\n"
    ],
    "6024": [],
    "1929": [],
    "5025": [],
    "443": [],
    "432": [],
    "5405": [],
    "1431": [],
    "5978": [],
    "327": [
        "That is odd considering it made it through our build and release cycle. \n\n@daveray any ideas?\n",
        "@jmhofer Does it work for you now that https://github.com/Netflix/RxJava/pull/330 is merged? \n",
        "Great. Thanks for confirming.\n",
        "I wrestled with DummyObservable a bit, but thought I had beaten it. Clearly not. I'll take a look. Sorry about that. \n",
        "I was able to reproduce this, but not consistently. I also found non-deterministic unit test failures during build. See #329 for the full report & link to a gist with transcripts.\n",
        "Yes, works for me now, thanks!\n"
    ],
    "1088": [],
    "329": [
        "I have committed fixes for these that should behave better. There were legit issues in them that depended on specific machine and scheduler timing. I won't be surprised if there are other tests with similar issues in the codebase.\n",
        "Considering this closed ... reopen if you're still seeing these issues.\n",
        "Note that the build failure reported in #327 is one of the errors I encountered.\n",
        "More detail: this seems to be a Java 8 issue. It builds clean with 1.6. \n"
    ],
    "6861": [],
    "6574": [],
    "5518": [],
    "3265": [],
    "333": [
        "Definitely. I was thinking that any incompatibilities rx JavaScript and\nJava implementations might be a deal breaker for kotlin.\n\nOn Saturday, August 31, 2013, Joachim Hofer wrote:\n\n> I agree, these generics should be reordered for consistency.\n> \n> I'll hurry with #331 https://github.com/Netflix/RxJava/issues/331 as it\n> will get difficult to merge as soon as more changes happen. - There's\n> probably still a lot more Observable usages that can be generalized,\n> though...\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/333#issuecomment-23615247\n> .\n",
        "Maybe we get 0.12.0 out the door with https://github.com/Netflix/RxJava/pull/331 right away so it comes along with most people picking up the breaking changes in 0.11.0 as well?\n",
        "I have submitted these changes to https://github.com/jmhofer/RxJava/pull/1 for inclusion in https://github.com/Netflix/RxJava/pull/331\n",
        "I agree, these generics should be reordered for consistency. \n\nI'll hurry with #331 as it will get difficult to merge as soon as more changes happen. - There's probably still a lot more `Observable` usages that can be generalized, though...\n"
    ],
    "5086": [],
    "1050": [],
    "336": [
        "[![Code Bounty](https://app.codebounty.co/reward/image/6b82995d8cf0ea7678754a98)](https://app.codebounty.co/reward/link/6b82995d8cf0ea7678754a98)\n",
        "Excellent observations about the API @xeno-by. Currently, we are preparing exercises for the Coursera class [Principles of Reactive Programming](https://www.coursera.org/course/reactive). For this course we would like to make an idiomatic Scala API. @samuelgruetter is working on that. \n\nThe cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that  adding a Scala wrapper can be only a plus in those cases. \n\nFor polyglot projects we could also take the Java rx.Observable as a common ground (being a return type of each operation and in API signatures). Then all of the Scala support can be added by an implicit conversion (rx.Observable => rx.ScalaObservable). \n\nAs a long-shot maybe the interface for multi and mono lingual projects can be unified so that we do not repeat our selves. IMHO it is worth a try. \n",
        "1c) Even that can be made functional if you replace the subscribe() with .toList().toBlockingObservable().single();\n",
        "1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).\n\n2) Some features that might be desirable in `rx.scala.Observable`: a) native function types, b) native collections, c) method names familiar to folks that use native collections, d) making parameter of `defer` by-name, e) creation of Observables via `apply` rather than via `from`.\n\n3) I also don't think that macros can help with `rx.scala.Observable`, because what you're probably after isn't just a copy/paste of a Java API, but rather a redesign that takes Scala features into account. But if there are some things that can be autogenerated, I'll be happy to answer questions about how macros work and how they can be used.\n",
        "Thanks for providing the design notes!\n\nI wonder though how often people tend to mix languages in their projects. Usability improvements in switching from a Java-based least common denominator to an idiomatic API might be significant. Does being polyglot overweigh these improvements?\n",
        "Thank you for your swift feedback! It's a pleasure to help.\n\n1) I'm not an Rx expert, and in fact this is the first time I see any Rx code apart from random snippets in web articles, so please don't treat this list as definitive. Comprehensive analysis would require quite some time, and I'm not sure I have it right now.\n\na) `Observable.from` could be replaced by `Observable.apply`, so that one can write `Observable(1, 2, 3)` instead of `Observable.from(1, 2, 3)`.\n\nb) It shouldn't be necessary to write `asJava`, e.g. as in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L349, and `asScala` (not sure whether it's necessary now).\n\nc) Use of mutable collections in situations like https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L350 is really inconsistent with Scala's pursuit of immutability. I wonder whether it'd be possible to write such code in a functional way.\n\nd) Instead of taking a no-arg function, `Observable.defer` could take a by-name parameter, which would obviate the need of creating an explicit closure: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L232.\n\ne) For a former C# developer like me, method names like `lastOrDefault` sound familiar, but for the Scala croud out there - not so much. How about changing the names and maybe even signatures, so that they mirror method names of native collections? E.g. `lastOrDefault` could become `lastOption` (also note the change from default values to options).\n\nf) I'm also not sure whether extension methods are even necessary. From what I would guess, in C# they are forced to use them, because interfaces can't define methods with implementations (at least, that was the story with `IEnumerable` and `Enumerable`). In Scala, we can do that, so why not just put all the combinators in `Observable`?\n\ng) `mapMany` in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L351 is essentially `flatMap`, right?\n\nh) No idea how this name could be stated more succinctly, but `toBlockingObservable` feels a bit verbose. When I moved from C# to Scala, in people's code I felt an overall tendency to compress everything, including names. This is kind of a vague observation, so feel free to ignore it.\n\n2) Function literals don't support inference for parameter types unless they are used in a context that requires a Scala native function type. In particular, inference won't work if function literals are supposed to be converted to something implicitly. \n\nE.g. in https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L341 one can't drop type annotations for lambda parameters. I tried removing them and got a compilation error. (Btw why are you using 2.10.1, when 2.10.2 is already available for quite long? Did you have any problems with it?)\n\nThat's an instance of https://issues.scala-lang.org/browse/SI-6221, which has been fixed in 2.11 and probably could be backported to 2.10. If you're in need of an immediate solution, we at EPFL have a compiler plugin for 2.10 that provides a backport.\n",
        "Here is some [background](https://github.com/Netflix/RxJava/issues/204#issuecomment-15249648) on why the current design was chosen rather than having each language with a separate version of Observable:\n\n---\n\nThe approach of having language specific packages/classes was pursued but did not work well because Rx is a composable library. It means that every time an `Observable` is used it needs to be re-wrapped or un-wrapped by whichever language is using it.\n\nFor example ...\n\nFrom Java a library is exposed that has a method like this:\n\n``` java\nrx.Observable getData()\n```\n\nFrom Groovy a library is exposed with a method like:\n\n``` java\nrx.groovy.GroovyObservable getOtherData()\n```\n\nThen from Scala you need to wrap them again:\n\n``` java\nrx.scala.ScalaObservable.from(getOtherData())\n```\n\nThis means we have an `rx.Observable` wrapped as `rx.groovy.GroovyObservable` wrapped as `rx.scala.ScalaObservable`.\n\nTo compose the two we would have:\n\n``` java\nrx.scala.ScalaObservable.zip(rx.scala.ScalaObservable.from(\n      getOtherData()), \n      rx.scala.ScalaObservable.from(getData()),\n       ... scala closure here ...);\n```\n\nNow what does `ScalaObservable` return from its operators? `ScalaObservable` or `Observable`?\n\nShould the above zip operator return `rx.scala.ScalaObservable` or `rx.Observable`? What happens if this library is consumed from another language?\n\nIf `Observable` each step along the way it must be wrapped yet again. If `ScalaObservable` it has now changed all of the return types of `rx.Observable` to a subtype.\n\nIn short, for interop between languages it very quickly becomes a mess and our primary polyglot goal was that `rx.Observable` was usable across all libraries as the single type and because the whole point of Rx is chained composition it's not as simple as just a single decoration at the beginning. It affects every single method in an API and step of the chaining.\n\nFor this reason we chose the current language-adaptor model so `rx.Observable` can remain the sole public interface across languages.\n",
        "At Netflix we are using Clojure, Groovy, Java and Scala and I know of apps running code from at least 3 of those 4 in the same JVM instance. I imagine it's not common in most environment for this type of diversity, but it is something we have wanted to support as seamlessly as possible. This is because we have wanted the `rx.Observable` to act as the interface we can expose across module boundaries as it naturally ends up at the edge of the API in methods such as `Observable<T> getDataFromService(args)`. This is part of what drove us to target the JVM with RxJava and not any specific language.\n\nThat said, an idiomatic solution that works best for pure Scala apps is more important. If we can find a solution that can retain the use of `rx.Observable` without a completely separate wrapper then great, otherwise let's have a `ScalaObservable` for pure Scala apps and a way of going back and forth across language boundaries when it's needed. Perhaps the implicits that exist right now can solve the immediate interop needs for easy interaction from Scala to Java, but the option to convert to `ScalaObservable` would also be there.\n\nAnother piece of information to guide this ... the Rx.Net version in C# is defined by simple interfaces for `Observer` and `Observable` without any of the operator interfaces on them. All of the operator methods (static and instance level) are added via extension methods. It's quite clean and makes the interfaces more flexible (anyone can easily implement them and the extension methods are 'just there' without inheritance involved).\n\nThe reason RxJava has `Observable` as a concrete class is because extension methods don't exist in Java so we don't have a choice but to have them as concrete methods to enable the fluent chaining pattern.\n\nIn Scala however we do have extension methods (implicits), macros etc that theoretically can allow the `rx.Observable` to be made into whatever it needs to be for idiomatic Scala usage, similar to how C# implements Rx.Net using extension methods. I imagine a possible issue is if existing methods on `rx.Observable` are in the way and cause problems in achieving idiomatic Scala functionality, if that's the case I'd like to understand what those issues are and if they can be resolved and if not if they really are deal breakers.\n\nAt this point I become not so helpful as I am not skilled enough in Scala to have a valid opinion or guide the conversation much further. I do have some questions though for the Scala experts here:\n\n1) What would make `rx.Observable` idiomatic for Scala?\n\nI'd like to see unit tests or sample code demonstrating expected behavior and usage so that we're all working towards the same goal and know when we've achieved success.\n\n2) What about the current `rx.Observable` + Scala implicits is not working well?\n\n3) What requirements of (1) can not be achieved with implicits and macros and requires a separate concrete class as a wrapper?\n\nThank you everyone for your involvement, I really do want us to find the ideal solution for Scala and then as a secondary priority make it work well across the JVM for polyglot applications.\n",
        "Scala 2.10.2 support was added in version 0.11.2 (https://github.com/Netflix/RxJava/releases/tag/0.11.2).\n",
        "> The cross language compatibility pointed out by @benjchristensen is a reasonable concern. However, I think there is a lot of monolingual projects out there that would greatly benefit from the idiomatic Scala library. It seems to me that adding a Scala wrapper can be only a plus in those cases.\n\nI completely agree if a wrapper is the only way to achieve idiomatic support. Monolingual projects should take first priority as that is the common case.\n",
        "If anything about the core Java library is causing issues let me know.\n",
        "Covariant support has been merged into master. This also changes the type used with `Observable.create`.\n",
        "I believe all of the structural changes are now merged to master. Are there any other changes that should be made before we release 0.12 so as to better support Scala integration?\n",
        "@samuelgruetter is there something we can do in the short-term to work around this issue? Is there anything about the core library that if changed would simplify this effort?\n\n@aloiscochard What about the approach being pursued (if the compiler bugs didn't exist) is a mistake?\n",
        "Those changes will be in 0.12 which has not been released yet. It was merged to master yesterday. \n\nBefore releasing I wanted to determine if this thread of discussion required any further changes to core, and I want to get in https://github.com/Netflix/RxJava/pull/349 as well since it generalizes some objects in `rx.util` which hopefully gets confirmed today.\n\nIs there anything else that if done in core for release 0.12 would improve Scala support?\n",
        "Then once I wrap up those other things (hopefully today) I will release 0.12. I fully expect we'll find more to change ... hence us not being at 1.0 yet :-)\n",
        "Due to the 2 bugs, are we unable to pursue the route where `rx.Observable` is the return type at this time?\n\nAlso, since I'm unfortunately not yet very experienced with Scala, in your examples would you mind demonstrating a use case where a ScalaObservable is exposed back to Java for interop? I'm interested in understanding how the solution being worked on would function in polyglot environments (while understanding this is a secondary priority).\n",
        "Version 0.12 has been released. \n",
        "It could go direct against the internal static operators instead of us putting an unnecessary static reduce on `Observable`.\n\n``` java\nObservable.create(OperationScan.scan(observable, accumulator)).takeLast(1);\n```\n",
        "Varargs have been removed from `Observable`: https://github.com/Netflix/RxJava/pull/361\n",
        "Investigating issues with `reduce` covariance at https://github.com/Netflix/RxJava/issues/360#issuecomment-24128500.\n\nIt works when done statically instead of via an instance method: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/ReduceTests.java#L39\n",
        "Sounds great @samuelgruetter, I'm happy to hear that we can achieve idiomatic Scala and Java interop cleanly without converting back and forth!\n\nDo the compiler bugs prevent us from moving forward or are their sufficient workarounds for now?\n\nI am planning on releasing 0.13 with the changes merged to master shortly. Is there anything else you need to core to support `rx.lang.scala.Observable`?\n",
        "The 'throttle' operator was just merged to master as `debounce``throttleWithTimeout`. See https://github.com/Netflix/RxJava/pull/368 for an explanation of the 3 variants of`throttle` that were committed.\n\nWe do not yet have `distinctUntilChanged` but that shouldn't be hard to get added.\n",
        "That's great that workarounds exist so we can move forward, I look forward to hearing how the autocomplete example works.\n\nIf you can get that functioning is that strong enough evidence to move forward with it or are there still pieces of functionality lacking?\n\nHow do you envision ongoing maintenance of this class? Do all new operators added to `rx.Observable.java` required wrapping methods, or does it pass thru if a wrapper isn't there?\n",
        "Good to know regarding maintenance ... we'll need to figure out a reasonable way of handling that as operators get added.\n\nDo you have an idea of when I should expect a pull request with this new Scala Observable?\n\nIs this a breaking change to how the implicits support currently works for Scala, or does this wrapper only take effect when someone imports `rx.lang.scala.Observable` instead of `rx.Observable`? Can the existing implicits continue existing alongside?\n",
        "Pull https://github.com/Netflix/RxJava/pull/376 has been released in [0.13.1](https://github.com/Netflix/RxJava/releases/tag/0.13.1)\n\nThank you @samuelgruetter!\n",
        "> Btw RxImplicits and ImplicitFunctionConversions are almost the same, except that ImplicitFunctionConversions does not contain an implicit class ScalaObservable.\n\nWith that one difference does it still require the two existing, or can `ImplicitFunctionConversions` perform the same functionality as `RxImplicits` and negate it's need? Or does having `RxImplicits` around still help for any use cases?\n",
        "Removing `RxImplicits` will be breaking for people until they change their import from `rx.Observable` to `rx.lang.scala.Observable` correct? If so I will bump the version to 0.14 when I merge this change.\n\nCan someone also please update the README (https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/README.md) to show usage information to help someone get started?\n",
        "+1 on this. There are other places where `Func*` are used, such as `BlockingObservable` not yet wrapped, and as new things are added, if they don't yet have a full wrapper there should still be a way to use them with the implicits.\n",
        "> it might be cool to have a unit test in which we encode the information \"which Java method corresponds to which Scala method\", and using reflection, we check if there is a Scala method for each Java method. So if a method is added to the Java Observable but not to the Scala Observable, this test would fail.\n> \n> And if we add a unit test as I outlined at the bottom of this comment, keeping the Scala Observable up to date would become easier.\n\nWe can't make the build fail if `rx.lang.scala.Observable` is out of sync. We can't block the project from building and releasing just because a new operator is added and the developer adding it isn't comfortable deciding what the idiomatic Scala method signature should look like.\n\nIt needs to be an async process for Scala developers to add wrapper methods/classes. Since this is open source we can't control people's schedule and require quick turnaround on adding the wrappers. Ideally that will happen when new functionality is added, but we can't make building and releasing dependent on that.\n\nThus, I think we need to account for the fact that most things will have wrappers but very newly added functionality or fringe functionality may not and should still have a mechanism for being used.\n",
        "Erik Meijer and I have discussed this but it doesn't feel like the right thing to do, as it would hurt the JVM ecosystem more than benefit it if the different languages forked from each other.\u00a0\n\nThere is no harm in a new version of RxJava being released without the Scala adaptor adding the new functionality, as that is no different than a separate RxScala project not yet supporting it on top of the RxJava core dependency.\n\nAs we approach 1.0 the rapid iteration will slow and this will become less of an issue. Around that time as well the project may migrate into a different home than here.\nOn September 16, 2013 at 3:20:07 PM, Chris Richardson (notifications@github.com) wrote:\n\nIf you want rxjava-core to evolve independently then perhaps rxjava-scala  \nand other language adapters should each be a separate top-level project  \nwith its own release cycle.\n",
        "Closing this out as completed ... further progress/bugs can use new issues.\n\nGreat work and thank you everyone involved on this.\n",
        "So does it make sense to mark them deprecated since they're still usable and possibly useful for someone accessing operations that haven't made their way to this curated wrapper? Just checking.\n",
        "Removing duplication makes sense. Since `rx.lang.scala.internal.ImplicitFunctionConversions` is escape hatch (besides manually using Func1 and friends) for stuff not covered by the Scala wrapper, would it make sense for it not to be in an internal package?\n",
        "@samuelgruetter It's up to you guys. I'll just leave with this: open source projects live a lot longer than the enthusiasm of their contributors so I'm skeptical of a wrapper that assumes it will always be kept completely up-to-date with complete coverage forever. If some third party decided to create a project of custom observables beyond what's in RxJava, those would be more difficult to use, assuming users respect the implication of \"internal\" in the package name. I'll go back to Clojure-land now :)\n",
        "@martin-g Right. And if for whatever reason some poor Scala programmer finds herself in yucky Java-land calling these mehods, at least throw her a bone and make the Func implicits available in a non-internal package.\n",
        "scalac is indeed inconsistent, it goes the extra mile to try an implicit view when the originally tried method is monomorphic, but doesn't do the same if it is polymorphic.\n\nThat's unlikely to change soon, even in 2.11.\n\nBut, one change that is likely in the 2.11 timeframe is first class support of SAM types, which would let you write an anonymous function that would be translated to `rx.Func1`.\n\nBTW, it's really great to see this discussion and cooperation happening!\n",
        "@samuelgruetter  You can work around the bug by explicitly provide a type argument. I've isolated and reported this issue, along with the workaround, here: https://issues.scala-lang.org/browse/SI-7818\n",
        "@samuelgruetter The particular bug only affects you when you define the value class. Clients of the class are safe.\n",
        "> 1) Implicit-based integration with Java-based observables has a serious flaw as it doesn't support parameter type inference for lambdas. The situation isn't going to change until https://issues.scala-lang.org/browse/SI-6221 is fixed. It's definitely fixed in 2.11, and at EPFL we have a compiler plugin that backports the fix to 2.10. Probably Typesafe folks can be convinced to do the backport in one of 2.10.x releases (/cc @adriaanm @gkossakowski @retronym @JamesIry).\n\nSorry, we don't change type inference in minor versions unless there's a critical bug.\nThe risk of regression in source compatibility is too high.\n",
        "A few comments from my point of view (since I first looked at this project, I always wanted to use it from Scala):\n\nNow that the core is typesafe, imho we have the first workable Scala integration (via implicits). From here on, everthing depends on how much effort we want to put into this vs how convenient it will be for the users.\n\nWhat we already have is that the most important method names match (`map`, `flatMap`, `filter`). Matt also made Scala for-comprehensions work with observables.\n\nThere's a lot of room for improvements, though. It seems that due to Scala-Java interop, there are problems with type inference (I even ran into a Scala compiler crash somewhere), and sometimes `asJava` collection conversions are necessary. Also, Scala/Akka futures are not yet addressed at all. An Akka-specific scheduler would probably be awesome to have, too.\n\nFor full Scala user convenience, we'd probably have to completely wrap `rx.Observable` into its own `rx.scala.Observable`. This would mean a lot more maintenance effort for the Scala integration, of course (I don't think we can do this automatically via code generation or macros, but I'm no expert of all that). But still, I think it's well worth it to create a dedicated Scala API.\n",
        "I'm not sure if wrapping `Observable` for Scala (not in a subclass though) would really hurt so much. Imho it's worth a try to find out how it feels. There will be a lot of wrapping and unwrapping behind the scene though, I'm afraid.\n",
        "Thanks for all the observations! I'll try to address some of the ones from @xeno-by.\n\n1a), 1e) and 1g) are just aliasing problems, imho. We already have `flatMap` as alias for `mapMany`, and the other aliases could easily be added, either directly in `rx.Observable`, or in a Scala wrapper, if the namespace gets too big otherwise (not my preferred solution). Methods returning options will have to live in a Scala wrapper, however.\n\nI didn't take a look at 1b) and collection conversions yet. This really shouldn't be necessary often, if at all.\n\n1c) You're looking at test code here which tests the callback \"at the end of the world\". This is not really normal usage of the API. The whole RxJava codebase is refreshingly (though not completely) free of mutability, if you ask me. Also, the Rx API is actually there to allow you to handle all your events in a functional, immutable way. - In short, I don't see a problem here.\n\n1d) is Scala-specific. By-name parameters are a great feature for methods like `defer`, I agree. We should make use of them in the Scala wrapper.\n\nI'm not worried about 1f) either.\n\n1h) I like the verbose name in this specific case. Imho, it's the same as `asInstanceOf` in Scala: Maybe I'm evil, but I like to punish people who do things they probably shouldn't do. :) Ok, there will of course be valid use cases for blocking observables, but there shouldn't be too many of them, hopefully.\n\n2) is quite a big problem, if you ask me. A backport of the fix to Scala 2.10 would be great. We can probably get around this with a dedicated Scala wrapper, though.\n\nAnd the reason for 2.10.1 instead of 2.10.2 is currently just a technical problem with the build system. I, too, hope that this will be fixed soon.\n",
        "@abersnaze You're right, good point.\n\nI started a little experiment with a more idiomatic Scala wrapper. It's just humble beginnings currently, though. You can find it [here](https://github.com/jmhofer/RxJava/blob/scala-wrapper/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala). \n\nComments and forks are welcome, of course. I started from the super-extends pull request in order to check how this whole thing feels in Scala.\n",
        "@samuelgruetter Sounds awesome! Very much looking forward to your sharing the code.\n",
        "Great, thanks! I'll play around with it, too.\n",
        "Maybe there's a 2nd implicit somewhere, adding map?\n",
        "Just another guess, but then it's maybe due to the type parameter of `map` (your `reduce` doesn't have one; you renamed the one with type parameter to `fold` which luckily avoids the problem).\n",
        "So, to make polymorphic methods like `map` work, we'd have to return ScalaObservables, not (Java)Observables everywhere, I guess (which doesn't pose a problem anyway as far as I can see)?\n\n@aloiscochard: Is that what you mean by \"a full wrapped scala version\"? - Because I thought that @samuelgruetter's goal was already to create a full wrapped scala version.\n",
        "@benjchristensen I don't see any problem with switching to the approach where we stay with intermediate ScalaObservables throughout the wrapper. As `ScalaObservable` is a value class, it shouldn't even impact performance at all.\n",
        "@samuelgruetter If I'm not mistaken, there was no release yet after the merge of the co-/contavariance branch. 0.11.3 was right before that. I'm afraid that you'll have to wait for 0.11.4 (or 0.12, more likely), or you'll have to work directly on the repo build of RxJava.\n",
        "I'd prefer calling `.wrapped` `.asJava` instead (like the collection `JavaConverters` do).\n",
        "@samuelgruetter Good idea!\n\nAnd: Yay, finally a covariant observable! Awesome! I've been working towards this all the time...\n",
        "Try it with an explicit type parameter for the Java method: `new Observable(JObservable.synchronize[T](asJava))`\n\nWorks for me, at least.\n",
        " @samuelgruetter Could you explain the problem with the `reduce` signature please?\n\nDo you mean by your TODO that this needs a second type parameter `U` with `U extends T` etc instead of simple wildcards in Java, too?\n",
        "I think it would be possible to work around that by making `reduce` static and giving it two type parameters `<U, T extends U>`. With this, we could probably simplify the type parameters of the instance method, dropping covariance in that place, and instead get the full covariance via the static method. Scala could just use the static method. \n\nI'm not sure whether we want that.\n\nOr maybe there's a more direct workaround via casting (yuck). Haven't tried anything like that out yet.\n",
        "Value classes are awesome. This means we don't even need to convert back to Java Observables anywhere. Thanks for the example.\n",
        "We believe that the following solution would be best:\n-   Implicit value class (let's call it `ScalaObservable` for the moment) wrapping an rx.Observable\n-   all return types are `rx.Observable`\n-   Since `ScalaObservable` is a value class, there is no runtime overhead for the wrapping (some explanations can be found in the second half of this [blog post](http://www.blog.project13.pl/index.php/coding/1769/scala-2-10-and-why-you-will-love-implicit-value-classes/)). This is new in Scala 2.10, and actually allows us to have extension methods similar to C#.\n-   An object `FunctionConversions` containing all implicit conversions from Scala functions to Rx functions (the same as in the present [Scala adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L29)). These conversions are only used by the adapter, users of Scala Rx won't use them.\n-   All instance methods of `rx.Observable` which take a Func or an Action have a wrapper method in `ScalaObservable` whose signature has Scala functions and whose body uses the conversions from `FunctionConversions`\n-   `ScalaObservable` has map, flatMap, filter, like in the [present adaptor](https://github.com/Netflix/RxJava/blob/rxjava-0.11.1/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala#L108) to enable for comprehensions\n-   `ScalaObservable` has `lastOption` method instead of `lastOrDefault` etc\n-   functions passed by Rx Scala users to Observable needn't be implicitly converted, so we're not affected by the [bug](https://issues.scala-lang.org/browse/SI-6221) that parameter type inference of implicitly converted functions does not work in Scala 2.10\n-   An `object Observable` with `apply` methods instead of `from` and `create`\n-   polyglot projects can also use this approach\n\nI've started to implement such an adapter and will post some code soon.\n\nNote that I've not (yet) addressed the following points:\n-   compatibility with Scala/Akka futures\n-   how to integrate `ScalaObservable` with Scala collections to get all methods of Scala's [Traversable](http://www.scala-lang.org/api/current/index.html#scala.collection.Traversable)\n",
        "You can see what I'm doing [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/ScalaAdapter.scala). Note that it's still very incomplete and not yet tested, but work is in progress.\n",
        "There's an interesting problem with `map`: If I add an explicit conversion like `ScalaObservable(numbers).map(...)`, it works, but without, i.e. `numbers.map(...)` gives an error... I'll investigate on this. You can see the corresponding test [here](https://github.com/samuelgruetter/rx-playground/blob/365a7ba8afa4feda1f5961a3a21c524092caf8f4/RxScalaAdapter/src/main/scala/rx/lang/scala/Adaptor.scala#L497)\n",
        "There's no 2nd implicit, but there's a second `map`: The `map` in rx.Observable. And scalac wants to use this one and does not convert to `ScalaObservable`. However, with `reduce`, it works...\n",
        "I've isolated the implicit conversion problem [here](https://github.com/samuelgruetter/rx-playground/blob/master/ScalaImplicitsProblem/src/main/scala/ScalaImplicitsProblem.scala). It's a problem with the Scala compiler.\n@benjchristensen looking forward to a jar with covariant observables!\n",
        "I agree with @jmhofer. I've started such a Scala Observable which always returns Scala Observable, see [here](https://github.com/samuelgruetter/rx-playground/blob/master/RxScalaAdapter/src/main/scala/rx/lang/scala/Observable.scala)\n",
        "@benjchristensen I'm confused about the jar releases. I thought they have contained @jmhofer 's changes for proper covariance/contravariance handling since 0.11.2, but apparently they don't:\n\nIn `rxjava-core-0.11.3.jar`, `flatMap` looks like this:\n\n```\npublic <R> Observable<R> flatMap(Func1<T, Observable<R>> func) {\n    return mapMany(func);\n}\n```\n\nOn github master, `flatMap` looks like this (that's what I would like to have in the jar):\n\n```\npublic <R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? extends R>> func) {\n    return mapMany(func);\n}\n```\n",
        "I can't currently think of anything that if done in core for release 0.12 would improve Scala support. But probably I'll find such things just after 0.12 is released ;-)\n",
        "I've forked the RxJava repo and I'm now working [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala).\n",
        "Well now I have a Scala compiler bug... It's [here](https://github.com/samuelgruetter/RxJava/blob/idiomaticscala/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L168). I don't know yet what to do about that.\n",
        "Thanks @retronym. Is this going to be fixed in Scala 2.10.x? I'm asking because we want to use the Rx Scala Wrapper for a course in November, and we don't want to confront students with compiler bugs. So we consider temporarily removing `extends AnyVal`, until the interplay between value classes and covariance can be considered stable.\n",
        "ok, so we'll keep using `extends AnyVal`, unless it leads to more problems...\n",
        "This [Observable.scala](https://github.com/samuelgruetter/RxJava/blob/955fbfcdfdd2ce12ac2ee578d63c8edd734f8444/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala) now contains all methods present in the Java Observable, **but** for many of them, there is only a comment containing their signature and a note on the problem I faced. You can find all these interesting problems by searching for `TODO`.\n",
        "I'm planning to continue as follows:\n-    Add some tests to `Observable.java`. Their goal is not to test the correct behavior of the methods (that's already done in the unit tests of the operations), but to test if the method signatures of `Observable` are good, and to provide small usage examples.\n-    I expect these tests to reveal some issues related to covariance. Fix these.\n-    Continue with the Scala adaptor.\n",
        "I think that `reduce` needs a type parameter `U` with `U super T` in the Java Observable. And similar changes will be needed for other methods as well, in order to make sure that the `T` of `Observable<T>` never occurs in a contravariant position. I'll post corresponding code soon.\n",
        "I added tests to [CovarianceTest.java](https://github.com/samuelgruetter/RxJava/blob/b59b68d7361bbb01604e2feaeba904a6b4cbd85c/rxjava-core/src/test/java/rx/CovarianceTest.java), which I would like to compile, but they don't, and I think that the signatures in `Observable.java` need to be tweaked.\nThe tests which do not compile are marked with `might-not-compile`.\nI will now try to tweak `Observable.java` as needed.\n",
        "The signature of `reduce` in `Observable.java` currently looks like this:\n\n```\npublic Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator) {\n                                                        ^^^^^^^^^^^\n```\n\nThe problem with this is that the underlined `T` appears in a contravariant position. This means that we cannot say anymore that `Observable<T>` is covariant in `T`, and we cannot use Observable as we would like to:\n\n```\npublic void libraryFunctionActingOnMovieObservables(Observable<? extends Movie> obs) {\n    Func2<Movie, Movie, Movie> chooseSecondMovie = \n        new Func2<Movie, Movie, Movie>() {\n            public Movie call(Movie t1, Movie t2) {\n                return t2;\n            }\n        };\n    Observable<Movie> reduceResult = obs.reduce(chooseSecondMovie); // <- weird error\n    // do something with reduceResult...\n}\n\npublic void codeUsingTheFunction() {\n    Observable<HorrorMovie> horrorMovies = Observable.from(new HorrorMovie());\n\n    // do something with horrorMovies, relying on the fact that all are HorrorMovies\n    // and not just any Movies...\n\n    // pass it to library (works because it takes Observable<? extends Movie>)\n    libraryFunctionActingOnMovieObservables(horrorMovies);\n}\n```\n\nThe above code should compile, but instead produces a weird compilation error.\n\nNow let's see how Scala solves this: The signature of reduceLeft in the Scala immutable collections (which are covariant in their type parameter `A`) looks like this:\n\n```\ndef reduceLeft[B >: A](f: (B, A) => B): B\n```\n\nThe trick is to add a type parameter `B` to the method, whose lower bound is `A`. Now `A` only appears in covariant positions, and we're fine.\n\nSo I thought we could just do the \"same\" in Java:\n\n```\npublic <U super T> Observable<U> reduce(Func2<? super U, ? super T, ? extends U> accumulator)\n```\n\nBut, unfortunately, Java does not support lower bounds for type parameters.\n\nSo, this makes me think that Java's type system is not powerful enough to properly support covariant Observables.\n\nBecause of this, I will now return to the Scala adaptor, and try to implement a covariant Scala Observable, which uses casts where necessary. If we later find a way to get rid of the casts, all the better.\n",
        "I can now confirm that the solution with value classes is indeed as awesome as we expected :D\nI wrote a very small example showing how Java code can use Scala code: There's a [MovieLib.scala](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scalatests/MovieLib.scala), which uses Scala Observables everywhere.\nIn a second project, there is [MovieLibUsage.java](https://github.com/samuelgruetter/RxJava/blob/0603e395b680655a923e138582d779c65d001651/language-adaptors/rxjava-scala-java/src/main/java/rx/lang/scalaexamples/MovieLibUsage.java), which uses `MovieLib` as a class which uses Java Observables everywhere, because Scala value classes are such that the Scala Observables appear as Java Observables for the Java compiler.\nThe only challenge here is to set up the build process correctly: In this scenario, the Scala sources have to be built first, and then the Java sources. I achieved this by making a seperate project for `MovieLibUsage`, which depends on the project containing `MovieLib`.\n",
        "We have sufficient workarounds for the compiler bug.\n\nThere's nothing fundamental that we need for the Scala adapter right now, but I'm currently trying to translate the dictionary autocomplete example written in C# from this [Rx Hands On Lab](http://blogs.msdn.com/b/rxteam/archive/2010/07/15/rx-hands-on-labs-published.aspx) to Scala to see what we can already do. For this, I miss the `distinctUntilChanged` and the `throttle` operator, so these are currently on top of my whishlist ;-)\n",
        "If I can get the autocomplete example functioning then I think that's strong enough evidence to move forward with it. We still lack operations in the wrapper, but it should be possible to add them all.\n\nThis adapter will require some maintenance. New operators added to the Java observable will have to be added to the adapter as well, and updates of the documentation too, because the signatures are too different to automate this. \nHowever, if really needed, one can always call `.asJava` on a Scala observable and use the Java methods directly, and if the implicit function conversions from Scala functions to Java Func/Action are imported, one could even use Scala functions. But that's not the intended way of using it and should only be used in quick hacks.\n",
        "It's not a breaking change: The old `RxImplicits` are still there and usable, but marked as deprecated.\n",
        "If an operation from `rx.Observable` has not yet made it to `rx.lang.scala.Observable`, there are the following solutions (ordered by my preference):\n-    report an issue to get the operation into `rx.lang.scala.Observable` ;-)\n-    call `.asJava` on the Scala observable and use the implicit conversions from `rx.lang.scala.internal.ImplicitFunctionConversions`\n-    use the old `RxImplicits`\n",
        "Btw `RxImplicits` and `ImplicitFunctionConversions` are almost the same, except that `ImplicitFunctionConversions` does not contain an `implicit class ScalaObservable`.\n",
        "If there is already code out there depending on `RxImplicits`, we need to keep it to remain compatible with that code. If not, we can remove `RxImplicits` without any loss of functionality.\n",
        "@mattrjacobs Good idea.\n\n@daveray Well the goal should be that there is no such thing as \"stuff not covered by the Scala wrapper\"... Having `ImplicitFunctionConversions` in an internal package would increase the pressure to keep the Scala Observable in sync, which is a desired effect. And if we add a unit test as I outlined at the bottom of [this comment](https://github.com/Netflix/RxJava/pull/376#issuecomment-24439163), keeping the Scala Observable up to date would become easier.\n",
        "I like @daveray's point: If some third party decided to create a Java project of custom observables beyond what's in RxJava, and we want to use this project from Scala, then we need the `ImplicitFunctionConversions`. So I will make this non-internal.\n\n@benjchristensen I agree that it would be kind of crazy to make the build fail just because `rx.lang.scala.Observable` is out of sync.\n",
        "@samuelgruetter All of that sounds great.  I'll take a look next week and offer feedback.\n",
        "Given that there's no loss of functionality, I think it makes the most sense to remove `RxImplicits` and not introduce the chance of newcomers to RxJava depending on unsupported functionality.  I'll generate a pull request to this effect\n",
        "@martin-g Correct me if I'm wrong, but dropping down to using rx.Observable still mandates passing in `Func1/Func2`/etc.  Being able to use native Scala functions and the implicits in this case seems far better than forcing user code to new up these function types and pass them in.\n\nAfter thinking about it, +1 to @daveray's idea of making both the value class and implicits available (with the value class preferred).  This will allow any temporary mismatch between `rx.Observable` and `rx.lang.scala.Observable` to be addressed by implicits while not impeding non-Scala developers from moving core along.\n",
        "IMHO, after looking at the code, using implicits convertions is not a good idea.\n\nI think you have better to start with a complete wrapper of the API, then you'll be able to apply scala idiom (basically writing a DSL) instead of having a Java API with some facilities for converting type.\n\nAnd that way you don't have to wait for https://issues.scala-lang.org/browse/SI-6221 ... which sounds anyway like a clumsy integration of Java API to me.\n",
        "@samuelgruetter what is the error? if @jmhofer is right you should have an `amibgous` implicit resolution error.\n",
        "@samuelgruetter I'm pretty sure no one could make the scala compiler be able to solve an ambiguity like that one.\n\nIf you where the compiler, which method you think should be choosed?\n\nYou guys should seriously consider implementing a full wrapped scala version first, and keep multi-lang support as a cherry on cake.\n\nIMHO it's a mistake to do the opposite, maybe I'm wrong but I think most scala user will want to use it in a full scala project.\n\nAnd for the course, it would be good to have an idiomatic API.\n",
        "@jmhofer yeah it's exactly what I meant :-)\n\nBy doing that you'll be able to provide the best possible syntax for RX API, looking forward next enhancement!\n",
        "@benjchristensen I would say it's kind of bad design, a form of overloading abuse. I would go the type-class way (on a similar Wrapper than @jmhofer one) to make a map function polymorphic.\n\nAnyway, the current approach took by @samuelgruetter looks good!\nAs @jmhofer said there should be no perf impact as long as you keep a value class, and from what I've seen there should be no reason to need more than one value in the wrapper.\n\nI have some remarks but I'l make them directly on @samuelgruetter commit as I did before.\n",
        "if you call `.wrapped` on a `ScalaObservable` you get back the original `Observable` which can be used with the Java API.\n\nMaybe we could find a better name that wrapped, not easy though ;-)\n",
        "@samuelgruetter great stuff!\n",
        "@samuelgruetter I just took a quick look, nice progress.\n\nLooks like most of your issues are related to covariance, I haven't look in depth but there is some trick to workaround this kind of thing in scala... not sure if possible to apply them here.\n\nI'll try to take a look during the week and give you feedback... not sure when unfortunately.\n\nI've seen some comments where you hesitate returning the scala wrapped version or the java one, I would say that for a first version, just return the scala one.\n\nYou can refine that later trying to find where you can return the native type, IMO it's a nice to have but clearly not absolutely needed when using the API in pure scala.\n\nAbout `Future`, I think it should be quite easy to create a wrapper to expose scala future as java one, have you tried implementing the java future interface backed by a scala one?\n",
        "@daveray ScalaObservable has a method to get the wrapped Java Observable, so you should be able to use any method from its API.\nAnd since the project is Open Source you can always send a Pull Request and improve it ;)\n",
        "If you want rxjava-core to evolve independently then perhaps rxjava-scala\nand other language adapters should each be a separate top-level project\nwith its own release cycle.\n\nOn Mon, Sep 16, 2013 at 2:55 PM, Ben Christensen\nnotifications@github.comwrote:\n\n> it might be cool to have a unit test in which we encode the information\n> \"which Java method corresponds to which Scala method\", and using\n> reflection, we check if there is a Scala method for each Java method. So if\n> a method is added to the Java Observable but not to the Scala Observable,\n> this test would fail.\n> \n> And if we add a unit test as I outlined at the bottom of this comment,\n> keeping the Scala Observable up to date would become easier.\n> \n> We can't make the build fail if rx.lang.scala.Observable is out of sync.\n> We can't block the project from building and releasing just because a new\n> operator is added and the developer adding it isn't comfortable deciding\n> what the idiomatic Scala method signature should look like.\n> \n> It needs to be an async process for Scala developers to add wrapper\n> methods/classes. Since this is open source we can't control people's\n> schedule and require quick turnaround on adding the wrappers. Ideally that\n> will happen when new functionality is added, but we can't make building and\n> releasing dependent on that.\n> \n> Thus, I think we need to account for the fact that most things will have\n> wrappers but very newly added functionality or fringe functionality may not\n> and should still have a mechanism for being used.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/336#issuecomment-24548044\n> .\n"
    ],
    "203": [],
    "5343": [],
    "647": [],
    "342": [
        "Yeah, `switchOnNext` is a lot better! Since the PR is merged, can't we close this?\n",
        "Just submitted pull request for this ... does anyone have an opinion? People I've asked agree with changing from `switchDo` to `switchOnNext`.\n",
        "Proceeding then, that's enough votes for me.\n",
        "`switchOnNext` is a better name. Works for me.\n",
        "I agree. `switchOnNext` is a lot better.\n"
    ],
    "6709": [],
    "3249": [],
    "2817": [],
    "5888": [],
    "5187": [],
    "6589": [],
    "3684": [],
    "766": [],
    "359": [
        "Like the zip operator?\n\nSent from my iPhone\n\nOn Sep 9, 2013, at 1:50 AM, samuelgruetter notifications@github.com wrote:\n\n> Unless someone shows me how to get rid of this warning without using @SuppressWarnings(\"unchecked\"), I would suggest that we remove the varargs methods and add instead\n> \n> an overloaded method for each arity\n> a method taking an Iterable (will be used by the Scala adaptor)\n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "That issue with varargs is definitely one of the weaknesses of generics. \n\nHow about if we had overloads for up to 9 arities, and then on that one have a 10th vararg for scenarios were people truly do want/need more? That way it would only affect someone using beyond 9 args?\n",
        "I meant something like this ...\n\n``` java\nconcat(T t1, T t2)\n... etc ...\nconcat(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8)\nconcat(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9)\nconcat(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T... rest)\n```\n\nI will start refactoring vararg method signature later today or tonight (US Pacific time) unless someone else is already doing it. If one of you already are tackling this please let me know here so we don't replicate effort.\n",
        "Closing as I have removed all varargs from Observable.\n",
        "The `@SafeVarargs` annotation allows us to solve this. Trying to figure out if we can leverage this Java 7 feature without breaking Android support (which is obviously more important).\n",
        "The same problem also occurs with `merge`, `mergeDelayError`, and if arguments with generic type are passed to `from` and `startWith`, they are also affected.\n",
        "Unless someone shows me how to get rid of this warning without using `@SuppressWarnings(\"unchecked\")`, I would suggest that we remove the varargs methods and add instead\n-    an overloaded method for each arity\n-    a method taking an Iterable (will be used by the Scala adaptor)\n",
        "yes\n",
        "I don't quite get what you mean by \"a 10th vararg for scenarios...\" but I'd also be fine with overloads for up to 9 arguments, plus another overload which takes only 1 argument of type `Collection<Observable<T>>` or `Iterable<Observable<T>>`, so if people want more than 9 arguments, they have to construct a list containing the arguments and pass this list to `concat`.\n"
    ],
    "360": [
        "I remember reading in effective java that the only type that can satisfy the super T and extends T is just T.\n",
        "One issue is with `concat`:\n\n``` java\npublic static <T> Observable<T> concat(Observable<Observable<? extends T>> observables)\n```\n\nThat works with this:\n\n``` java\n    public void testConcatCovariance() {\n        Observable<Media> o1 = Observable.from(new HorrorMovie(), new Movie());\n        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());\n\n        Observable<Observable<Media>> os = Observable.from(o1, o2);\n\n        List<Media> values = Observable.concat(os).toList().toBlockingObservable().single();\n    }\n```\n\nbut it doesn't work with this:\n\n``` java\n    public void testConcatCovariance2() {\n        Observable<Media> o1 = Observable.from(new HorrorMovie(), new Movie(), new Media());\n        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());\n\n        Observable<Observable<Media>> os = Observable.from(o1, o2);\n\n        List<Media> values = Observable.concat(os).toList().toBlockingObservable().single();\n    }\n```\n\nWhen both types are `Media` the `Observable` ends up being `Observable<Observable<Media>>` instead of `Observable<Observable<? super Media>>` and then `concat` fails. This is not at all ideal, especially since it's more common to be concatenating multiple Observables of the same type.\n\nIf I change concat to this and remove the `? extends`:\n\n``` java\npublic static <T> Observable<T> concat(Observable<Observable<T>> observables)\n```\n\n... the `testConcatCovariance2` example works and `testConcatCovariance1` fails unless I change this line:\n\n``` java\nObservable<Media> o1 = Observable.<Media>from(new HorrorMovie(), new Movie());\n```\n\nPersonally I prefer doing that when dealing with super types than making `concat` be forced to deal with it all the time.\n\nIf you skip to `Observable.from(o1, o2)` step which confuses the generics and go directly to `concat` then it's even cleaner. \n\nThis uses:\n\n``` java\npublic static <T> Observable<T> concat(Observable<? extends T> t1, Observable<? extends T> t2)\n```\n\nBoth of these work:\n\n``` java\n    @Test\n    public void testConcatCovariance3() {\n        Observable<Movie> o1 = Observable.from(new HorrorMovie(), new Movie());\n        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());\n\n        List<Media> values = Observable.concat(o1, o2).toList().toBlockingObservable().single();\n    }\n\n    @Test\n    public void testConcatCovariance4() {\n\n        Observable<Movie> o1 = Observable.create(new OnSubscribeFunc<Movie>() {\n\n            @Override\n            public Subscription onSubscribe(Observer<? super Movie> o) {\n                o.onNext(new HorrorMovie());\n                o.onNext(new Movie());\n                //                o.onNext(new Media()); // correctly doesn't compile\n                o.onCompleted();\n                return Subscriptions.empty();\n            }\n        });\n\n        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());\n\n        List<Media> values = Observable.concat(o1, o2).toList().toBlockingObservable().single();\n    }\n```\n\nIn short, it seems the `Observable<Observable<? extends T>>` does not work well.\n",
        "See https://github.com/benjchristensen/RxJava/commit/1a0fcdc976d78aea4ec59c6ab73e0856f98e6dfc for the changes made to `Observable.concat` due to the above finding in relation to https://github.com/Netflix/RxJava/issues/359. If someone can provide a better solution I'd appreciate it.\n",
        "Looks like this makes it work:\n\n``` java\npublic static <T> Observable<T> concat(Observable<? extends Observable<? extends T>> observables) \n```\n",
        "See https://github.com/benjchristensen/RxJava/commit/97b51eb2a9eaebfcf5064306736514ff39c85a8b for this change.\n",
        "I think `concat` is fine as of https://github.com/Netflix/RxJava/pull/361\n\nNeed to look at `reduce` as reported at https://github.com/Netflix/RxJava/issues/336#issuecomment-24094254\n",
        "The issues with `reduce` are shown at https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/ReduceTests.java#L58 and https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/ReduceTests.java#L83\n",
        "I have not yet figured out a solution to `reduce` that retains `? super` on the instance method version. I would appreciate someone else taking a look.\n",
        "@jmhofer can you give an example where the instance `reduce` method actually benefits from the wildcards?\n\n``` java\npublic Observable<T> reduce(Func2<? super T, ? super T, ? extends T> accumulator)\n... vs ...\npublic Observable<T> reduce(Func2<T, T, T> accumulator)\n```\n\nI can get covariance to work on it as a static method, but not as an instance method. \n",
        "Here is example code separate from Rx:\n\n``` java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport rx.util.functions.Func1;\n\npublic class CovariancePlayground {\n\n    public static class TestContainer<T> {\n\n        private final List<T> items;\n\n        public TestContainer(T... items) {\n            this(Arrays.asList(items));\n        }\n\n        public TestContainer(List<T> items) {\n            this.items = items;\n        }\n\n        public TestContainer<T> doSomethingToIt(Func1<? super T, ? extends T> function) {\n            ArrayList<T> newItems = new ArrayList<T>();\n            for (T t : items) {\n                newItems.add(function.call(t));\n            }\n            return new TestContainer<T>(newItems);\n        }\n\n        public <R> TestContainer<R> transformIt(Func1<? super T, ? extends R> function) {\n            ArrayList<R> newItems = new ArrayList<R>();\n            for (T t : items) {\n                newItems.add(function.call(t));\n            }\n            return new TestContainer<R>(newItems);\n        }\n    }\n\n    public static class UnitTest {\n\n        public void test() {\n            TestContainer<Movie> movies = new TestContainer<Movie>(new ActionMovie(), new HorrorMovie());\n            TestContainer<Media> media = new TestContainer<Media>(new Album(), new Movie(), new TVSeason());\n\n            movies.doSomethingToIt(movieFunction);\n            movies.doSomethingToIt(mediaFunction); // doesn't compile\n\n            //            media.doSomethingToIt(movieFunction); // shouldn't be possible\n            media.doSomethingToIt(mediaFunction);\n\n            movies.transformIt(mediaToString);\n            media.transformIt(mediaToString);\n        }\n\n        Func1<Movie, Movie> movieFunction = new Func1<Movie, Movie>() {\n\n            @Override\n            public Movie call(Movie t1) {\n                return t1;\n            }\n\n        };\n\n        Func1<Media, Media> mediaFunction = new Func1<Media, Media>() {\n\n            @Override\n            public Media call(Media t1) {\n                return t1;\n            }\n\n        };\n\n        Func1<Media, String> mediaToString = new Func1<Media, String>() {\n\n            @Override\n            public String call(Media t1) {\n                return t1.getClass().getName();\n            }\n\n        };\n    }\n\n    static class Media {\n    }\n\n    static class Movie extends Media {\n    }\n\n    static class ActionMovie extends Movie {\n    }\n\n    static class HorrorMovie extends Movie {\n    }\n\n    static class Album extends Media {\n    }\n\n    static class TVSeason extends Media {\n    }\n}\n```\n",
        "I think the `reduce` instance method fits this quote from Effective Java 2nd Edition page 136:\n\n> If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you\n> need an exact type match, which is what you get without any wildcards.\n\nI don't think we can get it to work since the publisher and consumer are the same type. Thus I think we should change it to just be the following:\n\n``` java\npublic Observable<T> reduce(Func2<T, T, T> accumulator)\n```\n",
        "Yes George, I think I just read that very quote and pasted it. Funny we both got to the same thing! Thanks for confirming my thoughts on this.\n",
        "Can someone else take a look at https://github.com/Netflix/RxJava/pull/369 and let me know if my understanding of generics are correct here? \n\nI have changed `reduce`, `aggregate` and `scan` back to `Func2<T, T, T>` without `? super` and `? extends` because these functions produce and consume the same type, thus they must match and the wildcards serve no value.\n",
        "@samuelgruetter I see how that example could work, but playing with it I think the example method I created having only 2 arguments is too contrived. When I try and stretch that to reduce with T, T, T it doesn't work, as the output must be injected back as the input.\n\nGeorge and I discussed in https://github.com/Netflix/RxJava/pull/369#issuecomment-24255958 and looked at JDK 8 to confirm how it uses wildcards and I think it confirms that wildcards don't help.\n",
        "Beyond `reduce` and `scan` are there any others either not working or where wildcards are useless?\n",
        "I don't know how to solve those examples when the `Observable` is defined as `Observable<? extends Movie>` with `onErrorResumeNext`, `onErrorReturn` etc.\n\nI can get this to work (and it makes sense to me):\n\n``` java\nObservable<Movie> o = Observable.from(new Movie(), new HorrorMovie());\nObservable<HorrorMovie> n = Observable.from(new HorrorMovie());\no.onErrorResumeNext(n);\n```\n\nIn that example, T becomes `Movie` and can then accept `T extends Movie` which allows `n` which is `HorrorMovie`.\n\nIf it was instead `Observable<? extends Movie>` that means T is `? extends Movie` which means `n` would be `? extends ? extends Movie` ... which can't work.\n\nHere is a screenshot from the IDE showing it confused and combining the types like that:\n\n![screen shot 2013-09-11 at 10 32 20 am](https://f.cloud.github.com/assets/813492/1124947/4ba61212-1b08-11e3-957f-0c3938dd7759.png)\n\nIn short, I don't know how to make it work when the generic itself is `? extends SomeType`. \n",
        "I'm not surprised Scala has a solution :-)\n\nI'm going to consider this issue closed then unless someone can provide a concrete example of something that can be improved or fixed similar to what we did on `reduce`/`scan`.\n\nThank you @samuelgruetter for your help on this.\n",
        "I don't see a problem with the `reduce` variant that takes and produces the same type.\n\nHowever, there's also `<R> Observable<R> reduce(R initialValue, Func2<? super R, ? super T, ? extends R> accumulator)`. - I still have to examine that in more detail.\n",
        "As illustrated by this [example](https://github.com/samuelgruetter/rx-playground/blob/294a8e835502c7fe53ab3f455b3b0442df8efa51/CovarianceTests/src/main/java/CovariancePlayground.java#L92), `Func2<T, T, T>` is a subtype of `Func2<? super T, ? super T, ? extends T>`, so if we replace `Func2<? super T, ? super T, ? extends T>` by `Func2<T, T, T>`, then:\n-    We loose some flexibility, for instance this [example](https://github.com/samuelgruetter/rx-playground/blob/294a8e835502c7fe53ab3f455b3b0442df8efa51/CovarianceTests/src/main/java/CovariancePlayground.java#L111) won't work any more. But I think such examples are not very common.\n-    We gain easier-to-read method signatures.\n\nFor the Scala adapter, it doesn't matter whether we have these wildcards or not in the Java core, because we have to do typecasting anyways.\n",
        "The problematic operations are those where the type parameter `T`, intended to be covariant, appears in a contravariant position. These operations are listed in this [section](https://github.com/samuelgruetter/RxJava/blob/def97312d2f242494cfc35f59034dc2a089b424f/rxjava-core/src/test/java/rx/CovarianceTest.java#L263) of my version of `CovarianceTest.java`.\n",
        "I don't have a solution either, but we just have to be aware that certain methods become unusable if we want to call them on an `Observable<? extends SomeType>`.\nIn Scala, btw, we have declaration-site variance and lower bounds on type parameters, which make all these examples work :-)\n"
    ],
    "5820": [],
    "3609": [],
    "473": [],
    "5207": [],
    "477": [],
    "6252": [],
    "3029": [],
    "906": [],
    "383": [
        "Then the hasNext should block until either the onNext or onComplete has been called.\n",
        "I fixed one flaky test by moving the decrement of the latch in to the observer.\n\n``` java\n                 .map(new Func1<String, String>() {\n                     public String call(String arg0) {\n+                        throw new IllegalArgumentException(\"any error\");\n-                        try {\n-                            throw new IllegalArgumentException(\"any error\");\n-                        } finally {\n-                            latch.countDown();\n-                        }\n                     }\n                 });\n\n+        // wait for the call to get to the observer before decrementing the latch\n+        doAnswer(new Answer() {\n+            @Override\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                latch.countDown();\n+                return null;\n+            }\n+        }).when(stringObserver).onError(any(Throwable.class));\n         m.subscribe(stringObserver);\n         latch.await();\n```\n",
        "> Build 278: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n> Build 276: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n> Build 237: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n> Build 185: rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions\n\nThe CurrentThreadScheduler tests that are testing delay functionality are very non-deterministic. The assertions either need to change to allow for that, or we need to change to using artificial time (though these particular tests are purposefully testing the real implementation, so using artificial time would someone defeat the purpose).\n\n> Build 251: rx.concurrency.TestSchedulers.testSchedulingWithDueTime\n\nThis is similar, it's asserting something scheduled on a background thread. I haven't dug into what needs to change.\n\n> Build 277: rx.operators.OperationConcat$UnitTest.testConcatConcurrentWithInfinity\n\nNot sure at a quick glance what the issue here is.\n\n---\n\nI don't have time this morning to fix these but will do so at some point (their intermittent failures annoy me too).\n",
        "Another here: https://netflixoss.ci.cloudbees.com/job/RxJava-pull-requests/293/\n",
        "Closing as this has become an epic dumping ground ... most issues have been solved. The only one I'm still aware of is a new one, the `pivot` operator.\n",
        "`rx.concurrency.CurrentThreadScheduler$UnitTest` failed several times in my machine today:\n\n<pre>\norg.mockito.exceptions.verification.VerificationInOrderFailure: \nVerification in order failure\nWanted but not invoked:\naction0.call();\n-> at rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions(CurrentThreadScheduler.java:191)\nWanted anywhere AFTER following interaction:\naction0.call();\n-> at rx.Scheduler$4.call(Scheduler.java:184)\n    at rx.concurrency.CurrentThreadScheduler$UnitTest.testSequenceOfDelayedActions(CurrentThreadScheduler.java:191)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at $Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n    at java.lang.Thread.run(Thread.java:662)\n</pre>\n",
        "The following error happened in my machine today:\n\n<pre>\njava.lang.AssertionError: expected:<39.0> but was:<100.0>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:443)\n    at org.junit.Assert.assertEquals(Assert.java:512)\n    at rx.operators.OperationGroupBy$UnitTest.testUnsubscribe(OperationGroupBy.java:546)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n    at java.lang.Thread.run(Thread.java:695)\n</pre>\n\nI reviewed `rx.operators.OperationGroupBy.UnitTest.testUnsubscribe()` and found the following assumption was wrong:\n\n``` java\n// sentEvents will go until 'eventCounter' hits 20 and then unsubscribes\n            // which means it will also send (but ignore) the 19/20 events for the other group\n            // It will not however send all 100 events.\n            assertEquals(39, sentEventCounter.get(), 10);\n            // gave it a delta of 10 to account for the threading/unsubscription race condition which can vary depending on a machines performance, thread-scheduler, etc\n```\n\nActually, since we can not control when to run a thread, `sentEventCounter` can be 100 in some scenario.\n",
        "@abersnaze Thanks. I added your patch to PR #461. Is it OK? Could you take a look?\n",
        "For the `rx.schedulers.NewThreadSchedulerTest.testMixOfDelayedAndNonDelayedActions`, as `AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions` uses the real time to schedule the actions, it's non-deterministic. When the CPUs are busy, the test may fail. Can we enlarge the time?\n\n``` java\n                scheduler.schedule(first);\n                scheduler.schedule(second, 300, TimeUnit.MILLISECONDS);\n                scheduler.schedule(third, 100, TimeUnit.MILLISECONDS);\n                scheduler.schedule(fourth);\n                scheduler.schedule(new Action0() {\n\n                    @Override\n                    public void call() {\n                        latch.countDown();\n                    }\n                }, 400, TimeUnit.MILLISECONDS);\n```\n",
        "wrt\n\nrx.operators.OperationNext$UnitTest.testOnErrorViaHasNext\n\nI don't think the test is necessarily flaky. rather that the Iterable returned by next() is inconsistent. if you trigger an exception during Iterable.next() then the Iterable.hasNext() will revert to returning 'true'. This can fail the test if the \n\nassertFalse(it.hasNext());\n\nruns after the it.next() on the async thread. \n\nso you can't really fix the test, you can either make the test thread delay a little longer and definitely fail, or remove the assert and accept that the behavior of hasNext() is unreliable after next() completes (either with a value or exception) since its unusual that you'd be checking the Iterable from a different thread.\n\nalso might be worth noting that the wiki suggests the Iterable should return a single 'null' value if the Observable completes without any value (https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators#next) but I can't see any test or implementation for this case - am I misunderstanding this?\n",
        "not sure in which case you mean? the hasNext() in the failing test is called after the onNext/onComplete has occurred (the async thread has called next() and it has thrown an exception)\n\nor do you mean in the case where the Observable completes without an onNext?\n",
        "Output of failed `rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext`:\n\n```\njava.lang.AssertionError: should not have received exception\n    at org.junit.Assert.fail(Assert.java:93)\n    at rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext(OperationNext.java:252)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:80)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:47)\n    at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:69)\n    at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)\n    at sun.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n    at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n    at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)\n    at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n    at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n    at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:724)\n```\n",
        "another local failure:\n\n```\nrx.operators.OperationNext$UnitTest > testOnErrorViaHasNext FAILED\n    java.lang.AssertionError at OperationNext.java:252\n```\n",
        "and yet another (in `rx.operators.SynchronizedObserver$UnitTest`):\n\n```\njava.lang.AssertionError: expected:<1> but was:<0>\n    at org.junit.Assert.fail(Assert.java:93)\n    at org.junit.Assert.failNotEquals(Assert.java:647)\n    at org.junit.Assert.assertEquals(Assert.java:128)\n    at org.junit.Assert.assertEquals(Assert.java:472)\n    at org.junit.Assert.assertEquals(Assert.java:456)\n    at rx.operators.SynchronizedObserver$UnitTest.testMultiThreadedWithNPEinMiddle(SynchronizedObserver.java:250)\n...\n```\n",
        "again `rx.operators.OperationNext$UnitTest.testOnErrorViaHasNext`\n",
        "Just had another instance of this:\n\n```\njava.lang.NullPointerException\n    at rx.operators.OperationConcatTest.testConcatConcurrentWithInfinity(OperationConcatTest.java:324)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    ...\n```\n",
        "Another test which also seems to be flaky:\n\n```\nrx.schedulers.NewThreadSchedulerTest.testMixOfDelayedAndNonDelayedActions\n\norg.mockito.exceptions.verification.VerificationInOrderFailure: \nVerification in order failure\nWanted but not invoked:\naction0.call();\n-> at rx.schedulers.AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions(AbstractSchedulerTests.java:317)\nWanted anywhere AFTER following interaction:\naction0.call();\n-> at rx.Scheduler$4.call(Scheduler.java:194)\n\n    at rx.schedulers.AbstractSchedulerTests.testMixOfDelayedAndNonDelayedActions(AbstractSchedulerTests.java:317)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    ...\n```\n\nThis was with version 0.16.0.\n"
    ],
    "4243": [],
    "3685": [],
    "387": [
        "This unit test demonstrates the issue:\n\n``` java\n        @Test\n        public void testOnFirstCompletion() {\n            PublishSubject<String> oA = PublishSubject.create();\n            PublishSubject<String> oB = PublishSubject.create();\n\n            @SuppressWarnings(\"unchecked\")\n            Observer<String> observer = mock(Observer.class);\n\n            Observable<String> o = Observable.create(zip(oA, oB, getConcat2Strings()));\n            o.subscribe(observer);\n\n            InOrder inOrder = inOrder(observer);\n\n            oA.onNext(\"a1\");\n            inOrder.verify(observer, never()).onNext(anyString());\n            oB.onNext(\"b1\");\n            inOrder.verify(observer, times(1)).onNext(\"a1-b1\");\n            oB.onNext(\"b2\");\n            inOrder.verify(observer, never()).onNext(anyString());\n            oA.onNext(\"a2\");\n            inOrder.verify(observer, times(1)).onNext(\"a2-b2\");\n\n            oA.onNext(\"a3\");\n            oA.onNext(\"a4\");\n            oA.onNext(\"a5\");\n            oA.onCompleted();\n\n            // assert we complete the zip stream here\n            inOrder.verify(observer, times(1)).onCompleted();\n\n            oB.onNext(\"b3\");\n            oB.onNext(\"b4\");\n            oB.onNext(\"b5\");\n            oB.onNext(\"b6\");\n            oB.onNext(\"b7\");\n            // never completes (infinite stream for example)\n\n            // we should receive nothing else despite oB continuing after oA completed\n            inOrder.verifyNoMoreInteractions();\n        }\n```\n",
        "I need to play more with the C# version before I finish the changes, as fixing this unit test could be done in different ways, and the most obvious one breaks other unit tests.\n",
        "Branch with unit test at https://github.com/benjchristensen/RxJava/commit/6921f729c76c9b6bc940e239d99181e93eba8406\n",
        "I believe this is fixed in https://github.com/Netflix/RxJava/pull/510 thanks to @akarnokd \n",
        "Hello, I've ported my Zip implementation and it appears to be doing almost the expected behavior: https://github.com/akarnokd/RxJava/commit/cd0a5e7ec27169816738f63547289102f2044639\n\n0 at t=1016\n1 at t=2016\n2 at t=3017\ncomplete at t=3017\n\nThe difference to Rx seems to be that it terminates right after the 3rd item whereas Rx.NET after rejecting the 4th item of the second observable.\n"
    ],
    "1714": [],
    "395": [
        "The 'Func2' sounds fine unless 'getHashCode()' is necessary to make 'distinct()' fast. In that case I think making our own 'EqualComparator<T>' would be the way to go. \n",
        "This method 'java.util.Objects.hash(Object...)' makes computing hash codes much easier.\n",
        "A `Comparator` returning 0 means the two items are equal thus it will work for this use case.\n\n``` java\nint compare(T o1, T o2)\n```\n\nhttp://docs.oracle.com/javase/6/docs/api/java/util/Comparator.html#compare(T,%20T)\n\n> returns a negative integer, **zero**, or a positive integer as the first argument is less than, **equal to**, or greater than the second.\n\nMoving to `EqualityComparator` would limit the return type to boolean as opposed to -1, 0, 1 as possible return types, but `Comparator` can represent equality as well, and both approaches let the developer define equality (using object reference, `equals`, `hashCode`, deep comparison, etc) instead of automatically using just the `equals` method.\n\nSupporting Comparator (and Comparable object types) makes it so people can just reuse the same logic as used for ordering. \n\nChecking for equality is simpler than checking for ordering (binary instead of trinary response), but if the Comparator returns 0 it means the objects are equal. \n\nSo if we're not going to use `Comparator` it should be because we want a simpler return type, not because it doesn't work. That said, I can't remember ever seeing something other than `Comparator` used for this type of behavior in a Java library because if not using `Comparator` then the library can just call `equals` on each Object. Why would something else be needed?\n\nFor example, the `Set` implementations in Java ensure uniqueness and they use the `Object.equals` method on objects to determine equality. Why would we need to do anything different than the Java collections libraries that use either `equals` or `Comparator`?\n",
        "The `compare` method on a `Comparator` can use `hashcode` and `equals` just the same as a new interface would allow, but I accept that having a trinary response is confusing when only a binary boolean is needed.\n\nMy vote is for `Func2<? super T, ? super T, Boolean>`, not creating a new special type for this very limited use case.\n",
        "> use it to make distinct efficient, for example.\n\nThis is a valid concern, iterating the entire list is not good (though with a Comparator we could maintain a sorted list and do a binary search!).\n\nAnother consideration for API design, an interface with 2 methods like `IEqualityComparer` can not be implemented by lambdas as it is not a functional interface with a single method (lambda body).\n\nIs this use case and performance issue strong enough to have a non-functional interface that requires an anonymous inner class to implement two methods? Also, implementing hashCode is far more obnoxious than implementing equals.\n\nFor performance reasons and avoiding hashCode implementations, would `Comparator` having ordering in mind actually be the right choice so we can test for equality using a binary search algorithm?\n\nHow about this change to use `TreeSet` and `Comparator` and not require iterating the full list?\n\n``` java\n            final Subscription sourceSub = source.subscribe(new Observer<T>() {\n\n                // use TreeSet instead of ArrayList\n                private final TreeSet<U> emittedKeys = new TreeSet<U>(equalityComparator);\n\n                @Override\n                public void onCompleted() {\n                    observer.onCompleted();\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    observer.onError(e);\n                }\n\n                @Override\n                public void onNext(T next) {\n                    U nextKey = keySelector.call(next);\n                    if(emittedKeys.add(nextKey)) {\n                        observer.onNext(next);\n                    }\n                }\n            });\n```\n\nUnit Test:\n\n``` java\n        @Test\n        public void testDistinctOfObjectWithComparator() {\n            Observer<? super RandomObject> observer = mock(Observer.class);\n            RandomObject r1 = new RandomObject(1, \"one\");\n            RandomObject r2 = new RandomObject(2, \"two\");\n            RandomObject r2b = new RandomObject(2, \"twoB\");\n            Observable<RandomObject> src = from(r1, r1, r2, r1, r2, r2b);\n            create(distinct(src, new Comparator<RandomObject>() {\n\n                @Override\n                public int compare(RandomObject o1, RandomObject o2) {\n                    int i = o1.i - o2.i;\n                    if(i != 0) {\n                        return i;\n                    }\n\n                    return o1.v.compareTo(o2.v);\n                }\n            })).subscribe(observer);\n\n            InOrder inOrder = inOrder(observer); \n            inOrder.verify(observer, times(1)).onNext(r1);\n            inOrder.verify(observer, times(1)).onNext(r2);\n            inOrder.verify(observer, times(1)).onNext(r2b);\n            inOrder.verify(observer, times(1)).onCompleted();\n            verify(observer, never()).onError(any(Throwable.class));\n            inOrder.verifyNoMoreInteractions();\n        }\n```\n",
        "@jmhofer Yes, if it's not consistent with equals it won't work, but if they have equals they don't need to use `Comparator` and why would they make them be different?\n\n@abersnaze Yes it does, but I'd like to avoid an API that requires developers to do that and know about some obscure API if we don't need it.\n\nQuestion about using `IEqualityComparer`, would it need to calculate the `hashCode` every time the object is touched since it can't cache it (as it doesn't know if mutation has occurred in an object)? \n",
        "We ended up removing `Comparator` for these operators ... so closing.\n",
        "A `Comparator` (per javadoc) is a \n\n> comparison function, which imposes a total ordering on some collection of objects.\n\nWe don't actually need the total ordering for our purposes in `distinct` or `distinctUntil`, only the fact that it incidentally defines equality as well. - But still, if someone defines a `Comparator` for equality, not making it define a total ordering, he or she is basically misusing it.\n\nAs an aside, `Comparator`s that are inconsistent with `equals` are dangerous beasts. It's way too easy to use them for collections like `TreeSet` which simply won't work in that case.\n\nAlso, at least for `distinct`, there is indeed an efficiency problem when (mis)using `Comparator` as we do now: There is no way to create an efficient set without either a total ordering or some kind of hash code. All the `Set` implementations in Java always depend on at least one of these two concepts afaik.\n\nImho, for doing this right, we actually need a real Java equivalent to `IEqualityComparer`, which defines both the concepts of equality and a hash code. - Or we could leave that whole thing out of the API and make people write their own wrapper classes for that use case, which is not very convenient, of course.\n",
        "The `compare` implementation can of course use whatever it likes internally. However, our code can't ever get a `hashCode` from a `Comparator`. It could get one from a new interface and use it to make `distinct` efficient, for example.\n\nI agree, though, that it's probably a very limited use case. So I'm ok with `Func2`, too.\n",
        "For `TreeSet` to work as expected, the `Comparator` has to be consistent with `equals`, and in that case, we don't even need it in the first place. \n\nIt's not correct in Java to implement `equals` without implementing `hashCode`, too.\n",
        "If the observable objects already have an `equals`/`hashCode` implementation, then the `distinct` call without any additional parameters will do. Afaik the additional `distinct` signature using an explicit `IEqualityComparer` in Rx.NET is for cases where you want to use a different `equals` from the default one for distinguishing between the observable objects.\n\nJava doesn't really support the concept of multiple equivalence relations per class. It would need something like the `IEqualityComparer` in its standard library for that, at least (and probably support that interface in the collections library, too). This was the reason why I initially left away the implementation for that specific `distinct` signature. I still don't think it's much of a use case...\n\nMy current implementation is a bit inconsistent: It takes a `Comparator` but doesn't care for or use the total ordering that should be defined by that `Comparator`. It just uses the equivalence relation defined by it, and has to live without being able to compute hash codes.\n\nThe more I think about it, the more I agree with @samuelgruetter that the `Comparator` is a bad choice for this. `distinct` has no need to impose a total ordering. It just needs an equivalence relation. Given a total ordering, we could make `distinct` efficient, of course, without using hash codes (just not via the Java default set implementations). But I don't see much value in that. It's also something completely different from what Rx.NET does here.\n\nSo basically, I'm for using a simple `Func2` for `distinctUntilChanged` and maybe leaving that away from `distinct` due to efficiency.\n\nIf we created an interface like `IEqualityComparer`, we'd have to impose the same restrictions and contracts on its `equals` and `hashCode` methods as `Object` does. Mutable fields used in hash code computations break the standard Java collection implementations based on hash codes. Therefore I see no strong need to make `distinct` work with that special case either.\n",
        "Or maybe `distinctUntilChanged` taking a `Func2<? super T, ? super T, Boolean>`, and no custom comparison for `distinct`, to keep it simple.\n"
    ],
    "708": [],
    "4884": [],
    "5069": [],
    "417": [
        "You should read the \"Rx Design Guidelines\" => http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx\n\n> Should an Observable call all onNext, onCompleted and onError in the same thread, if no scheduler is involved?\n\nThere is nothing requiring it be the same thread necessarily, but it is required that it being sequential and synchronized so the Observer doesn't need to worry about memory visibility, interleaving calls etc.\n\nSee section 6.7 and 6.8 of the design guidelines.\n\n> What's the contract when an Observable encounters a thread pool scheduler?\n\nIt's the same, a Scheduler is for moving location and time but does not change the contract. A single Observable must still be serialized. Anything in RxJava doing differently is a bug and needs to be fixed.\n\nWe iterated several times on `ObserveOn` to get it to hopefully behave correctly so that each event it receives is put on an event loop and processed sequentially on whatever Scheduler it is given.\n",
        "> EventLoop will receive two notifications: onNext(1) and onCompleted. However, as they are out of order, onCompleted may arrive first.\n\nIf they are out-of-order then we still don't have `ObserveOn` working correctly and it's a bug.\n",
        "> Here the error occurs even without observeOn:\n> \n> System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());\n> This snippet also makes the app never terminate.\n\nFor `take(1)`, after the observer receives a value, any later value or error will be ignored, even if `onNext(the first value)` throws an exception. The related codes:\n\n``` java\n            @Override\n            public void onError(Throwable e) {\n                if (counter.getAndSet(num) < num) {\n                    observer.onError(e);\n                }\n            }\n\n            @Override\n            public void onNext(T args) {\n                final int count = counter.incrementAndGet();\n                if (count <= num) {\n                    observer.onNext(args);\n                    if (count == num) {\n                        observer.onCompleted();\n                    }\n                }\n                if (count >= num) {\n                    // this will work if the sequence is asynchronous, it will have no effect on a synchronous observable\n                    subscription.unsubscribe();\n                }\n            }\n```\n\nFor `take(1)`, it will increment `count` at first. Even if `observer.onNext(args);` throws an exception, as `count == num`, the exception is not propagated.\n",
        "> public static void main(String[] args) {\n>     System.out.println(\"started\");\n>     System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())\n>         .map(f).toBlockingObservable().single());\n>     System.out.println(\"done\");\n> }\n\nThis issue is because `rx.operators.ScheduledObserver.EventLoop` does not handle the exception threw from the `onNext` method of a observer. The related codes:\n\n``` java\n                    switch (notification.getKind()) {\n                    case OnNext:\n                        underlying.onNext(notification.getValue());\n                        break;\n                    case OnError:\n                        underlying.onError(notification.getThrowable());\n                        break;\n                    case OnCompleted:\n                        underlying.onCompleted();\n                        break;\n                    default:\n                        throw new IllegalStateException(\"Unknown kind of notification \" + notification);\n                    }\n```\n",
        "@benjchristensen I encountered one problem which I had never realized before when I tried to solve this issue.\n\nFrom  the Observable's perspective, it can guarantee that it calls `onCompleted` of an Observer after all `onNext` calls. However, from the Observer's perspective, if `onNext` and `onCompleted` run in different threads, some weird thing may happen.\n\nFor example, an Observable calls `onNext` in thread t1. After 5ms, it calls `onCompleted` in thread t2. If t1 is suspended at once after it enters the `onNext` method. At this moment, none statement in `onNext` is executed. So now the Observer does not know its `onNext` has been invoked. Suppose t1 is suspended in 100ms, and t2 is not be suspended. So the Observer will find that `onCompleted` is invoked first, and after 95ms, the `onNext` method is called.\n\nI really think such case is weird for the Observer. Could you point out where I misunderstood? \n",
        "I read the article about concurrency in Rx: http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html.\nBut I'm still confused. Here are my problems:\n- Should an Observable call all onNext, onCompleted and onError in the same thread, if no scheduler is involved?\n- What's the contract when an Observable encounters a thread pool scheduler?\n",
        "@benjchristensen, one more question. If an Observer throws an exception in `onNext`, does its `onError` have to be called? If so, there may be complicated to fix the issue in `rx.operators.ScheduledObserver.EventLoop`.\n\nFor example, in @samuelgruetter 's example, \n\n``` java\npublic static void main(String[] args) {\n    System.out.println(\"started\");\n    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())\n        .map(f).toBlockingObservable().single());\n    System.out.println(\"done\");\n}\n```\n\n`EventLoop` will receive two notifications: `onNext(1)` and `onCompleted`. However, as they are out of order, `onCompleted` may arrive first. So the observer will be notified `onCompleted`. Then, when `onNext(1)` is called, the observer will need to be notified `onError` as `onNext` throws an exception. In such situation, the `onCompleted` and `onError` will be both called.\n\nI'm trapped in here.\n\nDue to `onCompleted` and `onError`, concurrency in RxJava is different from Rx.Net. Is there an wiki page about concurrency in RxJava?\n",
        "Thanks for your help. \"Rx Design Guidelines\" is really helpful.\n",
        "Now this issue should be fixed in PR #453 and #441. It can be closed.\n",
        "Here the error occurs even without `observeOn`:\n\n``` java\nSystem.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());\n```\n\nThis snippet also makes the app never terminate.\n\nThis prevents me from implementing the [head](https://github.com/samuelgruetter/RxJava/blob/2654f60e05a24fc910f73284e32290403d5bffcf/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala#L1565) operation in the Scala adaptor, and the original one with `observeOn` prevents me from implementing a [nice constructor](https://github.com/samuelgruetter/RxJava/blob/2654f60e05a24fc910f73284e32290403d5bffcf/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/package.scala#L141).\n"
    ],
    "423": [
        "@zsxwing @headinthebox \n\nWe already have a `first` operator in `Observable` that is async: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L3919\n\nWe solved the problem of duplicate naming for blocking/non-blocking in RxJava by separating all blocking operators into the `BlockingObservable` class so it is explicit. Everything on `Observable` is non-blocking and returns an Observable except for `subscribe` which returns `Subscription`.\n\nThe `takeLast` operator could have a `last` method aliased to `takeLast(1)` in `Observable`.\n",
        "> RxJava misses .LastAsync() and instead uses takeLast(n), which behaves differently.\n> var xs = Observable.Empty();\n> xs.TakeLast(1).Dump(); // onCompleted()\n> xs.LastAsync().Dump();// onError(... invalidOperation exception ...)\n\nThat seems non-obvious why 2 variants of `last` should behave differently regarding error propagation. \n\nWhy should `lastAsync` behave differently than `takeLast(1)` when `last` means \"take the last value\". Should `takeLast(1)` emit an error since you have asked for more than are available? Same with `takeLast(5)` if less than 5 are available? If wanted without errors, then `takeUpToLast(5)` would take 0-5 items, but `takeLast(5)` would only take 5 or error.\n",
        "@headinthebox I am not aware of a rule that covers this, can you provide an answer for @samuelgruetter's question? We can then go build the unit tests and get code to match the rule.\n",
        "I have completed the blocking and non-blocking `last` impls in https://github.com/Netflix/RxJava/pull/470\n",
        "@zsxwing Are you working on any of these others already so we don't duplicate effort?\n",
        "Actually, seems like `reduce` is the only one needing fixing as `average` will fix itself once `reduce` is done.\n",
        "The `reduce` operator is now fixed for the empty Observable case.\n\nWhen the Observable is empty but a seed is passed in, it just emits the seed:\n\n``` java\n    /**\n     * A reduce on an empty Observable and a seed should just pass the seed through.\n     * \n     * This is confirmed at https://github.com/Netflix/RxJava/issues/423#issuecomment-27642456\n     */\n    @Test\n    public void testReduceWithEmptyObservableAndSeed() {\n        Observable<Integer> observable = Observable.range(1, 0);\n        int value = observable.reduce(1, new Func2<Integer, Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t1, Integer t2) {\n                return t1 + t2;\n            }\n\n        }).toBlockingObservable().last();\n\n        assertEquals(1, value);\n    }\n```\n\nPlease confirm that current code and unit test match the expected behavior and then we can close this ... or we correct again.\n",
        "I found http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.aspx was out of date. Now Rx.Net has a blocking version of `Last` and `First`, and a unblocking version of `LastAsync` and `FirstAsync`.\n\nHere is the document I copy from VS:\n\n``` c#\n        // Summary:\n        //     Returns the first element of an observable sequence.\n        //\n        // Parameters:\n        //   source:\n        //     Source observable sequence.\n        //\n        // Type parameters:\n        //   TSource:\n        //     The type of the elements in the source sequence.\n        //\n        // Returns:\n        //     Sequence containing the first element in the observable sequence.\n        //\n        // Exceptions:\n        //   System.ArgumentNullException:\n        //     source is null.\n        //\n        //   System.InvalidOperationException:\n        //     (Asynchronous) The source sequence is empty.\n        public static IObservable<TSource> FirstAsync<TSource>(this IObservable<TSource> source);\n        //\n        // Summary:\n        //     Returns the first element of an observable sequence that satisfies the condition\n        //     in the predicate.\n        //\n        // Parameters:\n        //   source:\n        //     Source observable sequence.\n        //\n        //   predicate:\n        //     A predicate function to evaluate for elements in the source sequence.\n        //\n        // Type parameters:\n        //   TSource:\n        //     The type of the elements in the source sequence.\n        //\n        // Returns:\n        //     Sequence containing the first element in the observable sequence that satisfies\n        //     the condition in the predicate.\n        //\n        // Exceptions:\n        //   System.ArgumentNullException:\n        //     source or predicate is null.\n        //\n        //   System.InvalidOperationException:\n        //     (Asynchronous) No element satisfies the condition in the predicate. -or-\n        //     The source sequence is empty.\n        public static IObservable<TSource> FirstAsync<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate);\n\n        //\n        // Summary:\n        //     Returns the last element of an observable sequence.\n        //\n        // Parameters:\n        //   source:\n        //     Source observable sequence.\n        //\n        // Type parameters:\n        //   TSource:\n        //     The type of the elements in the source sequence.\n        //\n        // Returns:\n        //     Sequence containing the last element in the observable sequence.\n        //\n        // Exceptions:\n        //   System.ArgumentNullException:\n        //     source is null.\n        //\n        //   System.InvalidOperationException:\n        //     (Asynchronous) The source sequence is empty.\n        public static IObservable<TSource> LastAsync<TSource>(this IObservable<TSource> source);\n        //\n        // Summary:\n        //     Returns the last element of an observable sequence that satisfies the condition\n        //     in the predicate.\n        //\n        // Parameters:\n        //   source:\n        //     Source observable sequence.\n        //\n        //   predicate:\n        //     A predicate function to evaluate for elements in the source sequence.\n        //\n        // Type parameters:\n        //   TSource:\n        //     The type of the elements in the source sequence.\n        //\n        // Returns:\n        //     Sequence containing the last element in the observable sequence that satisfies\n        //     the condition in the predicate.\n        //\n        // Exceptions:\n        //   System.ArgumentNullException:\n        //     source or predicate is null.\n        //\n        //   System.InvalidOperationException:\n        //     (Asynchronous) No element satisfies the condition in the predicate. -or-\n        //     The source sequence is empty.\n        public static IObservable<TSource> LastAsync<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate);\n\n```\n",
        "@benjchristensen do we need to add the new Rx.Net interfaces?\n",
        "@headinthebox sorry, I mean that do we need to add these Rx.Net interfaces (lastAsync, firstAsync)  into RxJava.\n",
        "I reviewed these operators in RxJava. Here is my conclusion.\n- `elementAt` is correct.\n- `reduce` and `aggregate`  is wrong.\n- `min` and `max` are not implemented. However, I have already finished it in my branch: https://github.com/zsxwing/RxJava/commits/min-max . Once the reduce issue is fixed, I'll send a PR.\n- `average` uses `reduce`. For an empty observable, it will emit a DivisionByZero error. I think this error is not correct. It should be something like `UnsupportedOperationException`. In Rx.net, it's `System.InvalidOperationException: Sequence contains no elements.`\n- `takeFirst`, `takeLast`, `skip` and `skipLast` is correct.\n- blocking `last` is wrong. See #464\n- non-blocking `last` is missing.\n- blocking `first` is missing.\n- non-blocking `first` is wrong.\n\nPlease correct me if I have misunderstood something. \n",
        "There is still a difference between Average in RxJava and Rx.Net when the observable is empty.\n\nThis is a unit test for Average in RxJava.\n\n``` Java\n    @Test\n    public void testEmptyAverage() throws Throwable {\n        Observable<Integer> src = Observable.empty();\n        average(src).subscribe(w);\n\n        verify(w, never()).onNext(anyInt());\n        verify(w, times(1)).onError(any(ArithmeticException.class));\n        verify(w, never()).onCompleted();\n    }\n```\n\nIf the observable is empty, average emits an ArithmeticException.\n\nHere is a sample for Average in Rx.Net.\n\n``` c#\n            IObservable<double> o = Observable.Empty<int>().Average();\n            o.Subscribe(\n                x => Console.WriteLine(\"OnNext: \" + x),\n                e => Console.WriteLine(\"OnError: \" + e),\n                () => Console.WriteLine(\"Done\")\n                );\n```\n\nIt outputs \"OnError: System.InvalidOperationException: Sequence contains no elements.\".\n",
        "@benjchristensen Now I'm only working on `min` and `max` operators.\n",
        "I sent the PR #478 for `min` and `max`.\n",
        "I fixed the `Average` issue for the empty Observable case in #480. Please help me confirm it.\n",
        "Closed as it's fixed.\n",
        "@zsxwing, Thanks for diving into this.  \n\n(aside: When you write snippets like this it is a good idea to also look at onCompleted and onError. Aggregate does not \"throw\" an exception, but sends out an onError with an exception. And return the empty sequence by immediately calling onCompleted, which is not the same as \"do nothing\". Subtle, but important to be super precise as we look at the edge cases)\n\nvar xs = new[]{ 1, 2 , 3}.ToObservable();\nvar ys = new int[]{}.ToObservable();\n\nxs.Aggregate(accumulator: (x,y)=>x+y).Subscribe\n( x => Console.WriteLine(\"[1, 2, 3].Aggregate((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [1, 2, 3].Aggregate((x,y)=>x+1) = 6\n// Done\n\nys.Aggregate(accumulator: (x,y)=>x+y).Subscribe\n( x => Console.WriteLine(\"[].Aggregate((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// Boom = System.InvalidOperationException: Sequence contains no elements.\n\nxs.Aggregate(seed: 0, accumulator: (x,y)=>x+y).Subscribe\n(x => Console.WriteLine(\"[1, 2, 3].Aggregate((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [1, 2, 3].Aggregate((x,y)=>x+1) = 6\n// Done\n\nys.Aggregate(seed: 0, accumulator:(x,y)=>x+y).Subscribe\n(x => Console.WriteLine(\"[].Aggregate((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [].Aggregate((x,y)=>x+1) = 0\n// Done\n\nxs.Aggregate(seed: 0, accumulator: (x,y)=>x+y, resultSelector: x => string.Format(\"[{0}]\", x)).Subscribe\n( x => Console.WriteLine(\"[1, 2, 3].Aggregate((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [1, 2, 3].Aggregate((x,y)=>x+1) = [6]\n// Done\n\nys.Aggregate(seed: 0, accumulator:(x,y)=>x+y, resultSelector: x => string.Format(\"[{0}]\", x)).Subscribe\n( x => Console.WriteLine(\"[].Aggregate((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [].Aggregate((x,y)=>x+1) = [0]\n// Done\n",
        "No, looking at scan, I would say that scan in Rx.NET is broken.\n\nIn Haskell, the seed in a scan is sent out as well\n\nPrelude> scanl (+) 0 []\n[0]\n\nPrelude> scanl (+) 0 [1,2,3]\n[0,1,3,6]\n\nWith no seed, the results look like this\n\nPrelude> scanl1 (+) [1,2,3]\n[1,3,6]\n\nPrelude> scanl1 (+) []\n[]\n\nBut in C#, the seed is not send out.\n\nvar xs = new[]{ 1, 2 , 3}.ToObservable();\nvar ys = new int[]{}.ToObservable();\n\nxs.Scan(accumulator: (x,y)=>x+y).Subscribe\n( x => Console.WriteLine(\"[1, 2, 3].Scan((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [1, 2, 3].Scan((x,y)=>x+1) = 1\n// [1, 2, 3].Scan((x,y)=>x+1) = 3\n// [1, 2, 3].Scan((x,y)=>x+1) = 6\n// Done\n\nys.Scan(accumulator: (x,y)=>x+y).Subscribe\n( x => Console.WriteLine(\"[].Scan((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// Done\n\nxs.Scan(seed: 0, accumulator: (x,y)=>x+y).Subscribe\n(x => Console.WriteLine(\"[1, 2, 3].Scan((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// [1, 2, 3].Scan((x,y)=>x+1) = 1\n// [1, 2, 3].Scan((x,y)=>x+1) = 3\n// [1, 2, 3].Scan((x,y)=>x+1) = 6\n// Done\n\nys.Scan(seed: 0, accumulator:(x,y)=>x+y).Subscribe\n(x => Console.WriteLine(\"[].Scan((x,y)=>x+1) = {0}\", x)\n, e => Console.WriteLine(\"Boom = {0}\", e)\n, () => Console.WriteLine(\"Done\")\n);\n\n// Done\n",
        "I'd say we define for once and for all that (see http://www.haskell.org/hoogle/?hoogle=scanl)\n\nxs.aggregate(op) = xs.scan(op).lastasync()\nxs.aggregate(e, op) = xs.scan(e, op).lastasync()\nxs.aggregate(e, op, f) = xs.scan(e, op).lastasync().map(f)\n",
        "RxJava misses .LastAsync() and instead uses takeLast(n), which behaves differently.\n\nvar xs = Observable.Empty<int>();\nxs.TakeLast(1).Dump(); // onCompleted()\nxs.LastAsync().Dump();// onError(... invalidOperation exception ...)\n",
        "I have an implementation for this ready. This will fax the issue for reduce/scan. Did you see the comments.\n\nSent from my iPad\n\n> On Nov 4, 2013, at 3:51 AM, Shixiong Zhu notifications@github.com wrote:\n> \n> @benjchristensen do we need to add the new Rx.Net interfaces?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "@zsxwing Yes, that's what I meant. I have an implementation for them, but then recursively found some bugs in other operators.\n",
        "elementAt ==> OnError(\"out of range\")\n\nreduce(Func2) and aggregate(Func2) ==> that's what started this discussion, see above.\naverage{Longs/Floats/Doubles} ==> same, defined as reduce.\nmin ==> ==> same, defined as reduce.\nmax ==> same, defined as reduce.\nskip ==> onCompleted()\nfirst (2 overloads) ==> throws for blocking observable, onError(\"empty sequence\")\nand takeFirst (2 overloads) ==> as many elements as it can get, ending with onCompleted.\ntake ==> I think this is an alias for takeFirst.\n\ntakeLast ==> as many elements as it can get, ending with onCompleted.\nskipLast ==> onCompleted\n",
        "The behavior in Rx.NET is the same as in Haskell, except for the bug in scan discussed up here.\n\nPrelude> take 5 [1..3]\n[1,2,3]\n\netc.\n",
        "I just realized that the question \"what should the operator do if the source observable does not have enough elements?\" should be asked for some other operators as well:\n-    elementAt\n-    reduce(Func2<T, T, T>) and aggregate(Func2<T, T, T>)\n-    average{Longs/Floats/Doubles}\n-    min\n-    max\n-    skip\n-    first (2 overloads) and takeFirst (2 overloads)\n-    take\n-    takeLast\n-    skipLast\n\nI'd prefer that onError be called, instead of ignoring that there were not enough elements. That's also what scala collections do.\n\nAnd if takeLast on an empty observable calls onError, reduce can nicely be implemented using scan.\n"
    ],
    "6131": [],
    "4832": [],
    "5930": [],
    "6602": [],
    "428": [
        "Can you provide a unit test to demonstrate the issue? Here are existing unit tests for buffer: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperationBuffer.java#L372\n\nAlso, what Future are you referring to? Are you using custom schedulers?\n",
        "Yes, that's what a Subscription of a Future is supposed to do. \n",
        "Thanks for submitting the unit test, I'll try it out.\n\n> While we're on the subject of buffer() it would be nice if the observer was not called with an empty list.\n\nYou're using time, so it will emit every 1000ms whatever is buffered, even if it's empty.\n",
        "I'm unable to run the unit tests in eclipse for some reason.  Here's a unit test from my project.   While we're on the subject of buffer() it would be nice if the observer was not called with an empty list.  \n\n```\n    @Test\n    public void testInterrupted() throws Exception {\n        Observable.create(new OnSubscribeFunc<Integer>() {\n            @Override\n            public Subscription onSubscribe(final Observer<? super Integer> t1) {\n                final Future<?> t = Executors.newSingleThreadExecutor().submit(new Runnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(10000);\n                        } catch (InterruptedException e) {\n                        }\n                    }\n                });\n\n                return new Subscription() {\n                    @Override\n                    public void unsubscribe() {\n                        t.cancel(true);\n                    }\n                };\n            }\n        })\n        .buffer(1000, TimeUnit.MILLISECONDS, 10) \n        .subscribe(new Action1<List<Integer>>() {\n            @Override\n            public void call(List<Integer> t1) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // This should be called\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        Thread.sleep(10000);\n\n    }\n```\n",
        "Regarding the Future, no, i'm not using a custom scheduler.   Subscriptions.create(final Future<?> f) calls cancel on the future when it is unsubscribed. \n"
    ],
    "431": [
        "Hello guys - I'm on 0.15.1 and still see the issue, on any scheduler you subscribeOn.\nIssue is a little different - I go on getting called onNext on the observer even after unsubscribe(). Only difference is that onComplete is not called.\n",
        "I'll take a look.\n",
        "I think this is fixed in https://github.com/Netflix/RxJava/pull/472\n\nCan someone confirm?\n",
        "Great, I'll release today or tomorrow.\n",
        "Could you provide a unit test to reveal this issue? I tried similar codes but did not find the bug you described.\n",
        "I've observed similar behaviour using rxjava 0.14.6, also on Android when attempting to unsubscribe from a Subscription created using `Schedulers.newThread().schedulePeriodically(...)`\n\nThe failure is fairly easy to reproduce in the context of the application, although it's inconsistent as often the subscriptions are successfully unsubscribed.\n",
        "The test program above prints the values expected when run with the current master, but the whole program just doesn't quit after that. I see three RxNewThreadScheduler threads (2 core machine), all of them waiting for `ThreadPoolExecutor.workQueue.take()`. These threads aren't marked as daemon threads. See NewThreadScheduler L55.\n\nEdit: Maybe they should be regular threads, but the executor running them should be allowed to timeout its single core thread since NewThreadScheduler will start a new pool anyway.\n\n``` java\nprivate static class EventLoopScheduler extends Scheduler {\n    private final ExecutorService executor;\n\n    private EventLoopScheduler() {\n        ThreadPoolExecutor e = (ThreadPoolExecutor)Executors.newFixedThreadPool(1, new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                return new Thread(r, \"RxNewThreadScheduler-\" + count.incrementAndGet());\n            }\n        });\n        e.setKeepAliveTime(1, TimeUnit.SECONDS);\n        e.allowCoreThreadTimeOut(true);\n        executor = e;\n    }\n    ...\n}\n```\n",
        "This test demonstrates the problem, basically the Observable never receives unsubscribes even though the Observer no longer receives notifications:\n\n```\npackage tests;\n\nimport org.junit.Test;\nimport rx.Observable;\nimport rx.Observer;\nimport rx.Subscription;\nimport rx.concurrency.Schedulers;\nimport rx.util.functions.Func1;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class UnsubscribeTest {\n    @Test\n    public void testUnsubscribe() throws InterruptedException {\n        Subscription sub = Observable.interval(1, TimeUnit.SECONDS)\n                .map(new Func1<Long, Long>() {\n                    @Override\n                    public Long call(Long aLong) {\n                        System.out.println(\"generated \" + aLong);\n                        return aLong;\n                    }\n                })\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(Schedulers.currentThread())\n                .subscribe(new Observer<Long>() {\n                    @Override\n                    public void onCompleted() {\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Long args) {\n                        System.out.println(\"Received \" + args);\n                    }\n                });\n\n        Thread.sleep(3000);\n        System.out.println(\"Calling unsubscribe\");\n        sub.unsubscribe();\n        Thread.sleep(3000);\n    }\n}\n```\n\nOutput is:\n\ngenerated 0\nReceived 0\ngenerated 1\nReceived 1\nCalling unsubscribe\ngenerated 2\ngenerated 3\ngenerated 4\ngenerated 5\n\nIf I change the subscribeOn thread to Schedulers.threadPoolForIO() then the output is:\n\ngenerated 0\nReceived 0\ngenerated 1\nReceived 1\nCalling unsubscribe\n",
        "Yes looks fixed to me.\n"
    ],
    "659": [],
    "3244": [],
    "5301": [],
    "6848": [],
    "6003": [],
    "5579": [],
    "439": [
        "Reason: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/README.md\n\nDiscussed here: https://github.com/Netflix/RxJava/issues/297\n\nDoesn't everyone use ProGuard (http://developer.android.com/tools/help/proguard.html) to strip unused byte code and reduce file size of Android apps anyways which makes this moot?\n\nDoes a couple hundred KB really affect Android apps that significantly (particularly in light of ProGuard usage)?\n",
        "Any further comments on my questions about ProGuard?\n",
        "Hi @adriancole, nice to hear from you.\n\n> If it weren't for this, one could consider proguarding rxjava here, in the root project, and remove work for those consuming in android projects.\n\nAgreed. This is what I used to do (not with ProGuard, just a simple exclude when creating the jar).\n\nIf this is such a big deal then let's move the unit tests out. \n\nI still want to know though ... is it not normal for all Android projects to use ProGuard?\n",
        "Interesting, thanks for the insight. \n\nLet's proceed with the unit test refactor.\n",
        "If you can help tackle this @pasviegas I'd appreciate it. I don't have time in the coming days to do this (focused on something else). \n\nThe way I was planning on doing this is taking each inner `UnitTest` call and refactoring out to a separate class with the same package name and class name + 'Test' suffix in the /src/test path.\n\nFor example:\n\nMove /src/main/java/rx/operators/OperationAny.UnitTest https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperationAny.java#L130 to /src/test/java/rx/operators/OperationAnyTest.java\n",
        "This has been merged and I'll release a new version soon. Thank you @pasviegas for the great and tedious work on this!\n",
        "Here at square, the android team take a lot of care to keep distributions small. This issue does come up as more devs are experimenting with rxjava, and it came up again today.\n\nIt is too bad there's a problem with some languages that requires distributing inner test classes in jars.  If it weren't for this, one could consider proguarding rxjava here, in the root project, and remove work for those consuming in android projects.\n\nI'm hoping someone can be creative and determine a way to address the language issues mentioned so that we can use rxjava without increasing the complexity of proguard config in each project that uses rxjava.\n",
        "cc @RayFromSquare\n",
        "hi back at you, @benjchristensen!\n\nSo, we have a number of camps.  Some don't use proguard\u0010, at times because some libraries don't work well with proguard (like dagger), which would lead to custom rules.  Some here use it minimally for targeted obfuscation, but these rules are very simple.  In short, usage isn't universal.\n",
        "thanks @benjchristensen \n",
        "@pasviegas looking forward to it!\n",
        "Thanks, @pasviegas!\n",
        "+1\n",
        "Thanks! If you have any guideline in mind I can help with the refactor!\n\nAnd thx for the awesome library!\n",
        "just to keep everyone updated. \n\nI'll probably send the pull request today. Just need to finish couple of classes, hehe.\n",
        "Cool! Thank you! The library is awesome!\n"
    ],
    "4233": [],
    "2551": [],
    "5975": [],
    "3760": [],
    "441": [],
    "454": [],
    "5652": [],
    "1959": [],
    "4701": [],
    "6480": [],
    "2911": [],
    "5093": [],
    "1065": [],
    "5055": [],
    "6773": [],
    "436": [],
    "4380": [],
    "1946": [],
    "767": [],
    "4096": [],
    "4078": [],
    "3944": [],
    "6849": [],
    "3197": [],
    "3980": [],
    "691": [],
    "4634": [],
    "1369": [],
    "2999": [],
    "275": [],
    "5922": [],
    "6200": [],
    "1764": [],
    "1533": [],
    "1557": [],
    "435": [],
    "3022": [],
    "2899": [],
    "1095": [],
    "3376": [],
    "5613": [],
    "521": [
        "Fixed in https://github.com/Netflix/RxJava/pull/522\n",
        "It's an issue of `interval`. Here is the unit test to reveal it:\n\n``` java\n    @Test\n    public void testIssue521() throws InterruptedException {\n        Observable<Long> o = Observable.interval(200, TimeUnit.MILLISECONDS);\n        Subscription s = o.subscribe(new Observer<Long>() {\n\n            @Override\n            public void onCompleted() {\n                System.out.println(\"onCompleted\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Long args) {\n                System.out.println(args);\n            }\n        });\n        Thread.sleep(1000);\n        s.unsubscribe();\n    }\n```\n\nOutput:\n\n<pre>\n1\n2\n3\n4\nonCompleted\n</pre>\n\nI think `unsubscribe` should not call `onCompleted`.\n",
        "Here is the case in Rx.Net:\n\n``` c#\n            var o = Observable.Interval(TimeSpan.FromMilliseconds(200));\n            var s = o.Subscribe(\n                i => Console.WriteLine(\"Interesting: Infinity = \" + i),\n                e =>  Console.WriteLine(e),\n                () => Console.WriteLine(\"onCompleted\")\n                );\n            Thread.Sleep(1000);\n            s.Dispose();\n            Console.WriteLine(\"Press any key...\");\n            Console.ReadKey();\n```\n\nOutput is:\n\n<pre>\nInteresting: Infinity = 0\nInteresting: Infinity = 1\nInteresting: Infinity = 2\nInteresting: Infinity = 3\nPress any key...\n</pre>\n"
    ],
    "261": [],
    "5747": [],
    "6119": [],
    "440": [],
    "6535": [],
    "4717": [],
    "544": [
        "ReplaySubject is the one I didn\u2019t touch, I refactored Publish/Behavior/Async. I\u2019ll put Replay on my TODO.\n",
        "Ben and I hacked on subjects earlier this week, all subjects are/were in pretty bad shape, but we'll fix it. \n",
        "We should also make sure no additional,on errors,are propagated.\n\nSent from my iPad\n\n> On Nov 30, 2013, at 4:52 AM, akarnokd notifications@github.com wrote:\n> \n> I think this is a trivial fix\n> \n> ```\n> @Override\n> public void onNext(T args)\n> {\n>     synchronized (subscriptions) {\n>         if (isDone) {\n>             return;\n>         }\n>         history.add(args);\n>         for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {\n>             observer.onNext(args);\n>         }\n>     }\n> }\n> ```\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "I think this is a trivial fix\n\n``` java\n    @Override\n    public void onNext(T args)\n    {\n        synchronized (subscriptions) {\n            if (isDone) {\n                return;\n            }\n            history.add(args);\n            for (Observer<? super T> observer : new ArrayList<Observer<? super T>>(subscriptions.values())) {\n                observer.onNext(args);\n            }\n        }\n    }\n```\n"
    ],
    "3678": [],
    "847": [],
    "5759": [],
    "6858": [],
    "3964": [],
    "4192": [],
    "1233": [],
    "4287": [],
    "819": [],
    "2603": [],
    "5838": [],
    "6280": [],
    "1942": [],
    "2579": [],
    "1235": [],
    "2541": [],
    "4324": [],
    "881": [],
    "626": [],
    "3942": [],
    "1298": [],
    "3996": [],
    "5403": [],
    "3762": [],
    "6242": [],
    "4333": [],
    "5637": [],
    "6458": [],
    "595": [
        "According to Rx contract, toList does not need to handle concurrency, doesn't it?\n",
        "Closed as it's fixed in #633 \n",
        "The comment says below that onNext is expected to run concurrently. The solution would be to use a null sentinel:\n\n``` java\nfinal ConcurrentLinkedQueue<Object> list = new ConcurrentLinkedQueue<Object>();\nfinal Object NULL_SENTINEL = new Object();\npublic void onNext(T value) {\n    // onNext can be concurrently executed so list must be thread-safe\n    list.add(value != null ? value : NULL_SENTINEL);\n}\n\npublic void onError(Throwable ex) {\n    observer.onError(ex);\n}\n\npublic void onCompleted() {\n    try {\n        // copy from LinkedQueue to List since ConcurrentLinkedQueue does not implement the List interface\n        ArrayList<T> l = new ArrayList<T>(list.size());\n        for (T t : list) {\n            @SuppressWarnings(\"unchecked\") T t0 = t != NULL_SENTINEL ? (T)t : (T)null;\n            l.add(t0);\n        }\n\n        // benjchristensen => I want to make this list immutable but some clients are sorting this\n        // instead of using toSortedList() and this change breaks them until we migrate their code.\n        // observer.onNext(Collections.unmodifiableList(l));\n        observer.onNext(l);\n        observer.onCompleted();\n    } catch (Throwable e) {\n        onError(e);\n    }\n}\n```\n"
    ],
    "364": [],
    "5623": [],
    "6924": [],
    "6844": [],
    "4984": [],
    "3342": [],
    "6102": [],
    "2591": [],
    "1726": [],
    "4065": [],
    "5047": [],
    "1638": [],
    "3828": [],
    "6862": [],
    "3043": [],
    "3681": [],
    "169": [],
    "3767": [],
    "572": [],
    "624": [
        "I'm not sure I follow. Exactly at which point has `1` already been emitted? It has not been emitted after the `toBlockingObservable` call, because the second example still yields an item. So, somehow, the `.next.iterator.next()` must have \"swallowed\" one item, while the call to `single` manages not to swallow it and emit it as I'd expect. Could you please elaborate in more detail on what is the conceptual (not implementation) difference between the two? I'm still not convinced that the `next` call should skip the item provided by the `BehaviorSubject`.\n\nThank you very much.\n",
        "That clarifies a lot to me about the implementation. Furthermore, you have pointed me to the `toBlockingObservable.toIterable` operator, which is actually exactly what I have been looking for, but didn't found and tried to emulate with the `.next.iterator()` calls that in reality seem to have a slightly different semantics than I originally expected.\n\nThank you indeed,\n  Tom\u00e1\u0161 Dvo\u0159\u00e1k\n",
        "I confirmed that it does not work:\n\n``` java\nSystem.out.println(BehaviorSubject.create(1).take(1).toBlockingObservable().single());\n\nSystem.out.println(BehaviorSubject.create(1).toBlockingObservable().next().iterator().next());\n```\n\nSomeone will need to spend some time looking at `OperationNext`.\n",
        "Interestingly this one works:\n\n``` java\nSystem.out.println(BehaviorSubject.create(1).toBlockingObservable().toIterable().iterator().next());\n```\n",
        "As of 0.20-RC3 these work:\n\n``` java\nSystem.out.println(BehaviorSubject.create(1).take(1).toBlocking().single());\nSystem.out.println(BehaviorSubject.create(2).toBlocking().toIterable().iterator().next());\n```\n\nthis still does not:\n\n``` java\nSystem.out.println(BehaviorSubject.create(3).toBlocking().next().iterator().next());\n```\n",
        "A possible fix that allows the 3rd behavior is in https://github.com/Netflix/RxJava/pull/1501\n",
        "I think you need the `latest` operator #59 (not implemented yet) rather than the `next` operator.\n",
        "Each time you fetch an item from the iterator returned by `next`, you will receive the next incoming item in the Observable. In your example, when you fetch an item from the iterator, `1` has already been emitted, so it will be skipped.\n",
        "This might be a bug in the underlying `OperationNext` L147 ignoring the very first value sent by the behavior subject.\n",
        "In the current RxJava version, when the code comes to `BehaviorSubject(1).toBlockingObservable.next`, the next operator subscribes to the behavior subject. The behavior subject immediately pushes down the value 1. In the next's Observer, there is a check to see if there is someone waiting for a value. Since the code above hasn't reached the `.iterator().next()` yet, which would indicate a demand for a value, the value 1 gets ignored. Now, the chain of call is returning and the `iterator.next` is executed, blocking for a value to arrive, which won't.\n\nIn `BehaviorSubject(1).take(1).toBlockingObservable.single`, the single operator uses toIterable internally, which buffers all values, including the very first `1`, therefore, you'll see the 1.\n\nHope it clears things.\n",
        "I had an explanation some time ago. Bottom line is that the next() can't work in this setup.\n"
    ],
    "2643": [],
    "4313": [],
    "630": [
        "Ha, yep that code is pretty useless. Kind of funny ... I'll submit a fix shortly.\n",
        "Ok the contract is clear.\n\nSo, I don't understand why in **SafeObserver** there is this code\n\n```\ncatch (Throwable e) {\n    // handle errors if the onCompleted implementation fails, not just if the Observable fails\n    onError(e);\n}\n```\n\nIt's in contradiction with the grammar and because **isFinished** is set to **true** so this call is _useless_.\n\nWhy not call a global errorHandler or something like that in the _catch_ ?\n\nI don't understand.\n\nRegards,\nRonan.\n",
        "That's intentional. According to Rx Contract, A observer should not receive both onCompleted and onError. You need to handle the exception in onCompleted by yourself.\n\n![2013-12-17 7 38 00](https://f.cloud.github.com/assets/1000778/1763512/eab38080-670f-11e3-819b-385674e19cbb.png)\n"
    ],
    "5223": [],
    "875": [],
    "1260": [],
    "3448": [],
    "393": [],
    "6441": [],
    "5737": [],
    "353": [],
    "3228": [],
    "1057": [],
    "1899": [],
    "1625": [],
    "5805": [],
    "839": [],
    "3834": [],
    "5202": [],
    "5277": [],
    "5481": [],
    "1138": [],
    "676": [
        "Since `Observable` code changes often enough those links will become wrong so here is the valid code:\n\n``` java\n/**\n     * Whether a given {@link Function} is an internal implementation inside\n     * rx.* packages or not.\n     * <p>\n     * For why this is being used see\n     * https://github.com/Netflix/RxJava/issues/216 for discussion on\n     * \"Guideline 6.4: Protect calls to user code from within an operator\"\n     * \n     * Note: If strong reasons for not depending on package names comes up then\n     * the implementation of this method can change to looking for a marker\n     * interface.\n     * \n     * @param o\n     * @return {@code true} if the given function is an internal implementation,\n     *         and {@code false} otherwise.\n     */\n    private boolean isInternalImplementation(Object o) {\n        if (o == null) {\n            return true;\n        }\n        // prevent double-wrapping (yeah it happens)\n        if (o instanceof SafeObserver) {\n            return true;\n        }\n\n        Class<?> clazz = o.getClass();\n        if (internalClassMap.containsKey(clazz)) {\n            //don't need to do reflection\n            return internalClassMap.get(clazz);\n        } else {\n            // we treat the following package as \"internal\" and don't wrap it\n            Package p = o.getClass().getPackage(); // it can be null\n            Boolean isInternal = (p != null && p.getName().startsWith(\"rx.operators\"));\n            internalClassMap.put(clazz, isInternal);\n            return isInternal;\n        }\n    }\n```\n\n``` java\nif (isInternalImplementation(observer)) {\n                Subscription s = onSubscribeFunction.onSubscribe(observer);\n                if (s == null) {\n                    // this generally shouldn't be the case on a 'trusted' onSubscribe but in case it happens\n                    // we want to gracefully handle it the same as SafeObservableSubscription does\n                    return hook.onSubscribeReturn(this, Subscriptions.empty());\n                } else {\n                    return hook.onSubscribeReturn(this, s);\n                }\n            } else {\n                SafeObservableSubscription subscription = new SafeObservableSubscription();\n                subscription.wrap(onSubscribeFunction.onSubscribe(new SafeObserver<T>(subscription, observer)));\n                return hook.onSubscribeReturn(this, subscription);\n            }\n```\n",
        "Another option I've become more comfortable with (and that @headinthebox prefers) is that we add `Observable.unsafeSubscribe` that `Operator` implementations can use and it does what it says ... subscribe without any \"safety\" wrapping. It would directly invoke the inner `OnSubscribe` function.\n",
        "Do you create operators that act on nested Observables? Examples are `repeat`, `retry`, `merge`.\n\nThose are the only scenario where an `unsafeSubscribe` is needed. Otherwise, normal `Operator` implementations like `map`, `take`, `filter`, etc do not need to.\n",
        "Here is an example location where it is doing an \"unsafe subscribe\": https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorRepeat.java?source=c#L80\n\nWhereas in `map` you'll see it never subscribes because it is a `Subscriber` -> `Subscriber` transformation that gets lifted into the `Observable`: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorMap.java\n",
        "I intend on doing this in 0.18 along with `Scheduler` changes. Do my last explanations make sense, or is there still concern about this change?\n\nThe only time when this will need to be used is when implementing operators that do nested subscriptions. \n",
        "Thanks for the positive confirmation @mttkay ... I'll proceed with this.\n",
        "Completed in https://github.com/Netflix/RxJava/pull/1010\n",
        "Yes, that's what I would prefer. ^F for \"unsafe\" during code reviews to spot where people may shoot themselves in the foot that don't know what they are doing, but allow full power in case you need to implement a new operator.\n",
        "FWIW, I'd lean toward option 2. (Wouldn't this still result in using reflection though, since you'd have to check for the annotation at runtime?)\n\n> marker interfaces require remembering to put them where they should be\n\nTrue. Is this something that could be caught using static analysis?\n\n> they can be put where they're not supposed to be\n\nBut so can any class level annotation. And it can be made only applicable to classes via the target property. I don't see this being an issue really.\n\n> can be used by non-internal operators and misused\n\nSure. Then again, whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? You get what you ask for :-) \n\n> they are an extra type to maintain in the public API serving little value\n\nAre you referring to the marker interface? What's the maintenance overhead though, apart from having to remember applying it to internal observers?\n\nWould be interested in hearing what others have to say\n",
        "I see. I would find it a bit odd though to find unsafeSubscribe invocations\nthroughout my client code, even when I know it's safe. It would raise eye\nbrows for people not as familiar with the peculiarities of the library.\n",
        "+1\n\nOn Mon, Mar 31, 2014 at 7:34 PM, Ben Christensen\nnotifications@github.comwrote:\n\n> I intend on doing this in 0.18 along with Scheduler changes. Do my last\n> explanations make sense, or is there still concern about this change?\n> \n> The only time when this will need to be used is when implementing\n> operators that do nested subscriptions.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/676#issuecomment-39117035\n> .\n"
    ],
    "678": [
        "I sympathize with the plight of the cross-platform RX user - I am one.  However I strongly disagree with the idea of using non-idiomatic names just to make porting code between platforms easier. We tried that with RxJS, and it caused no end of confusion. There are many RX users who use RX across platforms. However there is a much larger potential audience that does not yet use RX, will very likely be exposed to Streams, and will approach reactive programming for the first time in the next two years. \n\nJ\n\nDictated using voice recognition. Please forgive the typos.\n\n> On Dec 27, 2013, at 6:29 AM, Suminda Dharmasena notifications@github.com wrote:\n> \n> Keep the .Net naming and usage intact much as possible. Any language specific idioms can core exit with this.\n> \n> This would help towards less confusion and easy portability in case you maintain a .net API also.\n> \n> This can be extended to the other language bindings also. E.g. idiomatic Scala API should ideally not hide the .Net of F# usage (as in this case F# being closer to Scala / Clojure than C#)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "Note that in JavaScript this method removes the data from the monad.\n\nThat said, we should definitely match the stream APIs closely as possible for Java 8.\n\nDictated using voice recognition. Please forgive the typos.\n\n> On May 20, 2014, at 9:14 AM, headinthebox notifications@github.com wrote:\n> \n> OK with forEach, I think RxJs has that as well.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "Keep the .Net naming and usage intact much as possible. Any language specific idioms can core exit with this.\n\nThis would help towards less confusion and easy portability in case you maintain a .net API also. \n\nThis can be extended to the other language bindings also. E.g. idiomatic Scala API should ideally not hide the .Net of F# usage (as in this case F# being closer to Scala / Clojure than C#) but co exist with the idiomatic language version.\n",
        "What I say is use idiomatic names wherever possible but leave the more familiar naming and usage also. The idiomatic changes would be a few so there will be little overhead.\n",
        "Best is that if there is a possibility / feasibility coordinate across the Rx implementations and the .net project is also open source so there is coherence and API convergence.\n",
        "These are the only ones that seem worth considering:\n\n| Stream API | Observable API |\n| --- | --- |\n| `filter` | `where` |\n| `limit` | `take(n)` |\n| `forEach` | `doOnEach` |\n\nWe have already done `filter`. I am okay with aliasing `take` and `limit`. \n\nThe `forEach` name may also be good. The question then is whether it's a synonym with `doOnEach` or `subscribe(Action1<T>)`. I think it's the later, as someone shouldn't need to `forEach(f).subscribe()`.\n\nShould we alias `subscribe` with `forEach`?\n\n``` java\nvoid forEach(Action1<? super T>)\nvoid forEach(Action1<? super T>, Action1<Throwable>)\nvoid forEach(Action1<? super T>, Action1<Throwable>, Action0)\n```\n",
        "Let's move ahead with this.\n",
        "Completed in https://github.com/Netflix/RxJava/pull/1232\n",
        "``` java\n    public static void main(String[] args) {\n        Observable.from(1, 2, 3).forEach(System.out::println);\n        Observable.from(1, 2, 3).toBlocking().forEach(System.out::println);\n\n        Observable.from(1, 2, 3).limit(2).forEach(System.out::println);\n    }\n```\n",
        "We have both the non-blocking and blocking forms of `forEach` now. The blocking one removes it from the monad.\n\n``` java\nObservable.from(1, 2, 3).forEach(System.out::println);\nObservable.from(1, 2, 3).toBlocking().forEach(System.out::println);\n```\n",
        "OK with forEach, I think RxJs has that as well.\n",
        "Makes sense.\n",
        "Unless one uses call-site lambdas, \"just swapping\" won't work due base functional type mismatch:\n\n``` java\nstream.filter(v -> v % 2 == 0)\nobservable.filter(v -> v % 2 == 0)\n// but\nPredicate<Integer> p = v -> v % 2 == 0\nstream.filter(p);\nobservable.filter(p); // type mismatch\nobservable.filter(p::test);\n```\n\nSome renames/matches of functionality\n\n| Stream API | Observable API |\n| --- | --- |\n| `filter` | `where` |\n| `mapToInt` | primitive observable ??? |\n| `sorted` | N/A |\n| `peek` | ??? |\n| `limit` | `take(n)` |\n| `forEach` | `doOnEach` |\n| `toArray` | `toBlockingObservable().toList().toArray()` |\n| `anyMatch` | `exists().toBlockingObservable().single()` |\n| `count` | `count().toBlockingObservable().single()` |\n| `allMatch` | `all().toBlockingObservable().single()` |\n| `noneMatch` | `all(not()).toBlockingObservable().single()` |\n| `findFirst` | `materialize().toBlockingObservable().first()` |\n| `findAny` | N/A, would be identical to `findFirst` |\n\nSome `Stream` methods exit the stream, this is why there are that many `toBlockingObservable` calls in the table.\n",
        "@benjchristensen I agree with the latter, especially people coming from java 8 streams, it's not obvious that in Rx you then have to subscribe in addition.\n"
    ],
    "6886": [],
    "1813": [],
    "5830": [],
    "683": [
        "These can be used for CEP scenarios to reason over multiple streams. It is best that they stay in some form or other as Java does not have anonymous classes like C# where they could be easily avoided by joining fields into a anonymous class. They are more needed in the JVM implementation than in .net.\n\nIdeally the senarios should be expanded in RxJava.\n",
        "If this is extended to accept an observable sequence as the condition / selector then it would be more useful.\n\nSay I want to buy using signal A if vol is greater than a certain threshold plus some other computationally expensive conditions and signal B otherwise only if I am trading that instrument for the day and I only trade 0.5% of instruments.\n\nThe current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost. Also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription. Using Linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query. This is more difficult though possible in Java than C# hence it will be good to have the conditional functionality extended for other use cases.\n\nMore powerful it would be if you have linq Expressions. This is also possible through Commons JCI or directly using Janino. Perhaps at a later stage.\n",
        "Also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values (boolean / index) for item selection. If not subscribers the condition is not evaluated and if possible each item can be discarded from the streams.\n\nThis would be a more convinient way to use this functionality.\n",
        "@headinthebox \n\nAdd an extra overload with Func<bool, TResult, TResult> condition for if and Func<TValue, TResult[]> selector ... etc.\n\nif(\n(a, b) -> !a.equals(obj1) && b.equals(obj2),\nstrm1,\nstrm2)\n\nthis case condition is evaluated as needed but for each element coming in\n",
        "@headinthebox \n\nIn a nutshell the extension will help combination and generation. Something you can consider for the main implementation also.\n",
        "Migrating conditionals to a contrib module: https://github.com/Netflix/RxJava/pull/714\n",
        "Here is a link to documentation on their usage: http://weblogs.asp.net/podwysocki/archive/2010/06/18/introduction-to-the-reactive-extensions-for-javascript-conditionals.aspx\n",
        "http://msdn.microsoft.com/en-us/library/dd233182.aspx \n\nI don't know of anyone using this for real in Rx.NET.\n",
        "@sirinath can you give a concrete example? I don't see the connection between these operators which are intended to overload imperative control structures in F# computation expressions and anonymous types.\n",
        "@sirinath Could you provide a concrete example? I am not sure that I understand what you are after precisely.\n",
        "These could be moved into a `rxjava-contrib/rxjava-dotnet-legacy` package along with those ops that have been added just to match Rx.Net.\n"
    ],
    "6014": [],
    "4831": [],
    "1895": [],
    "189": [],
    "1632": [],
    "948": [],
    "6639": [],
    "3803": [],
    "6101": [],
    "1743": [],
    "1833": [],
    "4417": [],
    "3653": [],
    "711": [
        "Removed `ExecutorScheduler` and replaced with `ComputationScheduler` that has a pool of event loops: https://github.com/Netflix/RxJava/pull/1048\n"
    ],
    "713": [
        "I used it to bound the number of IO requests in progress at the same time to avoid saturating the memory of the receiver on Android. I guess I will have to find another way.\n",
        "I would like to see the ExecutorScheduler come back without the default thread pool concurrency. ExecutorScheduler was the simplest way to delegate scheduling to the glib event loop:\n\n``` java\npublic class GlibExecutor implements Executor {\n    @Override\n    public void execute(@NotNull final Runnable runnable) {\n        Glib.idleAdd(new Handler() {\n            public boolean run() {\n                runnable.run();\n                return false;\n            }\n        });\n    }\n}\n```\n\nIt looks like I now have to subclass rx.Scheduler directly. That seems straight-forward enough, but the ExecutorScheduler was very nice here.\n",
        "Removed `ExecutorScheduler` and replaced with `ComputationScheduler` that has a pool of event loops: https://github.com/Netflix/RxJava/pull/1048\n",
        "> I seem to be failing to understand how ComputationScheduler is a replacement for ExecutorScheduler\n\nIt's not a direct replacement. The `ExecutorScheduler` had significant problems as this issue discusses.\n\n> Specifically, I was using .observeOn() so the observer would be executed on the Android main thread.\n\nYou should use the AndroidScheduler: https://github.com/Netflix/RxJava/tree/master/rxjava-contrib/rxjava-android#observing-on-arbitrary-threads\n\n> as that would be more idiomatic for Scala\n\nThat should be done as part of rxjava-scala: https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala\n\n> I used it to bound the number of IO requests in progress at the same time\n\nThis is a valid use case (at Netflix we use Hystrix for that server-side, but that's not helpful for Android).  \n\nI'm totally okay with `ExecutorScheduler` coming back as long as it complies with the contract, which it never has. It is not obvious how to make it work.\n\nThe concurrent throttling case can be solved in other ways, including a `Scheduler` implementation that has a bounded number of threads, but that correctly use event loops on top of each thread. I know @akarnokd was experimenting with a fixed-side event loop pool that could be used for this.\n\nIf that was adopted into the core library, it would probably be something like `Schedulers.fixedPool(int num)`, but the problem with that is it's a factory that produces a new pool every time, so users would have to make sure to create it and store a reference to it, otherwise it would not work. This is quite different from how the other Schedulers are used, where the factory methods are invoked every time such as `Schedulers.io()`, `Schedulers.computation()` and `Schedulers.newThread()`.\n\nWhat do you all think should be done?\n",
        "I seem to be failing to understand how ComputationScheduler is a replacement for ExecutorScheduler. I was using ExecutorScheduler because I needed certain code to run in a certain thread. Specifically, I was using .observeOn() so the observer would be executed on the Android main thread.\n\nI'd also be perfectly happy with a scheduler that wraps a scala.concurrent.ExecutionContext instead, as that would be more idiomatic for Scala. Is there a way to do either with ComputationScheduler?\n"
    ],
    "6739": [],
    "3055": [],
    "1070": [],
    "2897": [],
    "560": [],
    "1112": [],
    "1166": [],
    "4694": [],
    "3500": [],
    "3465": [],
    "1309": [],
    "2807": [],
    "3485": [],
    "991": [],
    "737": [
        "If publication is not safe, then there is no happens-before relationship between the assignment of the instance's fields and its unsafe publication. If the instance contains final fields, then Java inserts a memory barrier at the end of the constructor and publication is ensured to be safe \n",
        "Closing as no further comments in a long time. This is likely fixed with the recent fixes to `buffer`. \n\n@dvtomas Please re-open if there are still issues. \n",
        "Confirm this is a bug in `switch`. Thanks, @dvtomas \n",
        "`latest` does not need `volatile` as it's protected by `synchronized (gate)` and never used outside the lock.\n",
        "Sorry, @akarnokd , you're right. The initial step is not thread-safe.\n",
        "If latest is not volatile, latest can not be guaranteed to be 0.\n",
        "Just refreshed my java concurrency knowledge. `latest` is ensured to be 0 by `synchronized` rather than `instance initialization`. Right? \n",
        "From JSR-133 3.5 Final Fields, \"a thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object\u2019s `\ufb01nal` \ufb01elds.\"\n\nhttp://download.oracle.com/otn-pub/jcp/memory_model-1.0-prd-oth-G-F/memory_model-1_0-prd-spec.pdf?AuthParam=1389609770_22e201e49d67d0a8ae6bcaccaedd8518\n\nthe constructor is only guaranteed to make `final` fields visible.\n",
        "However, I don't know if the default value 0 of a non-final field will be guaranteed to be visible to other threads after the constructor is finished. Is it possible that other threads see a random uninitialized value?\n",
        "From [JLS 17.4.4. Synchronization Order](http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.4),\n\n> The write of the default value (zero, false, or null) to each variable synchronizes-with the first action in every thread.\n> Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated, **conceptually every object is created at the start of the program with its default initialized values**.\n\nSo if a field is the default value (zero, false, or null) and does not be assigned, the default value is always visible to every thread. \n",
        "I see another issue. The op uses `MultipleAssignmentSubscription` to store the inner subscription. When the switch to the next occurs, it does not unsubscribe from the previous Observable which will keep running indefinitely. I think `child` should be `SerialSubscription` instead.\n\n~~In addition, `latest` isn't volatile so checking the current index wouldn't be safe.~~ My mistake, accessed under gate.\n",
        "I was wrong, didn't \"see\" the synchronized. Btw, instance initialization esures that the `latest` field is seen to be 0, no need for volatile.\n\nWhile you are at it, could you move any `unsubscribe()` outside the synchronization blocks?\n",
        "When you call `new SourceObserver()`, the constructor is guaranteed to make fields visible.\n",
        "The buffer operator has been rewritten with extra effort for making sure values don't fall between two windows if timespan == timeshift. Does it work for you?\n"
    ],
    "3526": [],
    "3727": [],
    "1909": [],
    "4140": [],
    "6175": [],
    "390": [],
    "746": [
        "It's probably unrealistic to assume that all of the operations can be rewritten in one pull request.  This method will allow existing operators that use `OnSubscribeFunc` to still work.\n\n``` java\n    public static <X> Obsurvable<X> create(final OnSubscribeFunc<X> onSub) {\n        return create(new Action2<Observer<X>, OperatorSubscription>() {\n            @Override\n            public void call(Observer<X> in, OperatorSubscription s) {\n                Subscription sub = onSub.onSubscribe(in);\n                s.add(sub);\n            }\n        });\n    }\n```\n",
        "@akarnokd I think the root of your zip problems comes from the use of `Observable.create(...)` and not `this.bind(...)`.\n",
        "For last couple days I've been working on building on this to build a visual debugger of sorts for Rx. Because of the OperatorSubscription.add() method it allows the association between inner and outer observers to be discovered (aka merge). Here is a sample the raw data that I was able to get with four hooks (on create, on bind, on add and on observe) for the code\n\n`from(1,3,5).flatMap({i -> from(i, i+1)}).take(3).subscribe({ print it })`\n\n![obsurdebug](https://f.cloud.github.com/assets/406038/1937976/59c177bc-7f38-11e3-9134-b209dd40a767.png)\n",
        "I think you might be right about the Func0 being unnecessary. My current workspace is too far removed from the base line its hard to say for sure but I was able to remove the Func0 implementations and it still work for my use case.\n",
        "I like this approach. It keeps the user facing behaviour the same while allowing for a simpler implementation. \n\nAfter a first look, it seems that upstream operators shouldn't be able to unsubscribe downstream operators. So, bind would change to:\n\n``` java\npublic <R> Obsurvable<R> bind(final Func2<Observer<R>, OperatorSubscription, Observer<T>> bind) {\n    return new Obsurvable<R>(new Action2<Observer<R>, OperatorSubscription>() {\n\n        @Override\n        public void call(Observer<R> o, OperatorSubscription s) {\n            OperatorSubscription s2 = new OperatorSubscription();\n            s.add(s2)\n            f.call(bind.call(o, s), s2);\n        }\n    });\n}\n```\n\nTake can unsubscribe from all the upstream operators, but these can't unsubscribe Take (which would be notified through onComplete).\n",
        "We can write merge like so:\n\n``` java\n@Override\npublic void onNext(Obsurvable<T> innerObsurvable) {\n    Subscription innerSubscription = innerObsurvable.subscribe(new Observer<T>() {\n      // ...\n    });\n\n    outerSubscription.add(innerSubscription);\n}\n```\n\nWe already have to protect against onNext calls arriving after a call to onCompleted and unsubscribe, so first subscribing to the inner observable and then adding the inner subscription to the composite won't introduce any new interleaving.\n\nThis seems to allow for option 2) b) while also allowing people to create arbitrary nested observables, or am I missing something?\n",
        "> Each of the inner Observable instances can also be synchronous which would make the call to subscribe block and thus we would never receive the Subscription back.\n\nRight! I forgot about that case. The overload taking a subscription factory seems like the better approach then.\n",
        "Yes, it solves that problem. I like it!\n",
        "For feedback /cc @headinthebox @abersnaze @samuelgruetter @jmhofer @mairbek @zsxwing @akarnokd @michaeldejong @johnhmarks @duarten @rickbw\n",
        "> We can write merge like so\n\nEach of the inner `Observable` instances can also be synchronous which would make the call to `subscribe` block and thus we would never receive the `Subscription` back.\n\nI think we may just want to provide a `subscribe` overload or new name such as:\n\n``` java\npublic final void subscribe(Observer<? super T> observer, OperatorSubscription s)\n// or\npublic final void observe(Observer<? super T> observer, OperatorSubscription s)\n```\n\nI think I'd prefer the different name `observe`. I'm not super concerned with discoverability as it's incredibly rare that someone would need to be building an operator of this type and in that case they're reading the docs and complying with the `create`/`bind`/`observe` semantics. \n\nUPDATE\n\nThese signatures only work for \"one shot\" unless they create a new `OperatorSubscription` each time. Which is why it's beneficial for it to be hidden inside the normal `subscribe`. If someone is going to use this though they generally should have a reason (creating a nested operator) so that may be okay, or we could change the signature to protect against that by doing it as:\n\n``` java\npublic final void observe(Observer<? super T> observer, Func0<OperatorSubscription> subscriptionFactory)\n```\n",
        ">  external users are still unable to cancel the long running operation as subscribe won't return the subscription until it has finished\n\nI have yet to see actual use code where they use the `Subscription` received from `subscribe`. It's more-or-less a sign they are doing it wrong if they need to as they should instead be using things like `take` and `takeUntil` (particularly `takeUntil` for conditional cases) for ending `Observables`.\n\nThe only time I'm aware of a `Subscription` from `subscribe` being used for valid reasons is when building operators to combine `Observables` together, and in that case we are saying to use `bind` instead. See the previous comment for thoughts on exposing the \"private subscribe\" publicly for the rare case of building a new operator beyond `merge`/`concat`/`zip`/`switch`/etc for nested behavior.\n",
        "> After the modification it appears to me that we replace one problem with another: now one would need to carefully isUnsubscribed almost everywhere and think twice when to call unsubscribe.\n\nHow is this any different than now? We currently have to very carefully consider where to place a `Subscription`, what to put within it and what manual cancellation tokens (usually a boolean) we have to check while in loops that will be set by that `Subscription` we return. I see the consideration exactly the same.\n\nI also don't see it as any more sensitive about when to call `unsubscribe`. It has the same impact as our current approach does. As soon as you call it everything is supposed to shut down. So how do we have to think twice in one approach but not in the other?\n\nOn top of that, with the current implementation we have to deal with the fact that the approach doesn't work for synchronous use cases and we have to keep answering questions from people as to why their code doesn't behave as they expect and we keep telling them \"use Schedulers\" which in effect means Rx is only useful if all data sources is async (or small enough to not be a problem ... which kind of defeats the purpose). \n\nHowever, this is actually only half the answer, as in Rx.Net those synchronous cases work by putting everything on a recursive `CurrentThreadScheduler` and interweaving through the code base \"hacks\" to modify tokens similar or equal to ThreadLocal state that then stop the recursion. See my benefits (4) and (5) for why this new approach to `create`/`bind` seems far better than that. Thus, if we don't use this `bind` approach we have to accept slower behavior for all recursion and figure out how to make `CurrentThreadScheduler` work. I spent time implementing it and it was basically \"whack-a-mole\" with hacks in multiple places in the codebase to capture an `unsubscribe` and set it on a ThreadLocal so `CurrentThreadScheduler` could see that it had been `unsubscribed` and stop recursion. This is fairly straight-forward when on a single thread. It all becomes far more difficult when crossing over thread boundaries or when nesting `Observables` and different `Schedulers` in a single `Observable` sequence.\n",
        "> After a first look, it seems that upstream operators shouldn't be able to unsubscribe downstream operators. So, bind would change to:\n\nI need to play with this a bit to better understand and will then respond... \n",
        "The `MergeOperator` would end up like this:\n\n``` java\n                public void onNext(Obsurvable<T> innerObsurvable) {\n                    innerObsurvable.subscribe(new Observer<T>() {\n\n                        @Override\n                        public void onCompleted() {\n                            synchronized (o) {\n                                o.onCompleted();\n                            }\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            synchronized (o) {\n                                o.onError(e);\n                            }\n                        }\n\n                        @Override\n                        public void onNext(T a) {\n                            synchronized (o) {\n                                o.onNext(a);\n                            }\n                        }\n\n                    }, new Func0<OperatorSubscription>() {\n\n                        @Override\n                        public OperatorSubscription call() {\n                            OperatorSubscription innerSubscription = new OperatorSubscription();\n                            outerSubscription.add(innerSubscription);\n                            return innerSubscription;\n                        }\n\n                    });\n\n                }\n```\n\nUsing a `subscribe` method like this:\n\n``` java\n    public void subscribe(Observer<T> o, Func0<OperatorSubscription> sf) {\n        f.call(o, sf.call());\n    }\n```\n\nIt's a little unnecessary for a private operator \"doing the right thing\" and involves closing over the `outerSubscription` but it does provide a safe public signature.\n",
        "Updated prototype code with `observe` method: https://gist.github.com/benjchristensen/8367765\n\nThis would make the `create`/`bind`/`observe` methods siblings for creating operators.\n\nThus, an `Observable` is `observed` by an `Observer` and the `OperatorSubscription` is always injected.\n\nThe \"public\" signature of `Observable.subscribe` is unchanged.\n",
        "@akarnokd Here is another implementation of `zip` as comparison: https://gist.github.com/benjchristensen/8367765#file-obsurvable-java-L340 \n\nThe only place an `unsubscribe` is invoked is here: https://gist.github.com/benjchristensen/8367765#file-obsurvable-java-L427\n\nThere are no places where it must be checked.\n\nThe most interesting unit test for this is `testZipInfiniteAndFinite()` as it must `unsubscribe` the children: https://gist.github.com/benjchristensen/8367765#file-obsurvable-java-L549 \n\nThe thing that makes this work is that whenever a subscription occurs via `observe` the `Subscription` is injected into it and applies to the entire lifecycle of that subscription. This can be seen here:\n\n``` java\nos[i].observe((InnerObserver) observers[i], new Func0<OperatorSubscription>() {\n\n    @Override\n    public OperatorSubscription call() {\n        return childSubscription;\n    }\n});\n```\n\nThis could be simplified to the following if we want to make a user have to \"do the right thing\" when using it:\n\n``` java\nos[i].observe((InnerObserver) observers[i], childSubscription);\n```\n\nThe same `childSubscription` is injected into all `Obsurvables` being zipped together so a single `unsubscribe` will cause them all to be unsubscribed as each of them will be looking at the same `Subscription` wherever applicable (such as a `ObsurvableFromIterable` loop).\n",
        "While implementing various operators I ran into `groupBy` which required a signature change on `bind` to compose the `Subscriptions`. It's working, though I'm not convinced the signature is as elegant as it can be.\n\nThe prototype code is still here: https://gist.github.com/benjchristensen/8367765 It has grown to include `bind`, `map`, `flatMap`, `merge`, `take`, `zip`, `groupBy`, and `repeat`. There are unit tests for these asserting behavior including handling infinite synchronous streams, composed subscriptions and general functionality.\n\nI have also split out a simpler example (ObsurvableBind.java) with just the `bind` operator and a small number of unit tests for necessary functionality to simplify discussion of and iterating on the `bind` signature: https://gist.github.com/benjchristensen/8486461\n\nThe essential parts of the code are currently:\n\n``` java\npublic static <T> ObsurvableBind<T> create(final Action2<Observer<T>, OperatorSubscription> f) {\n    return new ObsurvableBind<T>(f);\n}\n\npublic void observe(Observer<T> o, OperatorSubscription sf) {\n    f.call(o, sf);\n}\n\npublic Subscription subscribe(Observer<T> o) {\n    final OperatorSubscription os = new OperatorSubscription();\n    observe(o, os);\n    return os;\n}\n\npublic static interface Operator<T> extends Observer<T> {\n\n    public OperatorSubscription getSubscription();\n}\n\npublic <R> ObsurvableBind<R> bind(final Func2<Observer<R>, OperatorSubscription, Operator<T>> bind) {\n    return new ObsurvableBind<R>(new Action2<Observer<R>, OperatorSubscription>() {\n\n        @Override\n        public void call(Observer<R> o, final OperatorSubscription s) {\n            Operator<T> ot = bind.call(o, s);\n            observe(ot, ot.getSubscription());\n        }\n    });\n}\n```\n\nThis achieves the generally desired traits but I'd like to see if we can come up with a better way of representing the `Func` definition of `bind`.\n\nThe `public void testBindUnsubscribeNested()` unit test represents the `groupBy` type functionality that requires nested composition of `Subscriptions`.\n",
        "Here is another possible variant of the signature: https://gist.github.com/benjchristensen/8497234\n\nInstead of `Func2<Observer<R>, OperatorSubscription, Operator<T>>` it uses `Func1<Operator<R>, Operator<T>>`:\n\n``` java\npublic static <T> ObsurvableBind2<T> create(final Action1<Operator<T>> f) {\n    return new ObsurvableBind2<T>(f);\n}\n\npublic <R> ObsurvableBind2<R> bind(final Func1<Operator<R>, Operator<T>> bind) {\n    return new ObsurvableBind2<R>(new Action1<Operator<R>>() {\n\n        @Override\n        public void call(Operator<R> o) {\n            observe(bind.call(o));\n        }\n    });\n}\n\npublic void observe(Operator<T> o) {\n    f.call(o);\n}\n\npublic Subscription subscribe(final Observer<T> o) {\n    final OperatorSubscription os = new OperatorSubscription();\n    observe(createOperator(o, os));\n    return os;\n}\n\npublic static interface Operator<T> extends Observer<T> {\n\n    /**\n     * Get the Subscription intended to pass up to the source being bound to.\n     * <p>\n     * In other words, the subscription from Operator -> Source\n     */\n    public OperatorSubscription getSubscription();\n}\n```\n",
        "Here is another variant: https://gist.github.com/benjchristensen/8506432\n\nThis eliminates the `OperatorSubscription` and the `Operator` becomes an abstract class instead of interface:\n\n``` java\npublic static abstract class Operator<T> implements Observer<T>, Subscription {\n\n        private final CompositeSubscription cs;\n\n        Operator(CompositeSubscription cs) {\n            this.cs = cs;\n        }\n\n        Operator() {\n            this.cs = new CompositeSubscription();\n        }\n\n        /**\n         * Used to register an unsubscribe callback.\n         */\n        public final void add(Subscription s) {\n            cs.add(s);\n        }\n\n        @Override\n        public final void unsubscribe() {\n            cs.unsubscribe();\n        }\n\n        public final boolean isUnsubscribed() {\n            return cs.isUnsubscribed();\n        }\n    }\n```\n\nThe `create`/`bind`/`observe` signatures stay the same:\n\n``` java\n    public static <T> ObsurvableBind3<T> create(final Action1<Operator<T>> f) {\n        return new ObsurvableBind3<T>(f);\n    }\n\n    public <R> ObsurvableBind3<R> bind(final Func1<Operator<R>, Operator<T>> bind) {\n        return new ObsurvableBind3<R>(new Action1<Operator<R>>() {\n\n            @Override\n            public void call(Operator<R> o) {\n                observe(bind.call(o));\n            }\n        });\n    }\n\n    public void observe(Operator<T> o) {\n        f.call(o);\n    }\n```\n\n@rickbw Are these different variants solving your concerns? What improvements would you make to their signatures and which do you prefer?\n\n@duarten I believe these new signatures address the problem you brought up regarding the passing of `Subscription`. The unit tests combining `groupBy` and `take` assert the particular use case.\n",
        "Anyone interested in this please take a look at the pull request I just submitted.\n\n@headinthebox and @samuelgruetter I could use your help fixing the Scala module. \n",
        "Thanks everyone for your discussion on this. I have merged the implementation. \n\nNext steps are:\n\n1) Nail down naming and signatures: https://github.com/Netflix/RxJava/issues/775\n2) Document (a README or Wiki page) operator implementation standards, guidelines and best practices\n3) Update operator implementations over time.\n",
        "Thanks @mttkay for getting involved and providing feedback. \n\nI too have similar concerns about `Observer` become `abstract` and I'm still considering the pros and cons of the change but thus far have come to see `abstract Observer implements Subscription` as being the best of the proposed designs.\n\nFor unit tests your code would need to change like this:\n\n``` java\nObserver mockObserver = mock(Observer.class);\nobj.getObservable().subscribe(new TestObserver(mockObserver));\nArgumentCaptor<Observer> onNextArgs = ArgumentCaptor.of(...)\nverify(mockObserver).onNext(onNextArgs.capture())\n// do expecations against onNextArgs\n```\n\nGoing back to the discussion on signatures in https://github.com/Netflix/RxJava/issues/775 the choice is basically to either:\n\na) change `Observer` to an `abstract` class and have a single type\nb) create a new type that combines `Observer` and `Subscription` and is used in the `create(OnSubscribe)` and `lift` signatures but not `subscribe`.\n\nAt this point the strongest argument has been to keep the public API clean and have a single `Observer` type that works in all cases. The drawback of this approach though is the impact on multiple-inheritance and unit testing.\n\nThe current signatures are:\n\n``` java\n// Observable.create\npublic final static <T> Observable<T> create(OnSubscribe<T> f)\n\n// Observable.OnSubscribe typed function interface\npublic static interface OnSubscribe<T> extends Action1<Observer<? super T>>\n\n// lift function\npublic <R> Observable<R> lift(final Func1<Observer<? super R>, Observer<? super T>> bind)\n\n// Observer\npublic abstract class Observer<T> implements Subscription {\n     public abstract void onNext(T t);\n     public abstract void onError(Throwable e);\n     public abstract void onCompleted();\n     public final void add(Subscription s)\n     public final void unsubscribe()\n     public final boolean isUnsubscribed()\n}\n\n// Subject\npublic abstract class Subject<T, R> extends Observer<T> {\n    public abstract Observable<R> toObservable();\n}\n```\n\nAnyone have a better design than this?\n",
        "This code demonstrates what the new signatures allow:\n\n``` java\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Observer<? super Integer> ob) {\n                for (int i = 1; i < 100000; i++) {\n                    /*\n                     * The Observer communicates whether it is unsubscribed\n                     * so loops and seqential processing on the same thread\n                     * can now unsubscribe.\n                     */\n                    if (ob.isUnsubscribed()) {\n                        System.out.println(\"--- Unsubscribed at: \" + i);\n                        return;\n                    }\n                    ob.onNext(i);\n                }\n                ob.onCompleted();\n            }\n\n        }).subscribe(new Observer<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                System.out.println(\"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                e.printStackTrace();\n            }\n\n            @Override\n            public void onNext(Integer i) {\n                System.out.println(\"Received: \" + i);\n                if (i == 10) {\n                    // an Observer can now unsubscribe\n                    unsubscribe();\n                }\n            }\n\n        });\n\n    }\n```\n\nThis outputs:\n\n```\nReceived: 1\nReceived: 2\nReceived: 3\nReceived: 4\nReceived: 5\nReceived: 6\nReceived: 7\nReceived: 8\nReceived: 9\nReceived: 10\n--- Unsubscribed at: 11\n```\n\nNote how the source `Observable` can check `ob.isUnsubscribed()` and the `Observer` can now `unsubscribe()` all within a single-threaded sequential call.\n\nThis is equally beneficial if the Observable is made async by running on a separate thread, but still a sequential for-loop instead of trampolining (which is far slower than a loop and both less obvious and more complicated to implement):\n\n``` java\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Observer<? super Integer> ob) {\n                for (int i = 1; i < 100000; i++) {\n                    /*\n                     * The Observer communicates whether it is unsubscribed\n                     * so loops and seqential processing on the same thread\n                     * can now unsubscribe.\n                     */\n                    if (ob.isUnsubscribed()) {\n                        System.out.println(\"--- Unsubscribed at: \" + i);\n                        return;\n                    }\n                    ob.onNext(i);\n                }\n                ob.onCompleted();\n            }\n                  // use subscribeOn so it is now async\n        }).subscribeOn(Schedulers.newThread()).subscribe(new Observer<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                System.out.println(\"Completed\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                e.printStackTrace();\n            }\n\n            @Override\n            public void onNext(Integer i) {\n                System.out.println(\"Received: \" + i);\n                if (i == 10) {\n                    // an Observer can now unsubscribe\n                    unsubscribe();\n                }\n            }\n\n        });\n```\n\nThis means we do want the `Observer` to be more intelligent and encapsulate the `Subscription` so we achieve these goals.\n\nUnit testing is doable by using `TestObserver` and I'm okay with that being slightly less elegant. \n\nThe remaining drawback is the inability to `implement Observer` since it is now abstract. \n\nA relevant question is whether classes need to `implement Observer` so as to \"be\" an `Observer`. We do not support this on `Observable`; classes are not \"an\" `Observable` but generally have getters that return an `Observable` or a class has a `toObservable()` method on it.\n\nSimilarly classes do not need to be an `Observer` but can encapsulate that logic. That said, there may still be value in having an interface that represents something that can be turned into an `Observer`.\n\nRight now `Observable` has that with the `Observable.OnSubscribe` interface. Should we have something similar for `Observer`? If so, what should it be called? `Observer.OnObserve`?\n\nWe either need a new name for `Observer+Subscription` (the currently modified `Observer`) and return `Observer` to just the 3 on\\* methods and a mechanism for converting from it to the `Observer+Subscription`. Or we leave `Observer` as `Observer+Subscription` and come up with a different name to represent the interface of the 3 on\\* methods.\n",
        "> Can't we provide a default implementation of Observer like this?\n\nThat is how it is implemented: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observer.java\n",
        "If we go this path, an interface `Notifiable` could work, since we already have the `Notification` type.\n\n``` java\npublic abstract class Observer<T> implements Subscription, Notifiable\n```\n\nOr we could leave `Observer` as the passive object that receives notifications and use `Subscriber` to represent the thing that calls `subscribe` and it would implement `Observer` and `Subscription`.\n\n``` java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription\n```\n",
        "Note that if we went to having `Subscriber` and `Observer` we'd then have the question of whether we allow `Observable.subscribe(Observer o)` because if we did, those implementations could not `unsubscribe`. \n\nThat is probably fine though, as most `Observer`'s don't need to unsubscribe.\n\nThus we could have methods like this in `Observable`:\n\n``` java\nvoid subscribe(Subscriber s)\nSubscription subscribe(Observer o)\n```\n",
        "I did an implementation using `Subscriber` to see if it makes sense. Please provide feedback on issue https://github.com/Netflix/RxJava/issues/792.\n",
        "public static abstract class Operator<T> implements Observer<T>, Subscription {\n\n}\n\nThis I like.\n\nOn Sun, Jan 19, 2014 at 4:44 PM, Ben Christensen\nnotifications@github.comwrote:\n\n> Here is another variant: https://gist.github.com/benjchristensen/8506432\n> \n> This eliminates the OperatorSubscription and the Operator becomes an\n> abstract class instead of interface:\n> \n> public static abstract class Operator<T> implements Observer<T>, Subscription {\n> \n> ```\n>     private final CompositeSubscription cs;\n> \n>     Operator(CompositeSubscription cs) {\n>         this.cs = cs;\n>     }\n> \n>     Operator() {\n>         this.cs = new CompositeSubscription();\n>     }\n> \n>     /**         * Used to register an unsubscribe callback.         */\n>     public final void add(Subscription s) {\n>         cs.add(s);\n>     }\n> \n>     @Override\n>     public final void unsubscribe() {\n>         cs.unsubscribe();\n>     }\n> \n>     public final boolean isUnsubscribed() {\n>         return cs.isUnsubscribed();\n>     }\n> }\n> ```\n> \n> The create/bind/observe signatures stay the same:\n> \n> ```\n> public static <T> ObsurvableBind3<T> create(final Action1<Operator<T>> f) {\n>     return new ObsurvableBind3<T>(f);\n> }\n> \n> public <R> ObsurvableBind3<R> bind(final Func1<Operator<R>, Operator<T>> bind) {\n>     return new ObsurvableBind3<R>(new Action1<Operator<R>>() {\n> \n>         @Override\n>         public void call(Operator<R> o) {\n>             observe(bind.call(o));\n>         }\n>     });\n> }\n> \n> public void observe(Operator<T> o) {\n>     f.call(o);\n> }\n> ```\n> \n> @rickbw https://github.com/rickbw Are these different variants solving\n> your concerns? What improvements would you make to their signatures and\n> which do you prefer?\n> \n> @duarten https://github.com/duarten I believe these new signatures\n> address the problem you brought up regarding the passing of Subscription.\n> The unit tests combining groupBy and take assert the particular use case.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/746#issuecomment-32711145\n> .\n",
        "Samuel, the subscription comes from the IDispoable, which is not in the Java Iterable interface.\n",
        "Can't we provide a default implementation of Observer like this?\n\n``` Java\npublic abstract class Observer<T> implements Subscription {\n     public abstract void onNext(T t);\n     public abstract void onError(Throwable e);\n     public abstract void onCompleted();\n\n     protected Subscription subscription = .... default implementation for Subscription ...\n     public final void add(Subscription s){ subscription.add(s); }\n     public final void unsubscribe(){ subscription.unsubscribe(); }\n     public final boolean isUnsubscribed(){ return subscription.isUnsubscribed(); }\n}\n```\n",
        "After the first look, it definitely solves the take(n) problem as the downstream take can now access the cancellation token for the upstream (btw, loops should exit with return instead of break in case of isUnsubscribed). \n\nHowever, external users are still unable to cancel the long running operation as subscribe won't return the subscription until it has finished. One would need to have an overload where the cancellation token is passed in from the outside as well (or a binding which leaks the OperatorSubscription):\n\n``` java\nOperatorSubscription os = new OperatorSubscription();\nSchedulers.computation().schedule(() -> os.unsubscribe(), 1, TimeUnit.SECONDS);\nObsurvable.from(1).repeat().subscribe(os, new Observer<T>() { ... }); // void\n```\n\nBut it doesn't work at the moment as from(1) unsubscribes the os and repeat can't really repeat it (it prints 1 and two onCompleted). If I remove the unsubscribe and change repeat to not emit onCompleted, it works as expected and honors the RxJava contract better (see [8415495](https://gist.github.com/akarnokd/8415495) and [8415517](https://gist.github.com/akarnokd/8415517)).\n\nAfter the modification it appears to me that we replace one problem with another: now one would need to carefully isUnsubscribed almost everywhere and think twice when to call unsubscribe.\n",
        "I've implemented zip with this new paradigm and it felt a bit odd:\n\n``` java\npublic <U, R> Obsurvable<R> zip(Obsurvable<U> other, Func2<T, U, R> resultSelector) {\n        Obsurvable<T> t = this;\n        return Obsurvable.create((o, s) -> {\n            Object guard = new Object();\n            Queue<T> leftQueue = new LinkedList<>();\n            Queue<U> rightQueue = new LinkedList<>();\n            AtomicBoolean leftDone = new AtomicBoolean();\n            AtomicBoolean rightDone = new AtomicBoolean();\n            OperatorSubscription tsub = new OperatorSubscription();\n            OperatorSubscription usub = new OperatorSubscription();\n            s.add(tsub);\n            s.add(usub);\n            Action0 stride = () -> {\n                boolean done = false;\n                synchronized (guard) {\n                    while (!leftQueue.isEmpty() \n                            && !rightQueue.isEmpty() \n                            && !s.isUnsubscribed()) {\n                        try {\n                            o.onNext(resultSelector.call(leftQueue.poll(), rightQueue.poll()));\n                        } catch (Throwable e) {\n                            o.onError(e);\n                            s.unsubscribe();\n                            return;\n                        }\n                    }\n                    if (!s.isUnsubscribed()) {\n                        if ((leftQueue.isEmpty() && leftDone.get())\n                                || (rightQueue.isEmpty() && rightDone.get())) {\n                            done = true;\n                            o.onCompleted();\n                        }\n                    }\n                }\n                if (done) {\n                    s.unsubscribe();\n                }\n            };\n            t.observe(new Observer<T>() {\n                @Override\n                public void onNext(T args) {\n                    synchronized (guard) {\n                        leftQueue.offer(args);\n                    }\n                    stride.call();\n                }\n                @Override\n                public void onError(Throwable e) {\n                    synchronized (guard) {\n                        o.onError(e);\n                    }\n                    s.unsubscribe();\n                }\n                @Override\n                public void onCompleted() {\n                    synchronized (guard) {\n                        leftDone.set(true);\n                    }\n                    stride.call();\n                }\n            }, () -> tsub);\n\n            other.observe(new Observer<U>() {\n\n                @Override\n                public void onNext(U args) {\n                    synchronized (guard) {\n                        rightQueue.offer(args);\n                    }\n                    stride.call();\n                }\n\n                @Override\n                public void onError(Throwable e) {\n                    synchronized (guard) {\n                        o.onError(e);\n                    }\n                }\n\n                @Override\n                public void onCompleted() {\n                    synchronized (guard) {\n                        rightDone.set(true);\n                    }\n                    stride.call();\n                }\n            }, () -> usub);\n        });\n    }\n```\n\nAnd a test method:\n\n``` java\nObsurvable.from(1).repeat().take(10000).zip(\nObsurvable.from(2).repeat().take(5), (a, b) -> a + b).take(2)\n.subscribe(System.out::println);\n```\n\nWhich again doesn't work with the reference repeat() as it should not call onCompleted once its upstream calls it because it will continue with subscribing to it again. Once fixed the above example works.\n\nThe oddity comes from where and what to call unsubscribe on; is this okay?\n\n``` java\nOperatorSubscription tsub = new OperatorSubscription();\nOperatorSubscription usub = new OperatorSubscription();\ns.add(tsub);\ns.add(usub);\n```\n\nAnd should I call `tsub.unsubscribe()` in the first observer.onCompleted() or `s.unsubscribe()`?\n",
        "Sorry for chiming in late. I'm a bit all over the place these days and some of the latest developments in the project slipped past me. I'll comment here w.r.t. #770 as well.\n\nI read the proposal and I like the suggested changes. One concern I have is that observers now have to extend an abstract class. In Java, it's quite intrusive if a library or a framework forces super classes on you, since it lacks multiple inheritance. We had a few components in our app that would behave like observers, but inherited from Android framework classes. This was quite nice, since they would provide the \"glue\" between the Android framework and our Rx based client code. We now have to convert these to observers first by delegating to an inner class, which makes their public API a bit awkward.\n\nMore problematic though is test friendliness. Maybe I'm missing something, but a very common recipe that we adopted in dozens of unit tests is the following:\n\n```\nObserver mockObserver = mock(Observer.class);\nobj.getObservable().subscribe(mockObserver);\nArgumentCaptor<Observer> onNextArgs = ArgumentCaptor.of(...)\nverify(mockObserver).onNext(onNextArgs.capture())\n// do expecations against onNextArgs\n```\n\nThis is not possible anymore, since `SafeObserver` into which all external observers get wrapped requires a valid subscription in a private final field, something that a mock object cannot provide.\n\nFWIW, Mockito @Spy's work, but it might not be wise to rely on spies. Maybe this could at least be mitigated by providing a non-final getter for the subscription which SafeObserver queries? At least then we'd be able to return a subscription for the mock that SafeObserver can accept.\n\nBen also pointed me to `TestObserver`, which can be used as a wrapper to query arguments. Neither solution strikes me as very elegant though.\n\nSorry I'll have to work more with the current code base to get a deeper impression, just wanted to throw this in as a first impression of sorts.\n",
        "Thanks for the write up Ben! I do agree this is very desirable.\n\nSo an Observer's role is an active one now (it can unsubscribe) rather than\njust a passive one (it receives notifications). That's fine, and Observer\nis still a good name (I'm less happy with the fact that Observer \"is a\"\nSubscription now, just in terms of naming, but anyway, I see how this makes\nsense implementation wise.)\n\nI usually name interfaces after the behavior they enable. If we reintroduce\nan interface that resembles what Observer used to be, I'd vote for\nsomething along the lines of `Notifiable` or `NotificationReceiver` to\nreflect that the interface captures the behavior of being able to receive\nRx notifications. OnObserve sounds like a single callback to an observe\nfunction so that might be misleading.\n\nJust my thoughts.\n",
        "This thread blessed me with the following insight:\n\nIf we look at the pull-oriented `Iterator`\n\n``` java\ninterface Iterator<T> {\n    boolean hasNext();\n    T next();\n}\n```\n\nand try to find its push-oriented dual, we get something like\n\n``` java\ninterface PushIterator<T> {\n    boolean wantsNext();\n    void onNext(T);\n    void onError(Throwable);\n    void onComplete();\n}\n```\n\nwhich is basically the same as @benjchristensen's\n\n``` java\npublic static abstract class Operator<T> implements Observer<T>, Subscription\n```\n\nwhere `wantsNext() = !isUnsubscribed()`.\n\nThat said, I like the `Operator` idea, but I think the naming can be improved: `Operator` is not general enough, I can also imagine use cases where I'd use an `Operator` instead of an `Observer`, without my `Operator` really being an operator in the sense that it transforms an Observable. Moreover, the name `Subscription` makes sense if it's returned by a call to `subscribe`, but if I create a `Subscription` myself and pass it to the `subscribe` method, this name is not very intuitive any more. I've not yet any good naming suggestion (I do not think `PushIterator` is a good name), but I'm thinking...\n",
        "In the current API, the fundamental thing you do with an observable object is _subscribe_ to it by passing an observer and getting a subscription back. You can invoke that behavior on `Observable` itself with `subscribe(Observer)`, or you can inject that behavior _into_ `Observable` with `Observable.create` and `OnSubscribeFunc.onSubscribe(Observer)`. Either way, the signature and the contract are exactly the same.\n\nIn the proposed new API, the fundamental thing you do is _observe_ by passing in both an observer and a subscription. You can invoke that behavior with `observe(Observer<T>, Func0<OperatorSubscription>)` or inject it with `Action2<Observer<T>, OperatorSubscription>.call`. Except that you've lost the symmetry of the current API! I would either go with `Action2<Observer<T>, Func0<OperatorSubscription>>` and `observe(Observer<T>, Func0<OperatorSubscription>)` or with `Action2<Observer<T>, OperatorSubscription>` and `observe(Observer<T>, OperatorSubscription)`. But don't mismatch the signatures. Otherwise, we'll find ourselves constantly writing closures to convert `OperatorSubscription` into `Func0<OperatorSubscription>`.\n"
    ],
    "2244": [],
    "748": [
        "The proper fix seems to be to immediately re-throw any VirtualMachineError by introducing a more specialized catch.\n",
        "Maybe it's better not to catch any of the `Error` [subclasses](http://docs.oracle.com/javase/7/docs/api/java/lang/Error.html)?\n",
        "But swallowing them is not good either, and then that will put the onus on the users to re-throw those exceptions, because there's really no way to handle them. If there are uncaught Errors won't the JVM shutdown even if there are non-daemon threads?\n\nInterestingly, Scala defines a NonFatal exception as:\n\n``` scala\nobject NonFatal {\n   def apply(t: Throwable): Boolean = t match {\n     case _: StackOverflowError => true // StackOverflowError ok even though it is a VirtualMachineError\n     case _: VirtualMachineError | _: ThreadDeath | _: InterruptedException | _: LinkageError | _: ControlThrowable | _: NotImplementedError => false\n     case _ => true\n   }\n}\n```\n\nwhich they use in their Futures library to check if it should be handed to the user for handling.\n",
        "Sorry, my point is that users may not be expecting to be handed such exception, and may swallow them themselves, by for example just logging them. The correct behaviour, IMHO, would be to let them bring down the JVM asap.\n",
        "That sounds good!\n",
        "Not surprised we ended up with something like this happening after migrating from `Exception` to `Throwable`: https://github.com/Netflix/RxJava/issues/296\n\nI agree @duarten that `SafeObserver` should catch and re-throw at least the `VirtualMachineError` class of errors: http://docs.oracle.com/javase/7/docs/api/java/lang/VirtualMachineError.html\n\nAny others we should include? `ThreadDeath` looks fun :-) The `LinkageError` exceptions also seem like we should never catch them: http://docs.oracle.com/javase/7/docs/api/java/lang/LinkageError.html\n",
        "In general not catching `Error` and `Throwable` is worse than catching them, as in an async system that means they are being thrown on some random thread in the background, won't call `onError` and thus can lock up a system since an `Observable` won't be terminated. \n\nSo it may only be the `StackOverflow` case that needs to be special-cased since it is a unique case of an infinite loop that means we won't ever successfully exit.\n",
        "It won't be swallowing them, they are or should all be passed via onError to the user provided Observer. StackOverflow is 'swallowed' because of a recursive loop. \n",
        "Background on `Throwable` being caught and emitted via `onError` can be seen here: https://github.com/Netflix/RxJava/issues/296\n\nThe Scala definition seems good. I think we should follow that same logic for defining something `Fatal` and immediately re-throwing it as opposed to passing via `onError`.\n",
        "Dealing with in pull request https://github.com/Netflix/RxJava/pull/839\n",
        "Should be fixed in https://github.com/Netflix/RxJava/pull/839\n",
        "Re-throwing the `Error` still has a problem when `Schedulers.io()` is involved. The `Error` will be swallowed by the `ExecutorService`.\n",
        "~~Just found a potential problem in this method:~~\n\n``` java\n    protected void _onError(Throwable e) {\n        try {\n            RxJavaPlugins.getInstance().getErrorHandler().handleError(e);\n            actual.onError(e);\n        } catch (Throwable e2) {\n            e2.printStackTrace();\n            if (e2 instanceof OnErrorNotImplementedException) {\n                /*\n                 * onError isn't implemented so throw\n                 * \n                 * https://github.com/Netflix/RxJava/issues/198\n                 * \n                 * Rx Design Guidelines 5.2\n                 * \n                 * \"when calling the Subscribe method that only has an onNext argument, the OnError behavior will be\n                 * to rethrow the exception on the thread that the message comes out from the observable sequence.\n                 * The OnCompleted behavior in this case is to do nothing.\"\n                 */\n                try {\n                    subscription.unsubscribe();\n                } catch (Throwable unsubscribeException) {\n                    RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);\n                    throw new RuntimeException(\"Observer.onError not implemented and error while unsubscribing.\", new CompositeException(Arrays.asList(e, unsubscribeException)));\n                }\n                throw (OnErrorNotImplementedException) e2;\n            } else {\n                /*\n                 * throw since the Rx contract is broken if onError failed\n                 * \n                 * https://github.com/Netflix/RxJava/issues/198\n                 */\n                RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);\n                try {\n                    subscription.unsubscribe();\n                } catch (Throwable unsubscribeException) {\n                    RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);\n                    throw new RuntimeException(\"Error occurred when trying to propagate error to Observer.onError and during unsubscription.\", new CompositeException(Arrays.asList(e, e2, unsubscribeException)));\n                }\n\n                throw new RuntimeException(\"Error occurred when trying to propagate error to Observer.onError\", new CompositeException(Arrays.asList(e, e2)));\n            }\n        }\n        // if we did not throw about we will unsubscribe here, if onError failed then unsubscribe happens in the catch\n        try {\n            subscription.unsubscribe();\n        } catch (RuntimeException unsubscribeException) {\n            RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);\n            throw unsubscribeException;\n        }\n    }\n```\n\n~~If `RxJavaPlugins.getInstance().getErrorHandler().handleError(e);` throws a Throwable, `RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);` also may throw one. So there may be a recursive loop. Is it necessary to make a distinction between Throwables from `RxJavaPlugins.getInstance().getErrorHandler().handleError(e);` and `actual.onError(e);`.~~\n\nSorry, I made a mistake. It's not a recursive loop.\n",
        "A thought to solve the swallowed StackOverflowError: can we call `actual.onError(e);` before `RxJavaPlugins.getInstance().getErrorHandler().handleError(e);`?\n",
        "Just dig deeply and found StackOverflowError is swallowed by SafeObserver.\nIn this example, there are 4 observers and wrapped by 4 SafeObservers. Here I call them so1, so2, so3, so4 in order. When the StackOverflowError is thrown, the thread call stack is something like:\n\n```\nso1.onNext\nso4.onNext\nso3.onNext\nso4.onNext\nso3.onNext\nso4.onNext\n...\n```\n\nNext,\n\n```\nso1.onError(throw a new StackOverflowError from \"RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);\")\nso1.onNext\nso4.onNext\nso3.onNext\nso4.onNext\nso3.onNext\nso4.onNext\n...\n```\n\nNext,\n\n```\nso4.onNext\nso3.onNext\nso4.onNext\nso3.onNext\nso4.onNext\n...\n```\n\nNext,\n\n```\nso4.onError(throw a new StackOverflowError from \"RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);\")\nso4.onNext\nso3.onNext\nso4.onNext\nso3.onNext\nso4.onNext\n...\n```\n\nNext,\n\n```\nso3.onNext\nso4(isFinished = true).onNext\nso3.onNext\nso4(isFinished = true).onNext\n...\n```\n\nNext,\n\n```\nso3.onError(throw a new StackOverflowError from \"RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);\")\nso3.onNext\nso4(isFinished = true).onNext\nso3(isFinished = true).onNext\nso4(isFinished = true).onNext\n...\n```\n\nNext,\n\n```\nso4(isFinished = true).onNext\nso3(isFinished = true).onNext\nso4(isFinished = true).onNext\n...\n```\n\nNext,\n\n```\nso4(isFinished = true).onError (StackOverflowError is swallowed here)\nso4(isFinished = true).onNext\nso3(isFinished = true).onNext\nso4(isFinished = true).onNext\n...\n```\n\nHere StackOverflowError is sent to so4.onError again, so4 will swallow it since isFinished is true.\n",
        "So if `RxJavaPlugins.getInstance().getErrorHandler().handleError(e);` always throw a StackOverflowError, `actual.onError(e);` will be skipped. No matter what we do in the catch clause(e.g, rethrow the StackOverflowError), it will be swallowed by SafeObserver in this example.\n"
    ],
    "3389": [],
    "568": [],
    "754": [
        "@mttkay On this subject, can you confirm that 0.17 (master branch) is working for you on Android. In particular the Android Scheduler was changed by me and I'm not setup to test on real devices.\n",
        "Yes, it has been merged. Thank you.\n",
        "@mttkay Thanks for doing that testing for me. I agree that you'll want further testing before production deployment, but the fact that it's good enough to pass right now means there are no major API signature or fatal issues. I am trying to wrap up a few last things so we can release in the next week give or take.\n",
        "@mttkay This code sample below is is taken from your blog post [Functional Reactive Programming on Android With RxJava](http://mttkay.github.io/blog/2013/08/25/functional-reactive-programming-on-android-with-rxjava/). The code here seems to imply that the `fromFragment` and `fromActivity` methods can be used with `.subscribeOn(Schedulers.newThread())`, but from the discussion above it sounds like that is not the intention. So I'm wondering if the blog post is just out of date? Please let me know if I'm misunderstanding something here.\n\n```\nclass MyFragment extends Fragment implements Observer<File> {\n  private Subscription subscription;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    subscription = AndroidObservables.fromFragment(this, downloadFileObservable())\n                          .subscribeOn(Schedulers.newThread())\n                          .subscribe(this);\n  }\n\n  private Observable<File> downloadFileObservable() { /* as above */ }\n\n  @Override\n  protected void onDestroy() {\n    subscription.unsubscribe();\n  }\n\n  public void onNext(File file) {\n    Toast.makeText(getActivity(),\n        \"Downloaded: \" + file.getAbsolutePath(),\n        Toast.LENGTH_SHORT)\n        .show();\n  }\n\n  public void onCompleted() {}\n\n  public void onError(Throwable error) {\n    Toast.makeText(getActivity(),\n        \"Download failed: \" + error.getMessage(),\n        Toast.LENGTH_SHORT)\n        .show();\n  }\n}\n```\n",
        "@mttkay Can you take a look at this PR #880? I'm worried that deferring the `unsubscribe` action may cause some problems. Maybe a better solution is:\n\n```\nif(isUIThread) {\n    do unsubscribe\n}\nelse {\n    AndroidSchedulers.mainThread().schedule( () -> do unsubscribe )\n}\n```\n",
        "I'll take this one. \n\nThe reason it's not working is we're doing a check for whether fromFragment is actually called from the main UI thread, and terminate the Observable if not. However, this check happens in the OnSubscribeFunc so will fail if the wrapped Observable is scheduled to run elsewhere. \n\nThe check should be moved to the invocation side, i.e. to the fromFragment helper. \n",
        "I'm waiting for 0.17 to land; it contains major changes to the Observable API. Will pick it up after.\n",
        "I'll have a look ASAP. Has the scheduler rewrite landed yet? It was still\nin a PR last time I checked\n",
        "So, I gave this some more thought and I'm not sure we should actually \"fix\" this. The reason is, `fromFragment` schedules notifications on the main UI thread. If you do not apply this to the final composition of your inner observables, then the result might not be what you might expect. If you have long running operations, they will now be propagated on the main UI thread, and this can congest the Android message queue. For an activity, since you unsubscribe in `onDestroy`, and since `onDestroy` is triggered by `finish`, and since `finish` will also post a message to the Android message queue, you might defer releasing the references the operator holds to the activity.\n\nAfter all, these helpers are meant for just one use case: to observe a fully constructed given sequence on the main thread while being able to unsubscribe such that no references to the activity or fragment will leak, plus some additional sanity checks for fragments. I guess that's why I put that guard in to begin with.\n\nThat being said, I think one problem is the naming. I would suggest the following:\n- rename `OperationObserveFromAndroidComponent` to `OperationObserveOnAndroidComponent`\n- rename `fromFragment` and `fromActivity` to `observeOnFragment` and `observeOnActivity`\n- remove the UI thread check from the operator and pull it up into these helpers; that way, your app will fail immediately with a sanity check rather than obscuring it and piping it through an Rx error handler, which you might no even have supplied\n\nThoughts on this?\n\n@benjchristensen \nI did some quick testing in a sample app that I use as a sandbox for experiments and it looks good. Unit tests also look good. Would like to further test in our application, but if there's pressure to release 0.17 earlier than later I'd almost say go ahead, I didn't see any smoke signals, and smaller issues can still be addressed in a minor version bump. Ship early ship often and so on :-)\n",
        "Sounds good\n",
        "Yes that code snippet I wrote before adding the `assertUiThread` guard. Like I said, I'll revisit this soon but want to see 0.17 land first.\n",
        "That PR already landed. Can we maybe agree that a PR gets at least 2 +1s before we merge it back? I'm not super happy with the changes in there. (see my comments in #880)\n",
        "This can be closed as it's fixed in `bindActivity` / `bindFragment`, which replace this.\n",
        "I also got this issue. When it'll be fixed?\n",
        "Thank for reply! You and your team made a bunch of great work, thanks man!\n"
    ],
    "756": [
        "Can you refactor that as a unit test with necessary assertions so it can go inside https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/test/java/rx/operators/OperationBufferTest.java ? \n",
        "Unit tests provided by @Acardiac in https://github.com/Netflix/RxJava/pull/761 demonstrating the issue:\n\n``` java\n@Test\n    public void bufferTimeSpanEmitAllItems() throws InterruptedException {\n\n        final int maxRounds = 100;\n        final int maxCount = 1000;\n\n        final int bufferTimeSpan = 42; // \u00b5s\n\n        int round = 0;\n        final AtomicInteger count = new AtomicInteger(0);\n        do {\n            ++round;\n            count.set(0);\n\n            Observable<List<Integer>> observable = Observable //\n                    .range(1, maxCount) //\n                    .buffer(bufferTimeSpan, TimeUnit.MICROSECONDS);\n\n            final CountDownLatch lock = new CountDownLatch(1);\n\n            observable.subscribe( // onNext\n                    new Action1<List<Integer>>() {\n                        @Override\n                        public void call(List<Integer> val) {\n                            count.addAndGet(val.size());\n                        }\n                    }, // onError\n                    new Action1<Throwable>() {\n                        @Override\n                        public void call(Throwable err) {\n                            lock.countDown();\n                        }\n                    }, // onComplete\n                    new Action0() {\n                        @Override\n                        public void call() {\n                            lock.countDown();\n                        }\n                    }\n            );\n            lock.await();\n        } while ((maxCount == count.get()) && (round < maxRounds));\n\n        assertEquals(maxCount, count.get());\n        assertEquals(maxRounds, round);\n    }\n\n    @Test\n    public void bufferCountEmitAllItems() throws InterruptedException {\n\n        final int maxRounds = 100;\n        final int maxCount = 1000;\n\n        final int bufferCount = 42;\n\n        int round = 0;\n        final AtomicInteger count = new AtomicInteger(0);\n        do {\n            ++round;\n            count.set(0);\n\n            Observable<List<Integer>> observable = Observable //\n                    .range(1, maxCount) //\n                    .buffer(bufferCount);\n\n            final CountDownLatch lock = new CountDownLatch(1);\n\n            observable.subscribe( // onNext\n                    new Action1<List<Integer>>() {\n                        @Override\n                        public void call(List<Integer> val) {\n                            count.addAndGet(val.size());\n                        }\n                    }, // onError\n                    new Action1<Throwable>() {\n                        @Override\n                        public void call(Throwable err) {\n                            lock.countDown();\n                        }\n                    }, // onComplete\n                    new Action0() {\n                        @Override\n                        public void call() {\n                            lock.countDown();\n                        }\n                    }\n            );\n            lock.await();\n        } while ((maxCount == count.get()) && (round < maxRounds));\n\n        assertEquals(maxCount, count.get());\n        assertEquals(maxRounds, round);\n    }\n```\n",
        "Both of those unit tests are passing for me (v0.18.3+) now whereas at least 1 of them was failing still as of 0.17.6.\n",
        "The rewritten exact buffer with count+timespan creates a new buffer if either count or timespan is reached. The inexact-timed version emits the full buffer but does not start a new window until the timespan ellapses. Do we need to ensure no values are left out?\n",
        "Ok, the marble diagram was updated, but it still does not work.\ngit SHA ID: 10f172d3fe25e853142aa39ace4cda37a433faed\n\n```\n    public static void main(final String[] args) throws InterruptedException {\n\n        final int maxRounds = 1000;\n        final int maxCount = 1000;\n        final Scheduler scheduler = Schedulers.computation();\n\n        int round = 0;\n        boolean pass = true;\n        final AtomicInteger count = new AtomicInteger(0);\n        do {\n            ++round;\n            count.set(0);\n            Observable<List<Integer>> observable = Observable.range(1, maxCount)\n                    .parallel(o -> o.<Integer>map(val -> Integer.parseInt(val.toString())), scheduler)\n                    .buffer(42, TimeUnit.MICROSECONDS, 42, scheduler)\n                    .filter(list -> !list.isEmpty());\n\n            final CountDownLatch lock = new CountDownLatch(1);\n\n            observable\n                    .subscribeOn(Schedulers.newThread())\n                    .subscribe( //\n                            val -> count.addAndGet(val.size()), //\n                            err -> {\n                                System.err.println(err.getMessage());\n                                lock.countDown();\n                            },\n                            lock::countDown\n                    );\n            lock.await();\n            pass = maxCount == count.get();\n            if (pass)\n                System.out.println(\"round: \" + round + \" passed\");\n        } while (pass && round < maxRounds);\n\n        System.out.println(\"in: \" + maxCount + \" out:\" + count.get() + \" round: \" + round);\n    }\n```\n\nOutput:\n\n> in: 1000 out:954 round: 1\n"
    ],
    "4830": [],
    "227": [],
    "1066": [],
    "6782": [],
    "6564": [],
    "1763": [],
    "5790": [],
    "4318": [],
    "771": [
        "If an onError is not implemented it should always be thrown.\n",
        "Dealing with in pull request https://github.com/Netflix/RxJava/pull/839\n",
        "Should be fixed in https://github.com/Netflix/RxJava/pull/839\n",
        "the behavior is inconsistent. that's the bug.\n\nDocument that the throwables are silently swallowed or thrown if there is no onError() \n\nErrors should probably always be thrown because I want my JVM to terminate before my JVM starts misbehaving and serving wrong data\n",
        "The problem here is that one of SafeObserver.onError is called twice: one is `RuntimeException`, the other is `OnErrorNotImplementedException`. A little to similar to #748 \n",
        "Not sure this is a bug. If an Observer throws an Exception in `onError`, what will happen? I think Rx does not guarantee that it always calls `onError` when an exception is thrown. It only guarantees that it at least calls `onError` once even if there are many exceptions. Do I misunderstand anything?\n",
        "@benjchristensen , Looks some operators do not handle `OnErrorNotImplementedException` correctly. Could you propose a guild about how to handle exception in RxJava? Now we have `RuntimeException except OnErrorNotImplementedException`, `Exception`, `Error` and `OnErrorNotImplementedException`.\n"
    ],
    "3299": [],
    "775": [
        "After playing with this last night I'm beginning to like the idea of changing `Observable` to a abstract class that extends `CompositeSubscription`.  The two argument creators on `Operator` seem awkward.  Does it make sense to allow the same `Subscription` was used to create two different `Operator`s with different `Observable`s or vice versa?  If `Observable` was the `Operator` you wouldn't need any of that.\n\nChanging from an interface to an abstract class would minimize the breakiness to just forcing everyone to switch from `implements` to `extends` for just named classes (anonymous inner classes wouldn't need to change).\n\nCome to think of it are there any other `Subscription` types?  Should we think of this as renaming `CompositeSubscription` to `Observer` and adding three abstract methods `onNext`,`onError`,`onCompleted`?\n",
        "I'm not sure if you were replying directly to my statement.  What about making `Observer` and abstract class where `unsubscribe()` in implemented for you?  In fact it should probably be final so that users would have to `add(Subscription)` to register a unsubscribe callback when needed.\n",
        "Apparently, I'm too late to the party (just seen the 0.17 release notes preview), but I wanted to say it anyway: the mathy-sciency-geeky `lift` thing sounds scary to me. I'm a programmer. I don't want to care about category theory. I want to chain method calls. Give me `chain` or `with` and I'm a happy guy. I could understand `andThen` or `compose`, but I get a little bit nervous with `bind`. With `lift`, I'm just put off. Thanks for listening to this complaint :-)\n",
        "Ben, first let me say that I very much appreciate your detailed explanation. I beg to differ, though. With RxJava, you are a bit in a special position, as you are bringing Rx to masses of Java programmers (which is a big deal itself), and you are also innovating on Rx at the same time (this `Operator`+`lift` thing is new and doesn't exist in other Rx implementations, AFAIK). This requires careful API design, of which naming things is an important part. Of course it's a highly subjective matter and in the end, it's your call; I just wanted to present a different opinion.\n\nWhat I've seen is that APIs in mainstream-ish languages tend to name things differently from the computer science \"upstreams\". `map` is a bit of an exception, as it kinda makes sense as a synonym for `transform` (transformation is a _mapping_ from source to target). Though it's called `transform` somewhere and even `select` elsewhere (in LINQ and Rx.NET/Rx.JS, where `map` is defined as an alias). And looking at monadic `bind`, that's called `flatMap` in Scala and most other mainstream-ish languages/libraries, LINQ and Rx.NET/Rx.JS call it `selectMany` (Rx defines a `flatMap` alias) and Dart uses `expand` (which is IMHO almost perfect). `fold` is often called `reduce` (or, like in Scala, `reduce` is a special case of `fold`) or even `aggregate`. Et cetera. So again, I believe it's common to diverge from functional/CS terminology in mainstream, and I guess that the reason is understandability.\n\nRegarding `lift`: looking at http://en.wikipedia.org/wiki/Lift_(mathematics), it looks like for practical purposes, `lift` is a function that is used in function composition. Eh... come on... What we have here is a chain of method calls that creates a chain of operators (which is a great name, BTW!). And what we are looking for is a name of a method that adds a previously-unknown operator to the chain. To me, `lift` doesn't come even close. It's more abstract, yes, but more abstract doesn't necessarily mean more good. For me, [part of] Rx's awesomeness lies in its accessibility to masses. Abstraction over abstraction is usually an opposite of that.\n",
        "Thanks @loganj for your input. I agree that \"it looks scary\" is a lousy argument. However, it looks scary enough to make me join this discussion. Don't underestimate the power of fear :-)\n\nAnyway, let me rephrase an argument I'm trying to make here. I argue that it's common for mainstream to have a different terminology from the math/computer science origins. I hope you will agree with me on that (we don't necessarily have to agree on whether it's a good thing or not). And I argue that we shouldn't deviate from the common practice.\n\nOne other example of importance of good naming. Dart's core library (dart:async) has a class called Stream, which is essentially Observable, and they have these two methods called `map` and `transform`. I like the name Stream, I like their map (it's the same as ours map), but I hate their transform. It's not an alias for map, it's this exact bind/lift/chain thing. TBH, I'd much rather have it called lift than transform :-)\n",
        "I'm not sure if I like having Observer implementing a Subscription. Now you can have the same Observer instance subscribed to more than one Observable if you so wish, and what you unsubscribe is the Observable <-> Observer association. I guess it would be okay if Observer were to become only an internal type. Also, there might be some strangeness with Subjects.\n",
        "> That is not a smart idea anyway, not sure if that would always guarantee that calls to OnNext are serialized if they get called from tow independ observables.\n\nAgreed. But it's additional flexibility that comes from separating those ideas. And the  `Subscription Subscribe(Observer)` signature would be misleading.\n\nAnother benefit is that now a subscription can be shared between a chain of observers, whereas otherwise each operator would have to cancel the parent observer, which in turn would cancel its parent, and so forth.\n",
        "Would it make sense for Observer to extend from CompositeSubscription, as it will have those semantics? \n\nBeing able to do Observer.create({ }).add(Observer.create{..}) still feels a bit weird. I wonder if this approach is just due to a limitation of Java's type system, as we can't express `Observer with Subscription` without explicitly introducing a new type.\n",
        "I too don't think making `Observer` extend `Subscription` is a good approach.\n\n#### 1) Conflates Responsibility\n\nWhen using an `Observable` it is rare that someone needs to concern themselves with the `Subscription` unless they are implementing an operator. By making `Observer` extend `Subscription` we would be forcing all users to always concern themselves with it.\n\nWhat does implementing `unsubscribe` even mean when just providing an `Observer` to an `Observable.subscribe(Observer)` when one just wants to subscribe to the data?\n\nThis is what we (users) would have to implement:\n\n``` java\n    new Observer<String>() {\n\n        @Override\n        public void onCompleted() {\n\n        }\n\n        @Override\n        public void onError(Throwable e) {\n\n        }\n\n        @Override\n        public void onNext(String args) {\n\n        }\n\n        public final void unsubscribe() {\n            // what to do here?\n        }\n\n    }\n```\n\nIn most cases I don't know what the `unsubscribe` method should do. It certainly wouldn't be implemented correctly.\n\nContrast this with the current `Observable.subscribe` which handles the subscription:\n\n``` java\npublic final Subscription subscribe(Observer<? super T> observer)  {\n   ... simplified ...\n   Operator<T> op = Operator.create(observer, new CompositeSubscription());\n   subscribe(op);\n   return op;\n}\n```\n\nThis is not logic that most users of Rx should ever have to worry about. \n\nI feel that `Observer` and `Subscription` should be kept separate and that we have a type such as the current `Operator` that combines them when needed.\n\n#### 2) Major Breaking Change\n\nThis would be a massive breaking change to anyone using RxJava. There is no mechanism for making it backwards compatible or providing a deprecation strategy.\n",
        "> I'm not sure if you were replying directly to my statement. \n\nI was replying to @headinthebox but it applies to yours as well (we posted within minutes of each other).\n\n> What about making Observer and abstract class where unsubscribe() in implemented for you?\n\nPerhaps, but it's still a pretty major breaking change. \n\nI can see some limited benefit in an `Observer` being able to call `unsubscribe`, but that is supported by the `subscribe(Operator)` interface and it's very rare that people are doing that in the final `Observer` since they generally should be using things like `take` and `takeUntil` for controlling when an `Observable` is unsubscribed.\n\nThe problem obviously is that we now have 2 ways of subscribing:\n\n``` java\npublic Subscription subscribe(Observer<? super T> observer)\n```\n\nand\n\n``` java\npublic void subscribe(Operator<? super T> o)\n```\n\nSo the real question is whether we are willing to have a massive breaking change where we eliminate all of the `subscribe` methods that return `Subscription`. And if so, why are they called `subscribe` anymore? Perhaps just `observe`?\n\nIf we were starting from scratch I wouldn't have the `Subscription subscribe(Observer)` methods, only `void observe(Observer)`\n",
        "Another problem I just considered ... `Subject` must extend from from `Observable` and implement `Observer`. Java doesn't support multiple-inheritance so we can't have `Observer` be an abstract class.\n\nThus, if we make `Observer extend Subscription` it can only be an interface which means everyone must implement `unsubscribe()` which we don't want.\n",
        "What exactly is wrong with the name `Operator` since everyone casually calls them \"operator\" anyways and the package they all live in is `rx.operators`?\n",
        "This is the signature that starts the `Observable`:\n\n``` java\nvoid subscribe(Observer&Subscription o)\n```\n\nThe `Subscription` specifically needs to be of type `CompositeSubscription` and is the seed for the entire sequence. \n\nAlso, it must have the `add` and `isUnsubscribed` methods:\n\n``` java\n    private final CompositeSubscription cs;\n\n    public final void add(Subscription s) {\n        cs.add(s);\n    }\n\n    public final void unsubscribe() {\n        cs.unsubscribe();\n    }\n\n    public final boolean isUnsubscribed() {\n        return cs.isUnsubscribed();\n    }\n```\n\nThus, a user can not just pass in an empty `unsubscribe`. They must pass in the exactly correct implementation, which is not at all what a user should have to do. \n\nThis is why `subscribe(Observer)` does this internally:\n\n``` java\nOperator op = Operator.create(observer, new CompositeSubscription());\nsubscribe(op)\n```\n\nIf `Observer` implements `Subscription` it would not change this, as `CompositeSubscription` is more than the `Subscription` interface.\n\nThus we would now have users implementing an `unsubscribe` method with no hook to the thing it should unsubscribe from.\n\n``` java\n        subscribe(new ObserverThatExtendsSubscription<String>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n                // receive data\n                if(s == null) {\n                     unsubscribe();\n                }\n            }\n\n            public void unsubscribe() {\n                // what do I do here?\n                // I want to do this =>\n                parentSubscription.unsubscribe();\n                // but there is no hook to a \"parentSubscription\"\n            }\n\n        }\n```\n\nThe problem is that if I'm implementing just an interface, there is no \"parentSubscription\" passed in that I can do something with. Thus, what would someone do inside the `unsubscribe` method they implement in their `Observer`? There is nothing they can do.\n\nThe only way I see to make this work is to replace the `Observer` interface with the abstract class `Operator`. This would indeed work as then it is a legit `Subscription` backed by a `CompositeSubscription`. \n\nBut it won't work with `Subject` as Java doesn't support multiple inheritance and `Subject` needs to extend both `Observable` and `Observer`.\n\nUsing this abstract class would work exactly like the current `Operator` class does, like this:\n\n``` java\n        subscribe(new OperatorOrObserver<String>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n                // receive data\n                if (s == null) {\n                    unsubscribe(); // this will now work\n                }\n            }\n\n        });\n```\n\nThis would work great, except for (1) it's a massive breaking change and (2) Subjects would all break.\n",
        "Talking with @headinthebox and @abersnaze we have discussed taking these changes all the way instead of part-way as done so far and doing the following:\n\nChange `interface Observer<T>` to an abstract class:\n\n``` java\n// Observer & Subscription \npublic abstract class Observer<T> implements Subscription {\n\n    public static create(onNext);\n    public static create(onNext, onError);\n    public static create(onNext, onError, onCompleted);\n\n    abstract void onNext(T);\n    abstract void onError(Throwable);\n    abstract void onCompleted();\n\n    final add(Subscription);\n    final unsubscribe();\n    final boolean isUnsubscribed();\n}\n```\n\nThis would effectively be the same class as is currently `Operator`.\n\nThen `Subject` would change to:\n\n``` java\nSubject<T> extends Observer<T> {\n\n    public Observable<T> toObservable();\n\n}\n```\n\nThis would allow `subscribe(Operator)` and `subscribe(Observer)` to collapse into one.\n\nThe benefit of this is:\n- no new types, just `Observer`\n- it forces subscribing \"the right way\" where an `Observer` can `unsubscribe` even on synchronous data\n\nRegarding the naming of `bind` we decided that `bind` is not the correct name as it is not exactly a `monadic bind`. It is in fact a `lift` or `transform`. We feel it is likely better to stick to proper CS or mathematical names for this function.\n\nThus it will be:\n\n``` java\n// lift \npublic <R> Observable<R> lift(final Func1<Observer<? super R>, Observer <? super T>> cf);\n... or ...\npublic <R> Observable<R> transform(final Func1< Observer <? super R>, Observer <? super T>> cf);\n```\n\nThis means version 0.17 will be a significant breaking release. We will leverage this to do all of the breaking changes here including removing deprecated methods and changing `Scheduler` to explicitly have Inner/Outer.\n",
        "> Would it make sense for Observer to extend from CompositeSubscription, as it will have those semantics?\n\nI don't think we want to expose the `clear` and `remove` methods that `CompositeSubscription` has. Also I consider the use of `CompositeSubscription` inside `Observer` an implementation detail. We could use something different if it makes sense so I don't want to commit long-term to `CompositeSubscription`.\n\n> Observer.create({ }).add(Observer.create{..})\n\nIt looks odd like that but there are actually use cases where I think that's more-or-less what we'll do (zip, groupBy, merge) albeit with a little more code involved and not directly chained like that.\n\nThere are always things we can do that shouldn't be done, such as this infinite loop with a `Subject`:\n\n``` java\nSubject<String, String> s = PublishSubject.create();\ns.subscribe(s);\n```\n\nThis fits into the \"don't do that\" category. Similar to `anInfiniteObservable.toList()`.\n\n> I wonder if this approach is just due to a limitation of Java's type system\n\nI don't know regarding this specific decision. We are limited in our implementation design though due to things such as lack of extension methods which drives us to use `abstract class` instead of `interface` for `Observable` and now `Observer` and then that affects `Subject` since we can't have multiple inheritance.\n",
        "Here is my branch working on this refactor as a preview of the changes: https://github.com/benjchristensen/RxJava/commits/lift-observer\n\nThe biggest issue I now have is figuring out how to make the unit tests work since `mock(Observer.class)` can no longer be used (the abstract method constructor is not invoked and thus the subscription state is null). Probably going to sleep on it ... enough carpal tunnel pain on tedious refactoring for one night.\n",
        "It definitely works on the previous signatures. I was arguing for leaving `Observer` as is but @headinthebox and @abersnaze convinced me to pursue changing `Observer`. The argument was for ...\n\n1) Having a signature that only dealt with `Observer` rather than `Observer` and some other `Subscription` implementation.\n\nIn other words, specifically avoiding methods like you show:\n\n``` java\n(Observer<T> obsurver, CompositeSubscription token)\n(Action2<Observer<T>, CompositeSubscription>)\n(Func2<Observer<U>, CompositeSubscription, Observer<T>>)\n```\n\nThat is where I started this journey at, and it works just fine as you say. Making `Observer` implement `Subscription` is taking it to the extreme possibly end state as I see it, allowing the signatures to be simpler like this:\n\n``` java\n(Observer<T> obsurver)\n(Action1<Observer<T>)\n(Func1<Observer<U>, Observer<T>>)\n```\n\n2) Elegance due to simpler signatures while it ends up \"doing the right thing\" in all cases rather than a user having to choose the right signature if they want unsubscribe support.\n\nIt's quite nice now that any `subscribe(Observer o)` can call `unsubscribe()` from within an `onNext()` method. Any user of Rx can do that with this `Observer implements Subscription` design whereas the code on master right now requires them choosing a different `subscribe` overload. \n\n> The \"when to unsubscribe\" remains largely the same.\n\nYes. This last set of changes is purely one of semantics and signature design. The change in functionality is already what was merged into master that added the `bind`/`lift` function. It basically was the discussion with @headinthebox that if we were starting from scratch with this `lift` model we wouldn't have combined `Observer` and `Subscription` so how about let's try and get it all refactored to that model now before we hit 1.0 instead of keeping signatures of \"old\" and \"new\".\n",
        ">  the mathy-sciency-geeky `lift` thing sounds scary to me\n\nI understand this sentiment. I'm torn on this one but there is a principle that pushed us towards using `lift`. We try hard not to re-invent new names for things when they already have names. Arbitrarily putting \"plain english\" names on top of things does not really help our industry as then we have multiple synonyms for the same concept or functionality and moving across languages and libraries is made more difficult than it should be.\n\nPart of the goal for Rx is to be consistent across platforms and languages which is why we work with @headinthebox and @mattpodwysocki to try and stay as close as we can. As we have pursued this path with `lift` and `Subscriber` @headinthebox has mediated across languages. \n\nAnother aspiration is to not try and redefine what operators and functions mean. If we are using capabilities from \"functional programming\" or \"math\" it is our perspective that it is better for us to learn and use the proper names for things so we can speak the same language. \n\nTake the `map` function for example: http://en.wikipedia.org/wiki/Map_(higher-order_function) That has become common in imperative languages even though the name originates from functional programming and is not plain english like \"transform\".\n\nLast, we have avoided adding new types as much as possible and let the functional interfaces stay as such in most places such as `Func1<Subscriber<? super R>, Subscriber<? super T>>`. As seen in https://github.com/Netflix/RxJava/issues/792 we tried very hard to not end up adding the new `Subscriber` type but the cost of not having it was worse than adding the type.\n\nAll that said ...\n\n> With lift, I'm just put off.\n\n... what specifically puts you off about this?\n\nDespite not liking the concept of alias methods, I'm not against having one if it is truly a blocker for users. Nor is the name `lift` locked in stone yet as we have not yet released nor was there much feedback (though @headinthebox has a very big say in this matter and I invite his input on this).\n",
        "@Ladicek Your make a strong argument and I'm willing to concede and make a change that benefits ease of adoption and comprehension. \n\nI'd like others to weigh in on this ... so /cc @samuelgruetter @jmhofer @zsxwing @mairbek @mattrjacobs @abersnaze @akarnokd @michaeldejong @mttkay @JakeWharton @loganj @adriancole\n\nThe proposal is to change from:\n\n``` java\npublic <R> Observable<R> lift(final Func1<Subscriber<? super R>, Subscriber<? super T>> lift)\n```\n\nto \n\n``` java\npublic <R> Observable<R> chain(final Func1<Subscriber<? super R>, Subscriber<? super T>> chain)\n```\n\nThe use is for custom operator chaining such as:\n\n``` java\nObservable<String> os = observable_of_integers.chain(TAKE_5).chain(MAP_INTEGER_TO_STRING);\n```\n\nMore information about the background on this can be found at https://github.com/Netflix/RxJava/issues/802 in summary form.\n",
        "Thanks for your input @loganj I appreciate you taking the time to weigh in and you make good points.\n",
        "> public <R> Observable<R> bind(final Func1<Operator<? super R>, Operator<? super T>> bind)\n\nThis is actually an instance of map since it takes (Operator<T>->Operator<S>) to (Observable<S>->Observable<T>), so \"lift\" would be the geek name. I like @akarnokd proposal to use leverage English to emphasize the fluent style. Using \"with\" sounds OK. \n",
        "> Func1<Operator<? super R>, Operator<? super T>>\n\nFor this one, I actually like keeping Func1; otherwise I'd have to unfold the synonym. That is because I remember\n\n```\n(Operator<S>->Operator<T>) ->(Observable<T>->Observable<T>)\n```\n\nThat is easier than\n\n```\n(XXX<S,T>) -> (Observable->Observable)\n```\n",
        "> public static interface OnSubscribe<T> extends Action1<Operator<? super T>>\n\nI like this one. With\n\n```\npublic static interface OnSubscribe<T> extends Function {\n        public void onSubscribe(Operator<? super T> op);        \n}\n```\n\nI need to mentally translate too much.\n",
        "> public abstract class Operator<T> implements Observer<T>, Subscription\n\nCan't we just make Observer implement Subscription? Less types is better.\n",
        "This would be my choice. As I said not sure the last one works.\n\n```\n// use `OnSubscribe` for the \"source\" function\npublic final static <T> Observable<T> create(final OnSubscribe<T> f);\n\n// use `with` for the name but leave the function\npublic <R> Observable<R> with(final Func1<Observer<? super R>, Observer<? super T>> cf);\n\n// Modify Observer\npublic abstract class Observer<T> implements  Subscription { .... }\n```\n",
        "What would be a good word for \"before\". Since \"bind\" is contravariant, it chains the transformations in reverse order. In my younger days when Algol 68 was all the rage if then else fi, while do od, case esac, I would propose neht, but I am sure that this would not fly in 2014 ;-)\n",
        "Putting the MI part aside, I a do not agree with \n`\n   What does implementing unsubscribe even mean when just providing an Observer to an         Observable.subscribe(Observer) when one just wants to subscribe to the data?\n`\nIt just means don't do anything. Just like now when you do an observable.create and return a subscription by subscribing to another observable. In .NET enumerator inherits IDisposable, and in most cases the IDisposable just does nothing. \n\nI see absolutely nothing wrong with that.\n\nNow most of the time people do not even pass observers directly but just the onNext, onError, or onCompleted functions to most of the time they won't even notice.\n",
        "> What exactly is wrong with the name Operator \n\nhttp://en.wikipedia.org/wiki/Operator_(programming)\n\nAn operator is typically a Function3.\n",
        "I would say, keep just one subscribe\n\n```\n Subscription Subscribe(Observer) \n```\n\nInstead of returning void there is no harm in returning the (augmented) subscription in both bases.\n",
        "> Now you can have the same Observer instance subscribed to more than one Observable\n\nThat is not a smart idea anyway, not sure if that would always guarantee that calls to OnNext are serialized if they get called from tow independ observables.\n",
        "> But it won't work with Subject as Java doesn't support multiple inheritance and \n> Subject needs to extend both Observable and Observer.\n\nOne way around that would be to make it have a toObservable method.\n",
        "yup.\n",
        "How about\n\n``` java\nObservable<T> o = Observable.<T>with(operatorA).with(operatorB).with(operatorC);\n```\n",
        "I don't quite understand why Observer and Subscription needs to be merged this way. I got pretty \"far\" with one of the previously suggested structures:\n\n``` java\nprivate final Action2<Observer<T>, CompositeSubscription> onSubscribe;\n    private Obsurvable(Action2<Observer<T>, CompositeSubscription> onSubscribe) {\n        this.onSubscribe = onSubscribe;\n    }\n    public Subscription subscribe(Observer<T> obsurver) {\n        CompositeSubscription token = new CompositeSubscription();\n        onSubscribe.call(obsurver, token);\n        return token;\n    }\n    public Subscription subscribe(Observer<T> obsurver, CompositeSubscription token) {\n        onSubscribe.call(obsurver, token);\n        return token;\n    }\n    public static <T> Obsurvable<T> create(Action2<Observer<T>, CompositeSubscription> onSubscribe) {\n        return new Obsurvable<>(onSubscribe);\n    }\n    public <U> Obsurvable<U> bind(Func2<Observer<U>, CompositeSubscription, Observer<T>> binder) {\n        return new Obsurvable<>((o, t) -> onSubscribe.call(binder.call(o, t), t));\n    }\n```\n\nThis way, both `create((u, k) -> { })` and `bind((u, k) -> t)` offers a composite subscription `k` which can be naturally closed over with an Observer (or that of the Operator if one really wants to reduce inner class clutter). The \"when to unsubscribe\" remains largely the same.\n",
        "I think this is settled.\n",
        "@benjchristensen Thanks for asking.  For what it's worth, I disagree with @Ladicek's reasoning, if not the proposed change.\n\nThere are a number of good criteria for choosing a function name, but whether or not it's \"scary\" because it has the whiff of math about it doesn't strike me as one of them.\n\n`lift` has the advantage of actually being a well-known name for that function.  People familiar with it will immediately know what it is and how to use it.  People who are not will have a body of knowledge to draw from if they go searching.\n\nThat said, `chain` is also a perfectly fine name, and you could always make `lift` an alias or just mention it in the javadoc.\n",
        "Note that `with` is a keyword in Scala, so in Scala we'll need a different name.\n"
    ],
    "519": [],
    "3795": [],
    "585": [],
    "1513": [],
    "4119": [],
    "5897": [],
    "3626": [],
    "2767": [],
    "5519": [],
    "789": [
        "Dealing with in pull request https://github.com/Netflix/RxJava/pull/839\n",
        "Should be fixed in https://github.com/Netflix/RxJava/pull/839\n",
        "Your Bang exception should be sent to `onError` method. But you do not pass the `onError` function. So an `OnErrorNotImplementedException` should be thrown. However, as the issue #771, the `OnErrorNotImplementedException` will be swallowed. Once the issue is fixed, you will observe `OnErrorNotImplementedException`.\n"
    ],
    "6629": [],
    "799": [
        "I've got a unit test that duplicates this behavior and a fix.  PR coming shortly\n",
        "After further review, I still don't have a complete handle on this.  The above Pull Request successfully limits the symptom of calling attachCallingThreadStack on a malformed exception, but the malformed exception is still getting created.  Since I can't eliminate the malformed exception (yet), I'm submitting a Pull Request that does not call attachCallingThreadStack.  This should eliminate the source of the malformed exception, with the loss of informative debugging of CompositeExceptions\n"
    ],
    "1683": [],
    "2578": [],
    "3045": [],
    "3893": [],
    "4101": [],
    "6751": [],
    "1902": [],
    "5406": [],
    "3175": [],
    "4124": [],
    "5258": [],
    "3401": [],
    "6149": [],
    "5957": [],
    "4560": [],
    "2765": [],
    "830": [
        "Yep it was certainly broken. Fixed in https://github.com/Netflix/RxJava/pull/833.\n\nThanks for the report.\n",
        "This unit test proved the issue and is now passing:\n\n``` java\n    public void testMultiTake() {\n        final AtomicInteger count = new AtomicInteger();\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> s) {\n                for (int i = 0; !s.isUnsubscribed(); i++) {\n                    System.out.println(\"Emit: \" + i);\n                    count.incrementAndGet();\n                    s.onNext(i);\n                }\n            }\n\n        }).take(100).take(1).toBlockingObservable().forEach(new Action1<Integer>() {\n\n            @Override\n            public void call(Integer t1) {\n                System.out.println(\"Receive: \" + t1);\n\n            }\n\n        });\n\n        assertEquals(1, count.get());\n    }\n```\n",
        "What about `map`? It doesn't decouple the subscription chain but just passes it through. \n\n``` java\n    public Subscriber<? super T> call(final Subscriber<? super R> o) {\n        return new Subscriber<T>(o) {\n```\n",
        "Yes, that's how it behaves, but not because `take` unsubscribes. It's because `onComplete` happens which then triggers `unsubscribe` from the bottom up to do cleanup inside the `SafeSubscriber`. That is by design.\n\n> Rx Design Guideline 4.3. Assume resources are cleaned up after an OnError or OnCompleted\n> message\n> Paragraph 4.1 states that no more messages should arrive after an OnError or OnCompleted message. This makes it possible to cleanup any resource used by the subscription the moment an OnError or OnCompleted arrives. Cleaning up resources immediately will make sure that any side-effect occurs in a predictable fashion. It also makes sure that the runtime can reclaim these resources.\n\nThus, adding the `Scheduler Subscription` to the `Subscriber` but wanting it to be run _after_ `onCompleted` won't work. You would need to remove the `add` so the scheduling 500ms in the future happens regardless of `onComplete` happening. \n\n(FYI that I won't be responding to this further tonight. It's past midnight and my brain is done.)\n",
        "> even if delay clearly violates the guideline above\n\nIt doesn't violate the guideline, `delay` is also delaying the `onComplete` thus the `unsubscribe` of `SafeSubscriber` is not triggered until after `delay` completes.\n\n> Surprisingly, this works:\n\nIt's not surprising since `delay` is an intermediate operator and thus does not have `SafeSubscriber` applied to it. This is yet another reason why `lift` is actually a clearer representation of what is happening \u2013 the intermediate operations are not subscribing, their functions are lifted into the `Observable` and executed in sequence when the `Observable` is subscribed to by the final `subscribe(Subscriber)`. \n\nThe only remaining oddity now that we have `lift` that doesn't cleanly match are nested `Observable` use cases where an `Operator` must subscribe to them (such as `groupBy`, `merge`, `zip`, `repeat`). We still rely on the `isInternalImplementation` check to prevent `SafeSubscriber` from wrapping those. That is the intent of this discussion: https://github.com/Netflix/RxJava/issues/676. \n\nDuring the `lift` prototyping I had considered a private or different method than `subscribe` for operators to use but it makes the public API awkward to do so. Likely we will end up with an `rx.operators.Subscriber/TrustedSubscriber/OperatorSubscriber` marker interface. \n\n> I think SafeSubscriber shouldn't force its actual subscriber (which is downstream) to unsubscribe.\n\nIf this were to be changed that would mean our current interpretation and implementation of guideline 4.3 is wrong. \n\nAs per the current interpretation the \"actual subscriber\" is not downstream. The `SafeSubscriber` is the absolute last thing in the sequence and this is because the `subscribe` step is the final in the chain, it's the exit point. \n\n``` java\nObservable.from(1).take(1).delay(v -> Observable.timer(500, TimeUnit.MILLISECONDS)).subscribe(s);\n```\n\nThe final `subscribe(s)` there is the end. That's why it returns `Subscription` (or could equally return `Void` now). Thus, once the `onComplete/onError` is invoked it is terminated and the full sequence is `unsubscribed`. \n\nIf `SafeSubscriber` did not `unsubscribe` the actual `Subscriber`, what would it `unsubscribe`? The intent is to cleanup all resources and the injected `Subscriber` is one of the resources that is now terminated and being cleaned up.\n\nConsidering this interpretation of guideline 4.3, what code changes would you make?\n\n@headinthebox Your input would be valuable to correct any misunderstandings or wrong implementations of the guidelines we have. The particular line of the guideline that influenced this implementation is:\n\n> The Rx contract for cleanup ensures that unsubscription will be called automatically once an OnError or OnCompleted message is sent.\n\nSpecifically we have interpreted that to mean when `onCompleted/onError` happens at the very end, not to intermediate steps (since that didn't make sense nor does it work).\n",
        "> will be unsubscribed from upstream\n\nIf an operator needs to decouple from this (such as `groupBy`) then it passes a different `Subscription` up the chain. \n\nThe `map` operator for example doesn't care. It just transforms data it receives. \n\n> As an external implementation, I can't use the Subscriber's add() method \n\nSure you can, within the lifecycle of that `Subscriber`. If you don't want to work within the lifecycle then you must decouple just like `groupBy` does. If you want to do something after `onComplete` you are by definition working outside the lifecycle of that `Subscriber`. Since you're at the end of the chain you would not have another `Subscription` to attach to and thus just fire-and-forget as in the example given above with a `Scheduler` inside `onNext`.\n\nIn short, the `subscribe` method is not the place to build a chaining operator, implementing the `lift` function is and then you decouple the `Subscription` as necessary. If you use `subscribe(Subscriber s)` then it is the end of the chain. \n",
        "What about OperatorMap?\n",
        "Consider this (running on head as of now):\n\n``` java\npublic static void main(String[] args) throws Exception {\n        AtomicInteger count = new AtomicInteger();\n        Observable.from(1, 2)\n                .map(v -> v * 2).take(1)\n                .subscribe(new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                add(Schedulers.newThread().schedule(\n                        i -> count.incrementAndGet(), 500, TimeUnit.MILLISECONDS\n                ));\n            }\n        });\n\n        Thread.sleep(1000);\n\n        System.out.println(count);\n    }\n```\n\nIt prints 0 for me, because once take unsubscribes from map, map (or take?) propagates that unsubscription downwards as well, disrupting the delayed schedule.\n",
        "Surprisingly, this works:\n\n``` java\nObservable.from(1).take(1).delay(v -> Observable.timer(500, TimeUnit.MILLISECONDS)).subscribe(s);\n```\n\neven if delay clearly violates the guideline above as take will call unsubscribe before delay even emits its value. It seems delay works only because its CompositeSubscription is disconnected from upstream so SafeSubscriber can't unsubscribe it before the actions were taken. \n\nSo if I rewrite delay, pending onNexts won't get run because SafeSubscriber between the two will cancel the schedule/subscriptions. I think SafeSubscriber shouldn't force its actual subscriber (which is downstream) to unsubscribe.\n",
        "Thanks. From implementation perspective, I have two concerns:\n- As an internal implementation, the Subscriber returned by my lifter method will be unsubscribed from upstream depending on what other operator is there: the case where basically there is a single CompositeSubscription shared between various lifting Subscribers.\n- As an external implementation, I can't use the Subscriber's add() method because SafeSubscriber will unsubscribe it even if I want different behavior or do something after onCompleted arrived from upstream (i.e., subscribe to another source).\n\nMost likely both situation can be bypassed via `nest()`.\n"
    ],
    "831": [
        "I really appreciate you finding the fix for this. \n"
    ],
    "4190": [],
    "493": [],
    "3104": [],
    "1694": [],
    "3297": [],
    "664": [],
    "844": [
        "That doesn't prevent people from using `observeOn` on `GroupedObservable`, such as for rendering to a UI.\n",
        "It's a tough trade-off ... non-determinism when using things that should not inject non-determism ... or risk of blocking.\n\nAnother possible solution is we could special case `observeOn` and `subscribeOn` instead to not return from `onNext` until they have subscribed. This would mean I need a hook inside the `Subscriber` type that tells me once a subscription is registered. I've looked at that as well, not sure which is better yet.\n",
        "Actually ... modifying `observeOn` and `subscribeOn` may not result in the deadlock risks so I'm going to test that implementation.\n",
        "I've submitted an attempt at a solution. The issue appears to be resolved but I don't completely like the solution nor do I trust it 100% yet. \n\nI need to sleep and think about it again tomorrow, but I'd appreciate a review and feedback, or a better solution from someone :-)\n",
        "There are trade-offs to solving this solution that probably are not worth it. \n\nI'd like people's opinion on whether we should figure out how to make these unit tests pass, or if it's acceptable for them not to:\n\n``` java\n    @Test\n    public void testGroupsWithNestedSubscribeOn() throws InterruptedException {\n        final ArrayList<String> results = new ArrayList<String>();\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                sub.onNext(2);\n                sub.onNext(1);\n                sub.onNext(2);\n                sub.onCompleted();\n            }\n\n        }).groupBy(new Func1<Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t) {\n                return t;\n            }\n\n        }).flatMap(new Func1<GroupedObservable<Integer, Integer>, Observable<String>>() {\n\n            @Override\n            public Observable<String> call(final GroupedObservable<Integer, Integer> group) {\n                return group.subscribeOn(Schedulers.newThread()).map(new Func1<Integer, String>() {\n\n                    @Override\n                    public String call(Integer t1) {\n                        System.out.println(\"Received: \" + t1 + \" on group : \" + group.getKey());\n                        return \"first groups: \" + t1;\n                    }\n\n                });\n            }\n\n        }).toBlockingObservable().forEach(new Action1<String>() {\n\n            @Override\n            public void call(String s) {\n                results.add(s);\n            }\n\n        });\n\n        System.out.println(\"Results: \" + results);\n        assertEquals(4, results.size());\n    }\n\n@Test\n    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes() throws InterruptedException {\n        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete\n        final ArrayList<String> results = new ArrayList<String>();\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                sub.onNext(2);\n                sub.onNext(1);\n                sub.onNext(2);\n                try {\n                    first.await();\n                } catch (InterruptedException e) {\n                    sub.onError(e);\n                    return;\n                }\n                sub.onNext(3);\n                sub.onNext(3);\n                sub.onCompleted();\n            }\n\n        }).groupBy(new Func1<Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t) {\n                return t;\n            }\n\n        }).flatMap(new Func1<GroupedObservable<Integer, Integer>, Observable<String>>() {\n\n            @Override\n            public Observable<String> call(final GroupedObservable<Integer, Integer> group) {\n                if (group.getKey() < 3) {\n                    return group.map(new Func1<Integer, String>() {\n\n                        @Override\n                        public String call(Integer t1) {\n                            return \"first groups: \" + t1;\n                        }\n\n                    })\n                            // must take(2) so an onCompleted + unsubscribe happens on these first 2 groups\n                            .take(2).doOnCompleted(new Action0() {\n\n                                @Override\n                                public void call() {\n                                    first.countDown();\n                                }\n\n                            });\n                } else {\n                    return group.subscribeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Func1<Integer, String>() {\n\n                        @Override\n                        public String call(Integer t1) {\n                            return \"last group: \" + t1;\n                        }\n\n                    });\n                }\n            }\n\n        }).toBlockingObservable().forEach(new Action1<String>() {\n\n            @Override\n            public void call(String s) {\n                results.add(s);\n            }\n\n        });\n\n        System.out.println(\"Results: \" + results);\n        assertEquals(6, results.size());\n    }\n```\n",
        "Here is a `subscribeOn` unit test that fails when `PublishSubject` is used if the `Scheduler` is slower than the time to emit `onNext`:\n\n``` java\n    @Test\n    public void testSubscribeOnPublishSubjectWithSlowScheduler() {\n        PublishSubject<Integer> ps = PublishSubject.create();\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        ps.subscribeOn(new SlowScheduler()).subscribe(ts);\n        ps.onNext(1);\n        ps.onNext(2);\n        ps.onCompleted();\n\n        ts.awaitTerminalEvent();\n        ts.assertReceivedOnNext(Arrays.asList(1, 2));\n    }\n```\n",
        "That's an interesting idea, especially since `PublishSubject` is definitely the culprit. \n\nWhat do you think about the lack of back pressure during that buffering period? \n\nThe reason is the same as `observeOn` being changed - not allowing buffer-bloat unless someone consciously chooses to do buffering or windowing. \n",
        "Thanks, I look forward to seeing your idea. I appreciate your back-and-forth on this with me.\n",
        "I believe so.\n",
        "As of 0.18 this problem shouldn\u2019t exist any longer as it will buffer until the subscriber arrives.\n\nIf the subscribe is occurring synchronously, then it is never a problem, only when the subscribe happens asynchronously (such as using `subscribeOn`).\n\nNow the choice of same or different scheduler is nuanced if using `subscribeOn`. Even if it\u2019s the same scheduler, it could schedule it to be done later, so the question is not about what scheduler it is, it is about whether there is a delay (async queueing/scheduling) of the subscribe occurring - which typically is going to happen when using a scheduler.\n\nYour example code would be fine, because the `obs subscribe` is happening synchronously. If however you changed it to the following it would be vulnerable:\n\n```\ngrpdObs subscribe { keyAndObs => \n  val (key,obs) = keyAndObs\n  obs subscribeOn(aScheduler) subscribe( someObserver )\n }\n```\n\nThe reason it becomes vulnerable is that the function returns and groupBy continues forward while the `obs subscribe` then happens sometime later. \n\nWe put a solution in place for this in https://github.com/Netflix/RxJava/pull/975. The downside is it makes it possible to have a memory leak if groups are skipped (purposefully not subscribed to), and we don\u2019t have a solution for that yet.\n\nWe decided that we'd rather avoid the non-deterministic data loss and risk a memory leak as that's easier to explain to people. At some point we'll need to solve the memory leak issue as well (such as emit an error, auto-unsubscribe or something similar if a group is emitted and not subscribed to).\n",
        "I opened https://github.com/Netflix/RxJava/issues/1280 to cover the side-effect of this solution.\n",
        "How about 1) and present a new operator to cover the parallel processing case directly.\n",
        "Maybe subscribeOn has to be smarter about its source (and not everyone else).\nI.e., if subscribeOn detects that the source is PublishSubject, It enters a buffering mode and once the time of the actual subscription has come, replay the buffered values and resume as a regular Observer would. This is is different from my previous hack where only the first observer would get the values. Here, everyone who is on a delayed subscription would eventually get the values from the time gap.\n",
        "Bounded buffering like in observeOn seems to be a workable solution, since the source needs to be blocked until the replay catches up anyway. I'm not sure, however, that my idea is deadlock-free or not. I'll do some experiments tomorrow.\n",
        "Is this settled?\n",
        "Hi Ben, I found your post after worrying that I could run into this situation in my own code. It is implied in your post, but I wanted to be entirely sure: Can this problem arise if you call subscribe on the _same_ scheduler? i.e. if I do \n\n```\ngrpdObs subscribe { keyAndObs => \n  val (key,obs) = keyAndObs\n  obs subscribe( someObserver )\n }\n```\n\nis it guaranteed that the notification that evokes the first (outer) subscribe will also be pushed to `someObserver`? in other words, that the notification on the inner subscription won't be skipped on `someObserver`?\nNow, the issue discussed here only applies when the inner subscription is done on another scheduler? correct?\n"
    ],
    "1185": [],
    "4603": [],
    "3315": [],
    "6408": [],
    "5000": [],
    "3239": [],
    "4963": [],
    "3627": [],
    "5357": [],
    "872": [
        "It's a good safety-net to keep, but it shouldn't do any of the error handling or unsubscribe logic of `SafeSubscriber`. Thanks for pointing it out. \n"
    ],
    "3488": [],
    "5682": [],
    "879": [
        "Fixed in master branch. Unit test merged to demonstrate: https://github.com/Netflix/RxJava/pull/960\n",
        "An issue is in OperationRetry L60 where the attempts is not per observer, but per source. But I'm not sure if this is the root cause.\n",
        "I believe that in the 0.16.1 code base the issue is with the use of a Composite  subscription that in a certain case calls unsubscribe when you try to add another sub to it. The code in master is a rework of operation retry and handles things with schedulers trampoline.\n"
    ],
    "4751": [],
    "533": [],
    "4943": [],
    "3660": [],
    "3924": [],
    "594": [],
    "4141": [],
    "1246": [],
    "817": [],
    "6030": [],
    "2630": [],
    "5778": [],
    "899": [
        "@zsxwing I came to a similar conclusion with my initial forked implementation - I actually ended up needing a slightly custom <code>isAttached</code> function. My nested fragment checks if its parent is visible in addition to itself because <code>FragmentTransaction.hide</code> does not cascade the hidden property.\n\n<code>OperatorAttach</code> does indeed seem a lot more generic than just this <code>rxjava-android</code> use case, I would like seeing it in the core myself.\n",
        "I want to ignore the events of the observable while the fragment is hidden. However, as I mentioned, actually whether or not it is hidden is not a property but a custom function. Therefore, as @zsxwing suggested, there would need to be a boolean function <code>isAttached</code> to determine the state.\n\nIn the <code>OperatorObserveFromAndroidComponent</code> there is already such functionality for the fragment state <code>isAdded</code>. Explicitly subscribing/unsubscribing according to a temporary state of the fragment is inconvenient because it requires subclassing and overriding methods.\n\nThe usage of the code in question would end up something like this:\n\n``` java\n    Observable<String> src = ...;\n    android.app.Fragment fragment = ...;\n\n    Observable<String> filteredSource =\n        OperatorObserveFromAndroidComponent.observeFromAndroidComponent(\n             src, fragment, new Func1<android.app.Fragment, Boolean>() {\n                 @Override\n                 public Boolean call(Fragment t1) {\n                     android.app.Fragment parent = t1.getParentFragment();\n                     return t1.isVisible() && parent != null && parent.isVisible();\n                 }\n             });\n\n    filteredSource.subscribe(new Action1<String>() {\n        @Override\n        public void call(String str) {\n            // Update the UI with the new data\n        });\n```\n",
        "Thanks @zsxwing for elaborating the use case. @mttkay I agree with the summary, it supports my need of having a more complex function to determine the state.\n\n@benjchristensen, as suggested, the source observable I have is sending events whenever it receives them from a push network API. Subscribing/Unsubscribing is done in fragment onCreate/onDestroy, but in between there are moments when the UI is hidden or otherwise inactive and the events can be discarded. The story of keeping the displayed data consistent over the application is of course a lot longer and we have an elaborate system for it, but in this case each notification was only shown in the UI for a short moment.\n",
        "@zsxwing, my guess is that `OperatorObserveFromAndroidComponent` assumes that `Fragment` can become active and inactive more than once, so `takeWhile` isn't appropriate here... I like your implementation more, though.\n",
        "This looks nice indeed!\n",
        "I don't fully understand the use case as I don't work with UIs or Android so can't help very much, but are you trying to unsubscribe from the event source when it is hidden, or just ignore them until it becomes visible?\n\nIn other words, must you keep listening to the events so as to know when it becomes visible again?\n",
        "If I understand correctly, if the visibility is not taken into account we receive events when hidden?\n\n```\ne: touch event [visible]\ne: touch event [visible]\ne: hidden [hidden]\ne: touch event [hidden]\ne: touch event [hidden]\ne: touch event [hidden]\ne: visible [visible]\ne: hidden [hidden]\ne: touch event [hidden]\ne: visible [visible]\ne: touch event [visible]\n```\n\nI imagine you want this?\n\n```\ne: touch event [visible]\ne: touch event [visible]\ne: touch event [visible]\ne: touch event [visible]\ne: hidden [hidden]\ne: visible [visible]\ne: touch event [visible]\ne: hidden [hidden]\ne: visible [visible]\ne: touch event [visible]\ne: touch event [visible]\ne: touch event [visible]\n```\n\n``` java\n    public static Observable<FragmentEvent> listenToFragment(final Fragment fragment) {\n        // simulate registering with the listener for a fragment\n        return Observable.create(new OnSubscribe<FragmentEvent>() {\n\n            @Override\n            public void call(final Subscriber<? super FragmentEvent> s) {\n                s.add(Schedulers.newThread().scheduleRecursive(new Action1<Recurse>() {\n\n                    boolean hidden = false;\n\n                    @Override\n                    public void call(Recurse r) {\n                        if (Math.random() < 0.2) {\n                            hidden = !hidden;\n                            if (hidden) {\n                                s.onNext(new FragmentEvent(fragment, \"hidden\"));\n                            } else {\n                                s.onNext(new FragmentEvent(fragment, \"visible\"));\n                            }\n                        } else {\n                            s.onNext(new FragmentEvent(fragment, \"touch event\"));\n                        }\n                        r.schedule(500, TimeUnit.MILLISECONDS);\n\n                    }\n\n                }));\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        listenToFragment(new Fragment(\"f1\")).toBlockingObservable().forEach(new Action1<FragmentEvent>() {\n\n            boolean visible = true;\n\n            @Override\n            public void call(FragmentEvent e) {\n                if (e.event.equals(\"hidden\")) {\n                    visible = false;\n                } else if (e.event.equals(\"visible\")) {\n                    visible = true;\n                }\n                System.out.println(\"e: \" + e.event + \" [\" + (visible ? \"visible\" : \"hidden\") + \"]\");\n            }\n\n        });\n    }\n```\n",
        "Should it actually subscribe/unsubscribe, or just ignore events?\n\nIf it keeps the subscription open here are two approaches, one with `filter` and one with `switchOnNext`:\n\n``` java\n\n    public static Observable<FragmentEvent> fragmentWithVisibilityCheckUsingSwitch(final Fragment fragment) {\n\n        return Observable.switchOnNext(listenToFragment(fragment).map(new Func1<FragmentEvent, Observable<FragmentEvent>>() {\n\n            boolean visible = true;\n\n            @Override\n            public Observable<FragmentEvent> call(FragmentEvent e) {\n                if (e.event.equals(\"hidden\")) {\n                    visible = false;\n                    return Observable.from(e); // could be Observable.never() to ignore\n                } else if (e.event.equals(\"visible\")) {\n                    visible = true;\n                    return Observable.from(e); // could be Observable.never() to ignore\n                } else {\n                    if (visible) {\n                        return Observable.from(e);\n                    } else {\n                        return Observable.never();\n                    }\n                }\n\n            }\n\n        }));\n    }\n\n    public static Observable<FragmentEvent> fragmentWithVisibilityCheckUsingFilter(final Fragment fragment) {\n\n        return listenToFragment(fragment).filter(new Func1<FragmentEvent, Boolean>() {\n\n            boolean visible = true;\n\n            @Override\n            public Boolean call(FragmentEvent e) {\n                if (e.event.equals(\"hidden\")) {\n                    visible = false;\n                    return true; // could be false to ignore\n                } else if (e.event.equals(\"visible\")) {\n                    visible = true;\n                    return true; // could be false to ignore\n                } else {\n                    if (visible) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n            }\n\n        });\n    }\n```\n\nOf course the function for determining whether it is visible can be injected as you state.\n\n> is it worth to put such OperatorAttach in the rxjava-core?\n\nWhat is different from the `attach` operator and using `filter`?\n",
        "> I'm trying to support that the Observable can always be subscribed by many Observers if the Activity is alive.\n\nThat suggests use of a `Subject`.\n\n>  cache and replay\n\nThis sounds correct, but what are the lifecycle implications as far as memory is concerned? The `cache()` operator is `replay()` with no limits so if an app is alive for hours or days it will keep retaining memory. Perhaps it is just the last _x_ events or minutes of events? \n\nCurious, why would there be events when an activity is not alive? or a fragment is not visible? And if there are events while hidden or not alive, should they be retained or just ignored completely?\n",
        "So basically, a callback to indicate if the fragment is active can improve the API. What's your opinion, @mttkay\n\n```\npublic static <T> Observable<T> from(Func0<Boolean> isActive, Observable<T> sourceObservable) \n```\n",
        "Here is my thought that will solve this issue and another issue I mentioned in https://github.com/Netflix/RxJava/pull/880#issuecomment-35367394\n\nEssentially, we need some api to make an Observable become inactive and keep silent (we can not use `Subscription` returned by `subscribe`)\n\nAt first, we need the following `OperatorAttach` to attach an Observable with a Func1<Boolean>.\n\n``` java\n\npublic final class OperatorAttach<T> implements Observable.OnSubscribe<T> {\n\n    private final Observable<T> source;\n    private final Func1<Notification<T>, Boolean> isAttached;\n\n    public OperatorAttach(Observable<T> source, final Subscription detach) {\n        this(source, new Func1<Notification<T>, Boolean>() {\n            @Override\n            public Boolean call(Notification<T> t1) {\n                return !detach.isUnsubscribed();\n            }\n        });\n    }\n\n    /**\n     * Generate a new Observable that mirrors the source but will swallow messages once isAttached return false.\n     * \n     * @param source\n     * @param isAttached\n     */\n    public OperatorAttach(Observable<T> source, Func1<Notification<T>, Boolean> isAttached) {\n        this.source = source;\n        this.isAttached = isAttached;\n    }\n\n    @Override\n    public void call(final Subscriber<? super T> subscriber) {\n        source.materialize().takeWhile(isAttached).subscribe(new Subscriber<Notification<T>>(subscriber) {\n            @Override\n            public void onCompleted() {\n                // ignore\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                // ignore\n            }\n\n            @Override\n            public void onNext(Notification<T> notification) {\n                if (notification.isOnNext()) {\n                    subscriber.onNext(notification.getValue());\n                } else if (notification.isOnError()) {\n                    subscriber.onError(notification.getThrowable());\n                } else {\n                    subscriber.onCompleted();\n                }\n            }\n        });\n    }\n\n}\n\n```\n\nThen, `observeFromAndroidComponent` is like this.\n\n``` java\n    public static <T> Observable<T> observeFromAndroidComponent(Observable<T> source,\n            android.app.Fragment fragment, final Func1<android.app.Fragment, Boolean> isAttached) {\n        final WeakReference<android.app.Fragment> fragmentRef;\n        Object memoryBarrier = new Object();\n        synchronized (memoryBarrier) { // force a memory barrier\n            fragmentRef = new WeakReference<android.app.Fragment>(fragment);\n        }\n        return Observable.create(new OperatorAttach<T>(source.observeOn(AndroidSchedulers.mainThread()),\n                new Func1<Notification<T>, Boolean>() {\n                    @Override\n                    public Boolean call(Notification<T> t1) {\n                        android.app.Fragment fragment = fragmentRef.get();\n                        return fragment != null && isAttached.call(fragment);\n                    }\n                }));\n    }\n\n    public static <T> Observable<T> observeFromAndroidComponent(Observable<T> source, Subscription detach) {\n        return Observable\n                .create(new OperatorAttach<T>(source.observeOn(AndroidSchedulers.mainThread()), detach));\n    }\n```\n\nUse case:\n- Activity\n\n``` java\npublic class TestActivity extends Activity {\n\n    private volatile Subscription detach;\n\n    private Observable<Integer> o;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        detach = new BooleanSubscription();\n        o = OperatorObserveFromAndroidComponent.observeFromAndroidComponent(\n                Observable.from(Arrays.asList(1, 2, 3)), detach);\n    }\n\n    @Override\n    protected void onDestroy() {\n        detach.unsubscribe();\n        super.onDestroy();\n    }\n\n}\n```\n- Fragment\n\n``` java\n        android.app.Fragment fragment = ...;\n        OperatorObserveFromAndroidComponent.observeFromAndroidComponent(\n                Observable.from(Arrays.asList(1, 2, 3)), fragment, new Func1<android.app.Fragment, Boolean>() {\n\n                    @Override\n                    public Boolean call(Fragment t1) {\n                        return t1.isAdded(); // or t1.isVisible();\n                    }\n\n                });\n```\n\n@mttkay, any idea?\n",
        "@mironov-nsk , I think creating two operator (one use `takeWhile`, one use `filter`) is better. That would meet your requirements.\n",
        "@benjchristensen is it worth to put such `OperatorAttach` in the rxjava-core? Does anyone need this operator out of `rxjava-android`?\n",
        " I just realized I did the same thing as `dematerialize`. The following codes are simpler.\n\n```\npublic static Observable<T> attach(Observable<T> source, Func1<Notification<T>, Boolean> isAttached) {\n    return source.materialize().takeWhile(isAttached).dematerialize();\n}\n\npublic static Observable<T> filter(Observable<T> source, Func1<Notification<T>, Boolean> isAttached) {\n    return source.materialize().filter(isAttached).dematerialize();\n}\n```\n",
        "> What is different from the attach operator and using filter?\n\nNow I think we don't need to add this operator. \n\nHere I think there are two use cases:\n- disable an Observable forever once the `isAttached` return false. For example, once an Activity is destroyed, we should disable the Observable forever.\n- disable an Observable once the `isAttached` return false, and enable an Observable once the `isAttached` return true. For example, according the `visible` property of the fragment to enable or disable the Observable .\n",
        "> Maybe I'm missing something, but doesn't the operator already do that? It will skip all notifications unless the fragment isAdded.\n\nI'm trying to support that the Observable can always be subscribed by many Observers if the Activity is alive.\n",
        "> Curious, why would there be events when an activity is not alive? or a fragment is not visible? And if there are events while hidden or not alive, should they be retained or just ignored completely?\n\nHere the events are not the UI events. It's some events emitted from a background thread. For example, a thread may read some information from a web server in a background thread, and send it to the UI thread. In the UI thread, the UI elements will be updated according to the information. \n\nIn Android, `AndroidSchedulers.mainThread()` is used to dispatch such events to the UI thread. There is an event queue for the UI thread. Sometimes, when the UI thread fetches an event (sent from a background thread) from the queue, maybe now the Activity is gone, or a fragment is not visible. So such events need to be dropped.\n\nI think it's a common pattern that creating an Observable that has the same life-cycle as the Activity.\n\nIn addition, I don't want to store a strong reference to an Activity or a Fragment in the Observable, or it will not be cleaned by GC. So I use a WeakReference.\n",
        "> That said, I'm still not sure what the problem is we're trying to solve or\n> how it's not accounted for already?\n- In current rxjava-android, I think the following behavior is wrong. This is the first problem I want to fix.\n\n``` java\npublic class TestActivity extends Activity {\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Observable<Integer> o = OperatorObserveFromAndroidComponent.observeFromAndroidComponent(\n                Observable.from(1), this);\n        // the following codes output \"1\"\n        o.subscribe(new Observer<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                e.printStackTrace();\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                System.out.println(t);\n            }\n        });\n        // the following codes output nothing\n        // this is a wrong behavior, should output \"1\"\n        o.subscribe(new Observer<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                e.printStackTrace();\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                System.out.println(t);\n            }\n        });\n    }\n}\n```\n- The second one is adding an API to let users can control when the Observable is active. For example, a Button, or a TextView can also be removed, like Fragment. So some Observable may be bind to a Button, or other UI component. I want to provide an API to keep the Observable silence once the UI component is removed. Since the use case may be very complex, I want to add one function like `isAttached` to let users determine when to keep the Observable silence.\n",
        "> The operator already takes care of this? If you unsubscribe in onDestroy,\n> it will drop all outstanding messages.\n\nHere I'm not sure which one is better, using `takeWhile` or `filter`? Maybe `filter` is better, since Activity or Fragment can come back to live.\n",
        "Yes, thanks for your summary.\n",
        "Maybe I'm missing something, but doesn't the operator already do that? It will skip all notifications unless the fragment `isAdded`.\n",
        "OK. From the the initial discussion it sounded as if this was merely about not emitting notifications if a fragment is in the background.\n\nAs for the use cases you mentioned:\n\n> disable an Observable forever once the isAttached return false. For example, once an Activity is destroyed, we should disable the Observable forever.\n\nWe can't do that; going through a configuration change means the fragment will get re-attached, and the observable must continue emitting. We use that pattern frequently with `cache` and `replay`\n\n> disable an Observable once the isAttached return false, and enable an Observable once the isAttached return true. For example, according the visible property of the fragment to enable or disable the Observable .\n\nWhat do you mean by disable? Could this also be solved by using cache and replay? You just keep emitting items into the cached observable, and once your fragment/activity is back to life, you re-subscribe\n",
        "The operator already takes care of this? If you unsubscribe in onDestroy,\nit will drop all outstanding messages.\n\nAndroid guarantees that no messages will be delivered between onDestroy and\nthe next call to onCreate, so there's only two cases:\n- the Activity doesn't come back to life, because the user backed out for\n  instance\n- the Activity goes through onCreate again because it was a configuration\n  change like change in rotation. In that case, use cache or replay and keep\n  the Observable alive, for instance using a fragment that retains instance\n  state\n\nThat said, I'm still not sure what the problem is we're trying to solve or\nhow it's not accounted for already?\n",
        "Just to summarize, what we want to fix is this yes:\n- make observables wrapped by fromFragment/fromActivity re-subscribable\n- pull out decision logic for when to silence the observable into a function that we pass in, rather than having it internal subclasses\n",
        "Not sure anymore where this should be best discussed, but will leave my comment here:\n\nWhile working on the samples project for rxjava-android, I actually discovered a few other issues that I was unaware of previously. Currently, `fromFragment` has to be used with much care and in a very specific, often non-obvious way to actually prevent memory leaks from happening. This is due to a combination of things:\n- resubscribing doesn't work, as already pointed out, so one cannot unsubscribe from a cached observable in `onDestroyView` before a config change, and resubscribe in `onViewCreated`. This means the fragment will leak. The only way to fix this right now is to always recreate the outer observable by calling `fromFragment` again immediately before subscribing to the cached inner sequence.\n- once the reference is cleared out, the operator doesn't unsubscribe its inner observer, so it will continue receiving messages even though they will all get discarded (this is rather easy to fix but I'm not sure if this has other repercussions, so I'm testing this right now)\n- because of the assertUiThread issue, the sequence can fail silently if no onError handler is specified (easy to fix too)\n\nAs said, I have fixes for the latter two issues, although they require more testing. However, I agree this operator demands rethinking on a bigger scale I guess. Especially the eager (and final) binding to the observed UI component in the constructor is a culprit here that needs to be addressed.\n",
        "So, I gave this some deeper thought over the weekend and came to the conclusion that I would prefer to deprecate and completely rewrite the current operator. Here is is what I came up with:\n\nhttps://gist.github.com/mttkay/0590979394aec6144a2e\n\nTL;DR:\n`OperatorWeakBinding` takes an arbitrary object reference, binds it weakly, binds any subscriber weakly, and only forwards notifications if both are alive. If not, it unsubscribes itself.\n\nBenefits:\n- does not leak context references, even when they're implicit through an inner class subscriber\n- no distinction anymore between fragments and activities; everything is considered a weak binding to some UI component (should therefore work with views, too)\n- it's not necessary to unsubscribe anymore, due to the use of weak references\n- it's not necessary anymore to test for fragment `isAdded`; since we re-subscribe in `onViewCreated`, we discard any old observer references after going through a config change\n- auto-unsubscribes when subscriber or bound reference are gone\n- can be used with `lift` since it's an `Operator` now\n\nDrawbacks:\n- expects to (and requires) the caller to manually `observeOn(mainThread()).cache`, since otherwise re-subscribing would restart the sequence (perhaps there are even use cases for this though?)\n\nI only tested this guy quickly in the samples project in both a fragment that retains instance state and an activity which retains the sequence by piping it through `onRetainNonConfigurationInstance` and I saw the activities being properly garbage collected.\n\nWhat's missing:\nWhat @tehmou suggested, i.e. making bindings more controllable by passing in a function. I was wondering though whether this should be its own operator, or implemented on top of this using existing operators? When I wrote the initial implementation of `OperatorObserveFromAndroidComponent` my goals were to make it simple to observe sequences on the main UI thread, without having to manage context references. That backfired a bit I guess, so I see this new implementation to be a superior implementation for this particular use case, not so much something that's more feature rich.\n\nCould you guys test this, review this and give me your thoughts? Thanks!\n",
        "I realized this can even be further simplified by providing new helpers through `AndroidObservable` similar to what `fromFragment` used to do:\n\n```\n    public static <T> Observable<T> bindActivity(final Activity activity, Observable<T> cachedSequence) {\n        return cachedSequence.observeOn(AndroidSchedulers.mainThread()).lift(new OperatorWeakBinding<T, Activity>(activity));\n    }\n\n    public static <T> Observable<T> bindFragment(final Fragment fragment, Observable<T> cachedSequence) {\n        return cachedSequence.observeOn(AndroidSchedulers.mainThread()).lift(new OperatorWeakBinding<T, Fragment>(fragment));\n    }\n```\n\nIn the Activity, you can then simplify to:\n\n```\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_reactive);\n\n        o = (Observable<String>) getLastNonConfigurationInstance();\n        if (o == null) {\n            o = SampleObservables.numberStrings(1, 100, 200).cache();\n        }\n\n        s = bindActivity(this, o).subscribe(new Observer());\n    }\n```\n\nand the Fragment even to:\n\n```\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        strings = bindFragment(this, SampleObservables.numberStrings(1, 100, 200).cache());\n    }\n```\n\nSo the only assumption that remains is that the source sequence must always be `cache`d; otherwise going through an unsubscribe/subscribe cycle during a rotation change would restart the sequence instead of continuing it. Any ideas how we could solve this? I guess the problem is that the underlying sequence must continue to receive notifications during the time the fragment/activity is detached.\n",
        "Just tested this in one of our apps' core screens, works nicely so far.\n\nI've prepared a branch against netflix/master that deprecates `ObserveFromAndroidComponent` and introduces this one. I'll push it and send a PR, so that you guys can test it out more easily.\n",
        "Maybe it's just getting late, but while working on the RxJava Android samples project, I made an observation: it seems the very problem all the Android operator implementations so far try to address, i.e. binding the sequence to the life time of a fragment or activity without leaking it, seems only to actually be an issue when using `cache` or `replay` (which, unfortunately, is a very common use case for us.)\n\nWhen using e.g. just `publish` to connect a fragment's inner observer (which in turn holds a reference to the fragment), then as long as I unsubscribe in `onDestroyView`, no context will leak, even for retained fragments. (Using publish is unfortunately not useful on Android, since the UI component might miss out on an emitted item while being detached.)\n\nI've opened an issue report here since I don't want to drive this issue further off topic, but would be glad if someone could either verify or falsify it:\nhttps://github.com/Netflix/RxJava/issues/939\n\nI'm just wondering whether the whole issue we're trying to fix might simply be down to a bug in `ReplaySubject`, in which case the whole discussion around `OperatorWeakBinding` would be null and void...\n",
        "So, I invested more time into this today, and the result is in the PR mentioned before:\nhttps://github.com/Netflix/RxJava/pull/938\n\nI have added support to bind a sequence via a predicate function that can be controlled from the outside. `bindActivity` now by default adds a predicate that tests for `isFinishing`, and `bindFragment` tests for `isAdded`, but this behaviour can overridden now by `lift`ing the operator manually using a custom predicate:\n\n```\nsource.lift(new OperatorWeakBinding(this, new Func1<Fragment, T> { ... })).subscribe(observer)\n```\n\nIn summary:\n\n```\nbindActivity(this, sourceSequence).subscribe(s)\n```\n\n==> keeps a weak reference to both `this` and `s`, schedules notifications on the main UI thread, and drops notifications and unsubscribes whenever:\n- `this` (the activity) is finishing\n- `this` is gone\n- `s` is gone\n\n```\nbindFragment(this, sourceSequence).subscribe(s)\n```\n\n==> same, just that the predicate test is for `isAdded`\n\n@zsxwing @tehmou let me know whether this addresses all the problems we discussed?\n",
        "/cc @samueltardieu \n",
        "I suggest to close this and in case of follow up problems / discussion to open a new issue.\n"
    ],
    "900": [
        "I merged the unit test into master branch and it is passing.\n",
        "Thank you by the way for submitting a unit test along with the report. That makes it far easier.\n"
    ],
    "4396": [],
    "1641": [],
    "1863": [],
    "950": [],
    "6217": [],
    "1774": [],
    "5834": [],
    "287": [],
    "4005": [],
    "929": [],
    "3778": [],
    "6870": [],
    "3817": [],
    "5106": [],
    "1555": [],
    "1393": [],
    "3365": [],
    "314": [],
    "1606": [],
    "943": [
        "I believe this requires migrating `OperationRetry` to `OperatorRetry` using the new `lift` approach so the synchronous `unsubscribe` is propagated. \n",
        "Thanks Ben, I look forward to trying out the next RC release.\nDave\n"
    ],
    "3704": [],
    "1910": [],
    "720": [],
    "5865": [],
    "4569": [],
    "1629": [],
    "701": [],
    "854": [],
    "159": [],
    "3316": [],
    "969": [
        "I understand that onError is called only once, I'm not trying to forward the exception to something else. What I want to do is be able to throw a RuntimeException to make the app terminate.\n",
        "I get why catching all errors from within the flow of RxJava (ie observables, functions etc..) to keep the monadic properties but once you reach the Observer the flow is consumed and this the point in the app where you can act on the events. The idea here is to fail fast in order to identify easily developer errors during the development phase. I was under the assumption after reading this closed issue https://github.com/Netflix/RxJava/issues/650 that RxJava should not be swallowing exceptions from within an Observer. \n",
        "I didn't realise that some operator might be using Observers internally, makes more sense now.\nI am handling the exceptions properly, I just wanted to figure out a way to make unexpected failures resulting from developer errors to be easier to spot. I suppose I'll rely on visual indication and Logs for now.\n",
        "This is an odd use case ... and it skips over the `Exceptions.throwIfFatal()` line in `subscribe` and swallows the error: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L7094\n\nNot ideal at all.\n\nI think we may need to make `SafeSubscriber` use an `Exception` other than `RuntimeException` that is considered \"fatal\" so we don't end up in loops where `observer.onError` throws and then `subscribe` tries to re-send it right back to `observer.onError` again only to get ignored by `SafeSubscriber` that allows only a single terminal state.\n\nSee here for the `RuntimeException` that should get thrown all the way up: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/observers/SafeSubscriber.java#L171\n",
        "Generally errors should be emitted to onError otherwise systems can end up hanging and/or leak resources because they never receive a terminal event (onComplete/onError) and therefore never releases user requests, unsubscribed for cleanup, etc. Only fatal errors are thrown, and the OnErrorNotImplementedException after the terminal event ensures everything receives an unsubscribe. \n\nBen Christensen\n310.782.5511  @benjchristensen\n\n> On Jun 24, 2014, at 2:00 PM, Matthias K\u00e4ppler notifications@github.com wrote:\n> \n> Actually, a much simpler way to solve this would be to change throwIfFatal to always rethrow Errors, and not just the 4 specific ones it checks for? That way we could wrap exceptions in AssertionError and have it terminate early.\n> \n> Was there any particular reason why only 4 kinds of errors are rethrown from throwIfFatal? There's other kinds of errors like NoClassDefFoundError that should probably be considered fatal as well. I always assumed anything derived from Error is considered fatal anyway.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
        "The definition of fatal exceptions can definitely be changed. Here is what we will want to change: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/Exceptions.java#L82\n",
        "Perhaps. Should AssertionError be considered fatal though? When we say fatal here it really does mean the app may die it need to be killed as user requests may be hung if this happens. \n",
        "The `onError` hook is only for logging and insights, not for decoration or throwing: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/plugins/RxJavaErrorHandler.java#L37 The plugin was specifically created to help identify when there is bad code swallowing errors in production environments and other similar diagnostic use cases. It was never intended for application logic. That's why it doesn't return anything and has a strict contract to never throw.\n\nIf `ExecutorScheduler` is swallowing fatal errors (primarily exceptions thrown from `onError`) then it is a bug.\n\nThe contract for error handling in Rx is:\n\n1) All errors thrown by user provided functions or notifications to `onNext` and `onCompleted` must be passed to `onError` unless they are considered \"fatal\" (primarily to prevent OutOfMemory and StackoverFlow scenarios).\n2) If `onError` itself throws an exception there is no choice but to consider it fatal.\n\nA try/catch/finally isn't reliable when multiple threads are involved, this is why it's so important to route errors to `onError` and only throw if we have no other choice (i.e. `onError` itself throws) due to the non-determinism of what thread it will be thrown on and what resources it will leave hanging.\n\nCan we step back and clearly define the use case trying to be solved? I want to understand if it's the actual Rx contract above that is in question, or just a bug in an operator or choice of \"fatal\" exceptions that needs to be fixed.\n",
        "What does your onError handler do with the exception when it receives it?\n",
        "Since your final `onError` throws, it would result in it being treated as \"fatal\" and allowed to throw all the way up the stack. \n\nOn the other hand, if a developer doesn't implement `onError`, you'd just get everything thrown wrapped in an `OnErrorNotImplementedException`, which seems to also results in behavior you'd like.\n\nConsidering these two possibilities, what about this current state isn't working for you? \n",
        "> Plus, we need to make sure that this logic is executed in all internal classes the catch Throwable. Otherwise we'll end up swallowing errors that shouldn't be swallowed.\n\nDefinitely.\n\n> let the developer decide what fatal means \n\nIf the user provided `Subscriber.onError` throws an exception, it will always be treated as fatal (since `onError` itself failed). Due to this I don't see why anything further is needed. The only real reason `Exceptions.throwIfFatal` really exists is to avoid recursive loops and stack overflow. Otherwise everything gets routed to `onError` or `onError` itself throws and the exception is allowed to throw all the way up the stack.\n\n> I believe part of the problem is ExecutorScheduler\n\nAgreed. If scheduled work fails it has no choice but to throw an exception wherever it is, such as here: \nhttps://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/schedulers/ScheduledAction.java#L41\n\nWork being scheduled should never throw, but instead propagate to `onError`, but if the action being scheduled doesn't correctly handled that, the `Scheduler` itself does not have a reference to a `Subscriber` and thus can do nothing but throw. No operator should ever behave that way though.\n",
        "I'm saying that the operators that do scheduling should do the error handling. For example, I see that `observeOn` doesn't catch and propagate to `onError`: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/operators/OperatorObserveOn.java#L139\n\nIf the operator doesn't do it, a user has no hope of managing errors.\n",
        "According to Rx contract, `onError` will be called only once. So you need to handle the exception in `onError` by yourself.\n",
        "RxJava will catch `Exception` and most `Error`. You can not propagate `Exception` out of RxJava. I'm curious why you have such requirement. \n",
        "#650 is out of date. The `Observer` is not only used by users, but also by RxJava. `Observer` is also used to build operators. In my opinion, `Observable` is often asynchronous. It means `Observer` often runs in other thread instead of the main thread. Even if RxJava throws the RuntimeException, it only crash the thread. That's still hard to debug. I suppose that forcing users to handle the exception is a better idea.\n",
        "Despite you are using 1.x `create`, the code signals the exception correctly. I'd assume there is something in Hystrix that suppresses your error and I suggest asking on their page or better yet on Stackoverflow.",
        "Sorry for reviving an old discussion.\n\nWe also run into the same issue, and the change that went in does not really help us. Rx contract or not, I think I agree with @Dorvaryn that certain errors should simply terminate the app, since they can signal developer error rather than anticipated runtime errors.\n\nA good example are precondition checks and assertions. Guava for instance throws IllegalArgumentException when a precondition failed. This will throw during an `onNext` call. Why would I want to handle this within the Rx call chain? As a developer I violated a method contract and should be informed immediately--by seeing the app crash. The same goes for null pointers.\n\nThe way this is dealt with right now:\n- a static `Exceptions.throwIfFatal` method which cannot be overridden, and which does not account for above mentioned cases\n- a plugin system for errors, but which is safe guarded against from re-throwing errors, so this is not an option either\n\nWhile I do see your points, I think there is definitely a case to be made for failing early, outside the Rx contract (since you _want_ to terminate the app, why would breaking the Rx contract matter anyway?) It would go a long way to make Rx based apps easier to debug, since more often than not, errors you expect to fail the app simply disappear in the safe guards applied by SafeSubscriber.\n",
        "Actually, a much simpler way to solve this would be to change `throwIfFatal` to always rethrow `Error`s, and not just the 4 specific ones it checks for? That way we could wrap e.g. argument checks in `AssertionError` and have it terminate early.\n\nWas there any particular reason why only 4 kinds of errors are rethrown from `throwIfFatal`? There's other kinds of errors like `NoClassDefFoundError` that should probably be considered fatal as well. I always assumed anything derived from `Error` is considered fatal anyway.\n",
        "Sure, but why is something like `NoClassDefFound` not considered fatal? According to Java's `Error` doc, all subclasses are considered fatal.\n",
        "Would you be okay with replacing these 4 checks with `instanceof Error`?\nI'm not sure if this will have a larger impact, but I feel that's the right\nthing to do here\n",
        "In our case, I feel an assertion failure should kill the app, but I see\nthat in different environments there might be different requirements around\nsuch behavior. I was actually wondering if there is even a need to split up\n`Exceptions.throwIfFatal` and the global error handler registered via\n`RxJavaPlugins`. If we weaken the requirement of the global onError hook to\nrethrow if desired, the logic from `throwIfFatal` could simply live in a\ndefault onError hook, and would remain overridable by clients.\n\nIt also looks like a potential source of bugs due to duplication: maybe\nit's by design, but the recently rewritten `ExecutorScheduler` does not\ninvoke `throwIfFatal` if it catches an error, only the global onError hook;\nthis makes for one half of the problem we're having, since it wraps all job\nexecutions in a try/catch/finally block, so even if throwIfFatal would\nrethrow say a StackOverflowError, the job would silently shut down and no\none ever sees that error. I guess it makes sense in terms of resilience,\nbut makes debugging hard, since all fatal errors disappear in a void.\n",
        "I see, that makes sense.\n\nThe use case we're trying to address is discovering developer failure\nearly. In this specific instance we had a precondition check fail on a\nmethod argument, which was invoked inside an RxJava call chain. The\nprecondition check fails with IllegalArgumentException, which is a\nRuntimeException, which in turn is not considered fatal by RxJava so gets\ncaught in SafeSubscriber's safety net (again, there is no reasonable way to\nrecover from that error in the app.)\n\nThe result is that our app continues to run in a broken or undefined state,\nsince we continue execution after a precondition was violated. This is hard\nto debug and not obvious to the programmer. What we want is to crash the\napp.\n",
        "It checks it for its type and then decides if it should rethrow or report\nsilently into our crash logging service. We rethrow all Errors and all\nRuntimeExceptions. Checked exceptions are either logged (depends on the\ntype as well, we don't log IOExceptions for instance) or are simply\nignored, because they are expected to be handled by the subscriber in a way\nappropriate to the context of the subscriber\n",
        "I believe part of the problem is `ExecutorScheduler`. Its `run` method is:\n\n```\n        @Override\n        public void run() {\n            if (isUnsubscribed()) {\n                return;\n            }\n            try {\n                actual.call();\n            } catch (Throwable t) {\n                RxJavaPlugins.getInstance().getErrorHandler().handleError(t);\n            } finally {\n                unsubscribe();\n            }\n        }\n```\n\nThat is, it catches all errors and loops them through the global onError hook, which is not allowed to throw. So even if `SafeSubscriber` rethrows, it would just end up being swallowed again.\n",
        "That said, just from my perspective, what we could do is to let the developer decide what fatal means when an exception is caught. This could be as simple as providing a predicate `isFatal` (e.g. through the plugin APIs) that SafeSubscriber calls instead of the static `Exceptions.throwIfFatal` method, and would rethrow on true.\n\nPlus, we need to make sure that this logic is executed in all internal classes the catch Throwable. Otherwise we'll end up swallowing errors that shouldn't be swallowed.\n",
        "> Work being scheduled should never throw, but instead propagate to onError, but if the action being scheduled doesn't correctly handled that, the Scheduler itself does not have a reference to a Subscriber and thus can do nothing but throw. No operator should ever behave that way though.\n\nMakes sense. I'm not sure I understand what you're suggesting though. All our observables are scheduled, so whatever the subscriber does won't matter, as it will end up in this catch clause. Does that mean there is no way for us to achieve what I outlined?\n",
        "Sorry for reviving an old discussion again, but can someone help me?\r\n> If the user provided Subscriber.onError throws an exception, it will always be treated as fatal (since onError itself failed).\r\n\r\n Is this still viable for RxJava 2?",
        "Hi ,My use case is to propagate the error from Observable to subscriber,but the same error is not visible to onError() method of subscriber ,instead it always shows\r\nonError Must subsriber is called --- com.netflix.hystrix.exception.HystrixRuntimeException: CommandSR timed-out and no fallback available.\r\nBelow goes my code from where i throw the real exception\r\n```java\r\n @Override\r\n    protected Observable<String> construct() {\r\n    \tSystem.out.println(\"I am in construct of \"+name+\"::thread name: \"+Thread.currentThread().getName());\r\n        return Observable.create(new Observable.OnSubscribe<String>() {\r\n        \t\r\n            @Override\r\n            public void call(Subscriber<? super String> observer) {\r\n                try {\r\n                    if (!observer.isUnsubscribed()) {\r\n                    \tString response = HTTPClientHelper.searchSR(\"https://stg-step.am.health.ge.com/service/v2/service-event11/search/SHOWROOM24\", \"gJc1Ts8PWBrCmi5PcTtZJTk6JmyS\", \"212469169\");\r\n                        // a real example would do work like a network call here\r\n                      \r\n                    \tobserver.onNext(response + \"!\");\r\n                        observer.onCompleted();\r\n                        \r\n                    }\r\n                } catch (Exception e) {\r\n                \tSystem.out.println(\"Exception+++++++++++++++\"+e.getMessage());\r\n                    observer.onError(new RuntimeException(\"graceful onError\"));\r\n                }\r\n            }\r\n         } );\r\n```",
        "ok sure thanks"
    ],
    "410": [],
    "4102": [],
    "6171": [],
    "979": [
        "cc @mttkay\n",
        "On the top of my head: couldn't we find a way to give the Android component back to the subscriber?\n\nSomething like\n\n``` scala\n   def bindActivity[T <: Activity, U](activity: T, sourceObservable: Observable[U]): Observable[(T, U)]\n```\n\nThis way, the subscriber will get a reference to the activity with every item and doesn't need to keep strong references to it.\n\nOf course, it means that the user needs to be cautious in not closing over the activity through other references, but it can do so by declaring the subscriber in the companion object rather than in the activity itself if they are not sure to do it correctly.\n",
        "(forget my remark about the companion object, I was thinking in Scala term, I meant \"as a static method\" in Java :-)\n",
        "Exactly. Closing it.\n",
        "@samueltardieu Is this still an issue? I believe that as of #1021 that was merged this should no longer be happening.\n",
        "I see what you mean. The rationale behind using a weak reference to the subscriber is that in most of the cases, it'll be an inner class of the activity (in your case, too.) If we would hold a strong reference to the observer, we would hold a strong reference to the Activity too, so for the life time of the sequence your Activity would immediately leak when attempting to destroy it.\n\nThat said, it's not as simple as turning a weak reference into a strong reference, but I totally see your point. I'm open for suggestions here, as I've tried many approaches to solve these issues and we keep finding (edge) cases where the solutions collapse.\n"
    ],
    "3163": [],
    "4637": [],
    "1788": [],
    "3049": [],
    "6579": [],
    "483": [],
    "992": [
        "/cc @mttkay @jmhofer @zsxwing \n",
        "That's great news. If I provide a jar built with Java 7 can you test linking to a jar?\n",
        "I have no other obvious place to place a binary so am using Dropbox: https://www.dropbox.com/s/fkt7vlox946pig0/rxjava-core-0.17.3-SNAPSHOT.jar\n\nThis file was built using OpenJDK 1.7.0_45 with @SafeVarargs\nThe branch this was built from is at https://github.com/Netflix/RxJava/pull/994\n",
        "Thanks for playing with that ... I'll spend some more time on this. It's not okay to have version 51 if people expect version 50. \n\nWhat's the roadmap for Android dev being moved onto version 51 (JDK 7) and no longer requiring version 50 (JDK 6)?\n",
        "Closing out ... failed experiment, and I found `@VarArgs` don't actually solve the problem anyways! https://github.com/Netflix/RxJava/issues/686#issuecomment-38851070\n",
        "> I'm on Mac however and getting a version of JDK 7 is not proving easy.\n\nWhat do you mean by this? It's available via Oracle: http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html -> http://download.oracle.com/otn-pub/java/jdk/7u51-b13/jdk-7u51-macosx-x64.dmg\n",
        "Oh how fun. \n",
        "Understood. My intention is for RxJava 1.0 to remain on Java 6. This `SafeVarargs` thing is not important enough to move to Java 7 even if it worked, but it ends up that it doesn't actually solve the problem anyways because of nested generics.\n",
        "Did anyone try to build their Android project with JDK 6? We're still using JDK 6. Unfortunately my team is on a tight release schedule right now so I don't have time to look into this before next week.\n\nGenerally though, this will trigger a compile time check yes? If that's the case, the only problem I can think of off the top of my head is that the dexer might be unable to resolve the annotation when processing the RxJava JAR. Keep in mind that the dex file contains everything, including direct and transitive dependencies.\n",
        "I have JDK 6 and 7 installed on my Mac back to back (I occasionally switch\nvia JAVA_HOME). As Dylan pointed out, Java 7 is supported with the latest\nAndroid build tools (rev 19+), and since IIRC it's byte code compliant with\nJava 6 with the exception of try-with-resources a compiled build should\nwork on all Android versions.\n\nThe problem I guess is one of adoption. At SoundCloud we're still stuck\nwith Java 6 because a testing library we use (Great Expectations) refuses\nto compile under Java 7. I admit I haven't researched this further, as it\nwasn't a priority for us, but I imagine others either have similar problems\nor more likely, simply don't see enough value in Java 7 to bump their tool\nchain.\n",
        "Looks like it was added in API 19 (\nhttp://developer.android.com/reference/java/lang/SafeVarargs.html). It\nseems to just be a compile time annotation. I'll download SDK 19 and test\nit.\n\nOn 27 March 2014 09:41, Ben Christensen notifications@github.com wrote:\n\n> /cc @mttkay https://github.com/mttkay @jmhoferhttps://github.com/jmhofer\n> @zsxwing https://github.com/zsxwing\n> \n> ## \n> \n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/992#issuecomment-38752214\n> .\n",
        "It seems to work, even when running on an ICS (api 14) device, though the\ntarget api must be set to 19 for it to be imported. It is defined to have\nRuntime retention.\nhttps://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/lang/SafeVarargs.java\n\nI'm not sure how linking it against one defined in a jar using java 7 will\nwork out though, my java fu is not that strong.\n\nOn 27 March 2014 10:41, Dylan Sale dylan.sale@gmail.com wrote:\n\n> Looks like it was added in API 19 (\n> http://developer.android.com/reference/java/lang/SafeVarargs.html). It\n> seems to just be a compile time annotation. I'll download SDK 19 and test\n> it.\n> \n> On 27 March 2014 09:41, Ben Christensen notifications@github.com wrote:\n> \n> > /cc @mttkay https://github.com/mttkay @jmhoferhttps://github.com/jmhofer\n> > @zsxwing https://github.com/zsxwing\n> > \n> > ## \n> > \n> > Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/992#issuecomment-38752214\n> > .\n",
        "Sure thing\n",
        "It seems to work, though it gets a bunch of warnings while building:\n\nWarning:Gradle: : rx/Subscriber.class(rx:Subscriber.class): major version\n51 is newer than 50, the highest major version supported by this compiler.\nWarning:Gradle: : rx/Observable.class(rx:Observable.class): major version\n51 is newer than 50, the highest major version supported by this compiler.\nWarning:Gradle: :\nrx/Observable$Operator.class(rx:Observable$Operator.class): major version\n51 is newer than 50, the highest major version supported by this compiler.\nWarning:Gradle: : rx/functions/Func1.class(rx/functions:Func1.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Function.class(rx/functions:Function.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: : rx/Subscription.class(rx:Subscription.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Action1.class(rx/functions:Action1.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/observers/Subscribers.class(rx/observers:Subscribers.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: :\nrx/subscriptions/CompositeSubscription.class(rx/subscriptions:CompositeSubscription.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: : rx/functions/Action2.class(rx/functions:Action2.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/plugins/RxJavaPlugins.class(rx/plugins:RxJavaPlugins.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/Scheduler.class(rx:Scheduler.class): major version 51\nis newer than 50, the highest major version supported by this compiler.\nWarning:Gradle: : rx/functions/Func2.class(rx/functions:Func2.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/FuncN.class(rx/functions:FuncN.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: :\nrx/observables/ConnectableObservable.class(rx/observables:ConnectableObservable.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/subjects/BehaviorSubject.class(rx/subjects:BehaviorSubject.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: :\nrx/subjects/PublishSubject.class(rx/subjects:PublishSubject.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Action0.class(rx/functions:Action0.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/subscriptions/Subscriptions.class(rx/subscriptions:Subscriptions.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: : rx/functions/Func0.class(rx/functions:Func0.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/subjects/Subject.class(rx/subjects:Subject.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: : rx/Observer.class(rx:Observer.class): major version 51 is\nnewer than 50, the highest major version supported by this compiler.\nWarning:Gradle: : rx/functions/Func3.class(rx/functions:Func3.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: :\nrx/Observable$OnSubscribe.class(rx:Observable$OnSubscribe.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Action.class(rx/functions:Action.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/schedulers/Schedulers.class(rx/schedulers:Schedulers.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: :\nrx/plugins/RxJavaObservableExecutionHook.class(rx/plugins:RxJavaObservableExecutionHook.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/observables/BlockingObservable.class(rx/observables:BlockingObservable.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: :\nrx/Observable$OnSubscribeFunc.class(rx:Observable$OnSubscribeFunc.class):\nmajor version 51 is newer than 50, the highest major version supported by\nthis compiler.\nWarning:Gradle: : rx/functions/Func9.class(rx/functions:Func9.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Func8.class(rx/functions:Func8.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Func7.class(rx/functions:Func7.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Func6.class(rx/functions:Func6.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Func5.class(rx/functions:Func5.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/functions/Func4.class(rx/functions:Func4.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\nWarning:Gradle: : rx/Scheduler$Inner.class(rx:Scheduler$Inner.class): major\nversion 51 is newer than 50, the highest major version supported by this\ncompiler.\n",
        "Hmm, I'm seeing some odd behaviour with it saying missing symbols in the\nlog (no crashes though). I'll have a closer look tomorrow if someone else\nhasn't given a better answer :)\n",
        "Looks like KitKat (api 19) supports jdk 7 but you need to setup some\ncompiler flags in gradle turn it on.\n\nhttp://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Using-sourceCompatibility-1.7\n",
        "I was building with JDK 6. \n",
        "I'm not sure when JDK 7 development will become the norm but it is\ncertainly supported using the latest build tools. You can even target older\nversions of android as long as you don't use new features that require\nlibrary support.\n\nI'm on Mac however and getting a version of JDK 7 is not proving easy.\n",
        "The download \"completes\" about 20mb in for me. I'm not sure why.\n"
    ],
    "3966": [],
    "997": [
        "just a gut feeling, but *able sounds like an interface to me. In fact, you could almost extract the different `schedule()` methods (and `now()`, though I don't know what that's for).\n",
        "and just wondering (sorry, it's late and I should be going to bed, so I might be rambling): what happens if the schedule methods on `Scheduler` return `EventLoop`/`Inner` instead of `Subscription`? That way, you wouldn't need a separate `getEventLoop()` and since `EventLoop` implements `Subscription`, you could still use it as such. (and, fwiw, I agree with @kirkshoop re naming)\n",
        "> It means that work must be scheduled and executed just to get the reference. This in turn means that volatile mutable references must be used (and set on first work such as an onNext) rather than immutable final references to the EventLoop/Inner assigned at subscription time. That may or may not be an issue. \n\nright you are, scratch that. I was thinking of something like this:\n\n``` java\nfinal InnerClassOfSomeName is = scheduler.schedule(new Action0() {\n    @Override\n    public void call() {\n        // do work here then reschedule\n        is.reschedule();\n    }\n});\nis.unsubscribe()\n```\n\nObviously, that won't work. Sorry for wasting your time.\n\n> I don't understand what \"you could almost extract the different schedule() methods\" is referring to as far as API design. Being an interface is not helpful in this case\n\nThat was a knee-jerk reaction because both `Schedulable`/`Recurse` as well as `EventLoop`/`Inner` contain the method signatures\n\n``` java\nvoid schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\nvoid schedule(Action1<Schedulable> action);\nlong now();\n```\n\n You're probably correct that this doesn't define an interface.\n\n> >   just a gut feeling, but *able sounds like an interface to me\n> \n> What do you suggest calling the Recurse/Schedulable type?\n\nMy objection was that in the JDK, adjectives are often (usually?) interfaces or annotations (`Runnable`, `Cloneable`, `Comparable`, `@Nullable`, etc). Though I guess `Observable` is a good counterexample, both inside and outside the JDK :).\n\nI don't really have a better suggestion either, and `Schedulable` is fine. Something along the line of `Executor` might make sense, since you call `schedule()` on something to which you submit an action for execution later. Obviously, `Executor` itself is very much in use already. \n\nPlease don't let me hold you up. I just ran across a tweet by @headinthebox and started bikeshedding on an impulse.\n",
        "> Reading up on recursive lambdas in Java 8 it looks like it was allowed at some point but not in the shipping version ... no idea why not.\n\nmaybe it's got something to do with the fact that lambdas aren't compiled to inner classes but [use invokedynamic](http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html):\n\n> When the compiler encounters a lambda expression, it first lowers (desugars) the lambda body into a method whose argument list and return type match that of the lambda expression, possibly with some additional arguments (for values captured from the lexical scope, if any.) At the point at which the lambda expression would be captured, it generates an invokedynamic call site, which, when invoked, returns an instance of the functional interface to which the lambda is being converted. This call site is called the lambda factory for a given lambda. The dynamic arguments to the lambda factory are the values captured from the lexical scope. The bootstrap method of the lambda factory is a standardized method in the Java language runtime library, called the lambda metafactory. The static bootstrap arguments capture information known about the lambda at compile time (the functional interface to which it will be converted, a method handle for the desugared lambda body, information about whether the SAM type is serializable, etc.)\n\nThe link is from 2012, but seems to agree with a [recent article](http://www.takipiblog.com/2014/01/16/compiling-lambda-expressions-scala-vs-java-8/), afaict.\n\n> Page 49 of http://www.angelikalanger.com/Lambdas/LambdaReference.pre-release.pdf demonstrates it.\n\nWow, awesome reference!\n\n> > What about SerialScheduler instead of Inner?\n> > Scheduler.SerialScheduler has a bit too much cowbell for my taste.\n\nsome alternatives I came up with:\n- `Scheduler.Rescheduler`: because you use it to reschedule the task (but maybe that's even more cowbell?)\n- `Scheduler.Trampoline`: the functionality is similar to using a trampoline for tail calls.\n\nI'm not sure how to read `Scheduler.Inner`. Is it an inner scheduler, e.g. a scheduler for inner loops, or is it just some inner class of `Scheduler`?\n\nRe the choice between the two approaches: I'd personally err on the side of making the API so that it can't be used incorrectly, even if it's less pretty, especially if use-case 3 is common and would be the one that you'd tend to get wrong.\n\nI'm not sure, but If the single-use usecase is common, you could still add a convenience method, right? Or would this invite the incorrect use in use-case 3 again?\n\n``` java\nclass Scheduler {\n    public abstract Foo getFoo(); \n    public int degreeOfParallelism();\n    public long now();\n    // new:\n    public Subscription scheduleOnce(Action0 action) { \n        Foo foo = getFoo();\n        foo.schedule(action);\n        return foo;\n    }\n\n    public abstract static class Foo implements Subscription {\n        public abstract void schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n\nAs I mentioned earlier, I've never actually _used_ this part of RxJava myself, so I can't really provide more than gut reactions.\n",
        "I vote for `scheduler.createQueue` which implies that it is a collection, or rather a priority queue, which must be emptied and cleaned up properly.\n",
        "@benjchristensen I'd also vote for `scheduler.createWorker`.\n",
        "Based on these implementation requirements for C++ would you recommend a different signature from this?\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Recurse> action);\n    public final Subscription schedule(Action1<Recurse> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Recurse> action, long initialDelay, long period, TimeUnit unit);\n    public abstract Inner createInner(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Recurse {\n        public final void schedule();\n        public final void schedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Recurse> action);\n        public final void schedule(Action1<Recurse> action, final long delayTime, final TimeUnit unit);\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class Inner implements Subscription {\n        public abstract void schedule(Action1<Recurse> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Recurse> action);\n        public long now();\n    }\n}\n```\n\n@headinthebox Does this change your perspective on the Java design at all?\n",
        "I have submitted a pull request with these changes. \n\nUsage looks like this:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Scheduler.Inner;\nimport rx.Scheduler.Recurse;\nimport rx.functions.Action1;\nimport rx.schedulers.Schedulers;\n\npublic class Test {\n\n    public static void main(String args[]) {\n\n        Schedulers.newThread().schedule(new Action1<Recurse>() {\n\n            @Override\n            public void call(Recurse r) {\n                System.out.println(\"do stuff\");\n                // recurse\n                r.schedule(this);\n            }\n\n        });\n\n        Schedulers.newThread().schedule(recurse -> {\n            System.out.println(\"do stuff\");\n            recurse.schedule();\n        });\n\n        Schedulers.newThread().schedule(recurse -> {\n            System.out.println(\"do stuff\");\n            recurse.schedule(1000, TimeUnit.MILLISECONDS);\n        });\n\n        Schedulers.newThread().schedule(recurse -> {\n            recurse.schedule(re -> {\n                System.out.println(\"do more stuff\");\n            });\n        });\n\n        Inner inner = Schedulers.newThread().createInner();\n        inner.schedule(re -> {\n            System.out.println(\"do stuff\");\n            re.schedule(r -> {\n                System.out.println(\"do more stuff\");\n            });\n        });\n\n    }\n}\n```\n\nCode outline:\n\n![screen shot 2014-04-02 at 11 08 31 pm](https://cloud.githubusercontent.com/assets/813492/2600101/6c680404-baf6-11e3-916e-c41a817bc328.png)\n",
        "This is the time to voice opinions and affect change. Once we make these changes we're headed towards 1.0 and really do not want to change these signatures again.\n\nI welcome bike shedding and arguing over names, signatures, etc for the next couple days but would like to wrap it up and move forward by the weekend unless a glaring issue is found.\n\nI would appreciate suggestions for better names than `Recurse` and `Inner`, neither of which I particularly like.\n",
        "@kirkshoop If you have a chance to answer my previous question, I'd appreciate it so we make sure these changes address broad use cases and are not bound to a specific language (since even though we're on the JVM, there are several different languages we support, and it would be preferable for Rx across platforms to be similar).\n\n> Based on these implementation requirements for C++ would you recommend a different signature from this?\n",
        "Thank you @kirkshoop for the feedback. If I understand correctly, the primary change would be hiding the `Inner` from public use. I'm going to repost a comment from https://github.com/Netflix/RxJava/pull/1014#issuecomment-39477335 about a use case that requires `Inner` being accessible publicly:\n\n---\n\nThe problem I've had with combining them (`Inner` and `Recurse`) is that when first creating an `Inner` there is no `Action` to invoke. Using the ThreadLocal to store the current action doesn't solve this, it would just make it non-obvious why `inner.schedule()` doesn't work the first time, and the API would be odd that I can get an `Inner` with a `schedule()` method even though nothing has been invoked yet.\n\nThe reason for this scenario is that retrieving an `Inner` via `createInner()` is needed to make use cases like `observeOn` less awkward. Here is the example where `Inner` is retrieved before an `Action` is executed in `observeOn`:\n\n``` java\n        protected void schedule() {\n            if (counter.getAndIncrement() == 0) {\n                if (recursiveScheduler == null) {\n                    recursiveScheduler = scheduler.createInner();\n                    add(recursiveScheduler);\n                }\n                recursiveScheduler.schedule(new Action1<Recurse>() {\n\n                    @Override\n                    public void call(Recurse inner) {\n                        pollQueue();\n                    }\n\n                });\n            }\n        }\n```\n\nThe reason is that the recursion happens externally (the operator is doing it) rather than internally (inside the `Action<Inner>/Action<Recurse>`.\n\nTherefore, we have use cases where `Inner` is used before `Recurse` makes sense, so the API is not appropriate when they are combined.\n\n---\n\nThus, if we have `ScheduledAction`/`Recurse` as the only public type and hide `Inner` as an implementation detail, we can not gracefully solve the `observeOn` use case without doing what it does now: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java#L94 =>\n\n``` java\n        protected void schedule() {\n            if (counter.getAndIncrement() == 0) {\n                if (recursiveScheduler == null) {\n                    add(scheduler.schedule(new Action1<Inner>() {\n\n                        @Override\n                        public void call(Inner inner) {\n                            recursiveScheduler = inner;\n                            pollQueue();\n                        }\n\n                    }));\n                } else {\n                    recursiveScheduler.schedule(new Action1<Inner>() {\n\n                        @Override\n                        public void call(Inner inner) {\n                            pollQueue();\n                        }\n\n                    });\n                }\n            }\n        }\n```\n\nIs solving this use case gracefully a good enough reason for exposing `Inner` via the `createInner()` method? Most people will never need to use it and only interact with `Recurse` (or `ScheduledAction` or whatever we call it) and thus only see the `Inner` type on the `createInner()` method that they ignore.\n\nThe `Scheduler.createInner()` method feels similar to the `Observable.unsafeSubscribe()` method.\n",
        "The `scheduler` being passed in there is the \"outer\" one which means it would create a new \"inner\" each time and could (depending on which `Scheduler` it is) spawn a new thread for every `ScheduledAction`.\n",
        "Also, by doing it that way it makes the `Subscription` logic unclear. A `ScheduledAction.schedule()` should not return a `Subscription` each time, as unsubscribing from it would shut down the entire \"inner\" scheduler, so unsubscribing on one should not shut down all actions. \n\nThis is why the `Scheduler.schedule` methods return `Subscription` as it represents the `Inner` thread or event-loop, but the `Recurse.schedule` and `Inner.schedule` methods return void. \n",
        "I had the chance to meet @kirkshoop in person while in London and we reviewed the needs of CPP and Java and came to agreement on the proposed model. We are considering slightly changed names though to improve the semantic meaning:\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Schedulable> action);\n    public final Subscription schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Schedulable> action, long initialDelay, long period, TimeUnit unit);\n    public abstract EventLoop createEventLoop(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Schedulable {\n        public final void schedule();\n        public final void schedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Schedulable> action);\n        public final void schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class EventLoop implements Subscription {\n        public abstract void schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Schedulable> action);\n        public long now();\n    }\n}\n```\n\nNeither of us are sold on `Schedulable` or `EventLoop` (nor `Recurse` or `Inner) so please let us know if you have better ideas.\n",
        "There are 3 types of usage patterns to address with this design:\n\n#### 1) Single Action\n\nThe simplest case where only a single action is scheduled which results in a new inner EventLoop being created.\n\nUse Cases: subscribeOn, unsubscribeOn, timeout, interval, timer\n\nExample:\n\n``` java\nscheduler.schedule(new Action1<Schedulable>() {\n\n    @Override\n    public void call(final Schedulable re) {\n        // do work here\n    }\n})\n```\n\n#### 2) Inner Recursion\n\nSimple recursion where the work to be repeated is derived from inside the initially scheduled Action, generally just repeating itself.\n\nUse Cases: retry, repeat\n\nExample:\n\n``` java\nscheduler.schedule(new Action1<Schedulable>() {\n\n    @Override\n    public void call(final Schedulable re) {\n        // do work here then recursively reschedule\n        re.schedule();\n    }\n})\n```\n\nBeyond just rescheduling itself, it can reschedule with a delay, or schedule a different Action on the inner EventLoop it has access to via the `Schedulable`.\n\n#### 3) Outer Recursion\n\nThe more complex case, but actually quite common requirement is outer recursion. This use case exists because the scheduling of work is being driven by outer notifications, such as via `onNext`.\n\nUse Cases: observeOn, repeat ... and should be things like debounce which are currently implemented wrong.\n\nExample:\n\n``` java\nfinal EventLoop eventLoop = scheduler.createEventLoop();\n\npublic void onNext(T t) {\n    eventLoop.schedule(new Action1<Schedulable>() {\n\n        @Override\n        public void call(final Schedulable re) {\n            // do work here\n        }\n    })\n}\n```\n\nA single EventLoop (Inner) needs to be created and reused for all notifications received, thus a reference to it must exist and be used for scheduling.\n\nEach `onNext` will then schedule work to be performed sequentially on the same EventLoop.\n\n### Current Design\n\nThe current design is:\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Schedulable> action);\n    public final Subscription schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Schedulable> action, long initialDelay, long period, TimeUnit unit);\n    public abstract EventLoop createEventLoop(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Schedulable {\n        public final void schedule();\n        public final void schedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Schedulable> action);\n        public final void schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n        public long now();\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class EventLoop implements Subscription {\n        public abstract void schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Schedulable> action);\n        public long now();\n    }\n}\n```\n\nThis design achieves all of the goals, but it has duplication of signatures to favor a simple model for use cases (1) and (2) while still addressing (3).\n\n### Alternate Design\n\nWe could reduce some of the duplication of the Scheduler API by accepting use case (3) as the primary case and all others work within it.\n\n``` java\nclass Scheduler {\n    public abstract EventLoop createEventLoop(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Schedulable {\n        public final void schedule();\n        public final void schedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Schedulable> action);\n        public final void schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n        public long now();\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class EventLoop implements Subscription {\n        public abstract void schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Schedulable> action);\n        public long now();\n    }\n}\n```\n\nThe drawback of this for usage is that now the `createEventLoop()` needs to be used for use cases (1) and (2) and the `Subscription` explicitly captured.\n\n``` java\n// instead of this\nsubscriber.add(scheduler.schedule(new Action1<Schedulable>() {\n\n    @Override\n    public void call(final Schedulable re) {\n        // do work here\n    }\n}))\n\n// it would now be this\nEventLoop loop = scheduler.createEventLoop();\nsubscriber.add(loop);\nloop.schedule(new Action1<Schedulable>() {\n\n    @Override\n    public void call(final Schedulable re) {\n        // do work here\n    }\n});\n```\n\n### Bikeshed\n\nNow is the time to [bikeshed](http://bikeshed.com) on this and argue over the design and names while accounting for these 3 use cases.\n\nI personally think we should leave the 3 redundant methods on `Scheduler` to simplify the easy use cases of (1) and (2) so `createEventLoop()` only ever gets used for use case (3).\n",
        "Reviewing with @headinthebox ...\n\n#### Option 1\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Schedulable> action);\n    public final Subscription schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Schedulable> action, long initialDelay, long period, TimeUnit unit);\n    public abstract EventLoop getEventLoop(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Schedulable {\n        public final void reschedule();\n        public final void reschedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Schedulable> action);\n        public final void schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n        public long now();\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class EventLoop implements Subscription {\n        public abstract void schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Schedulable> action);\n        public long now();\n    }\n}\n```\n\n#### Option 2\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Schedulable> action);\n    public final Subscription schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Schedulable> action, long initialDelay, long period, TimeUnit unit);\n    public abstract Inner getInner(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Schedulable {\n        public final void reschedule();\n        public final void reschedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Schedulable> action);\n        public final void schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n        public long now();\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class Inner implements Subscription {\n        public abstract void schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Schedulable> action);\n        public long now();\n    }\n}\n```\n\n#### Option 3\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Recurse> action);\n    public final Subscription schedule(Action1<Recurse> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Recurse> action, long initialDelay, long period, TimeUnit unit);\n    public abstract Inner getInner(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Recurse {\n        public final void reschedule();\n        public final void reschedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Recurse> action);\n        public final void schedule(Action1<Recurse> action, final long delayTime, final TimeUnit unit);\n        public long now();\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class Inner implements Subscription {\n        public abstract void schedule(Action1<Recurse> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Recurse> action);\n        public long now();\n    }\n}\n```\n",
        "Preference by @headinthebox is option 2 above which changes `EventLoop` back to `Inner` because `EventLoop` has different semantic meaning than the very generic `Inner`. An \"event loop\" on a `NewThreadScheduler` versus `Trampoline` vs something else is rather different.\n",
        "We plan on making the final decision tomorrow, April 15th now that this has been available for debate for over a week. \n",
        "> That way, you wouldn't need a separate getEventLoop() and since EventLoop implements Subscription, you could still use it as such.\n\nIt means that work must be scheduled and executed just to get the reference. This in turn means that volatile mutable references must be used (and set on first work such as an `onNext`) rather than immutable final references to the `EventLoop`/`Inner` assigned at subscription time. That may or may not be an issue. \n\n> then use SerialQueue or anything else that specifies the behavior of scheduling on the returned object\n\nGood feedback.\n\n> just a gut feeling, but *able sounds like an interface to me\n\nWhat do you suggest calling the `Recurse`/`Schedulable` type?\n\nI don't understand what \"you could almost extract the different schedule() methods\" is referring to as far as API design. Being an interface is not helpful in this case. The point of the `Recurse`/`Schedulable` type is combining an `Inner`/`EventLoop` with an `Action0` that can be rescheduled recursively for use case (2).\n",
        "By the way, we could always swing the opposite direction and make the user worry about the use cases and only expose the most basic functional aspects:\n\n``` java\nclass Scheduler {\n    public abstract InnerClassOfSomeName getInnerClassOfSomeName(); \n    public int degreeOfParallelism();\n    public long now();\n\n    public abstract static class InnerClassOfSomeName implements Subscription {\n        public abstract void schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n\n#### 1) Single Action\n\n``` java\nfinal InnerClassOfSomeName is = scheduler.getInnerClassOfSomeName();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here\n    }\n})\n\nis.unsubscribe()\n```\n\nwith lambda\n\n``` java\nfinal InnerClassOfSomeName is = scheduler.getInnerClassOfSomeName();\nis.schedule(() -> {\n        // do work here\n})\n\nis.unsubscribe()\n```\n\n#### 2) Inner Recursion\n\n``` java\nfinal InnerClassOfSomeName is = scheduler.getInnerClassOfSomeName();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here then recursively reschedule\n        is.schedule(this); // this will NOT work with lambdas, only anonymous inner classes\n    }\n})\n\nis.unsubscribe()\n```\n\n#### 3) Outer Recursion\n\n``` java\nfinal InnerClassOfSomeName is = scheduler.getInnerClassOfSomeName();\n\npublic void onNext(T t) {\n    is.schedule(new Action0() {\n\n        @Override\n        public void call() {\n            // do work here\n        }\n    })\n}\n\nis.unsubscribe()\n```\n\nwith lambdas\n\n``` java\nfinal InnerClassOfSomeName is = scheduler.getInnerClassOfSomeName();\n\npublic void onNext(T t) {\n    is.schedule(() -> {\n            // do work here\n    })\n}\n\nis.unsubscribe()\n```\n\nI don't like this approach, but it's an option.\n",
        "> Obviously, that won't work. Sorry for wasting your time.\n\n@ccmtaylor not a problem at all! I appreciate your involvement. Can't you see how many breaking changes to the API have happened due to mistakes I've either written or merged!  I only know about this particular use case because I've implemented `Scheduler` 3 times now :-)\n\n> My objection was that in the JDK, adjectives are often (usually?) interfaces or annotations\n\ngood point\n\n> I guess Observable is a good counterexample, both inside and outside the JDK\n\nIf the JVM supported extension methods `Observable` would probably be an interface like it is in C#. \n\n> started bikeshedding on an impulse\n\nThat's what we asked for on this one, so thank you! The craziest ideas or simplest questions can spark a thought and change a design, or just prove an API isn't clear.\n",
        "Down to choosing between:\n\n``` java\nclass Scheduler {\n    public abstract Inner getInner(); \n    public int degreeOfParallelism();\n    public long now();\n\n    public abstract static class Inner implements Subscription {\n        public abstract void schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n\n#### Pros\n- very simple API\n- small surface area\n- forces correct usage by getting the `Inner` then doing work\n\n#### Cons\n- recursion does not work with lambdas\n\n``` java\nclass Scheduler {\n    public final Subscription schedule(Action1<Schedulable> action);\n    public final Subscription schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(Action1<Schedulable> action, long initialDelay, long period, TimeUnit unit);\n    public abstract Inner getInner(); // for advanced use cases like `observeOn`\n    public int degreeOfParallelism();\n    public long now();\n\n    // now the primary interface\n    public static final class Schedulable {\n        public final void reschedule();\n        public final void reschedule(long delay, TimeUnit unit);\n        public final void schedule(Action1<Schedulable> action);\n        public final void schedule(Action1<Schedulable> action, final long delayTime, final TimeUnit unit);\n        public long now();\n    }\n\n    // now mostly an implementation detail except for advanced use cases\n    public abstract static class Inner implements Subscription {\n        public abstract void schedule(Action1<Schedulable> action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action1<Schedulable> action);\n        public long now();\n    }\n}\n```\n\n#### Pros\n- supports all 3 use cases including recursion with lambdas\n- one step less on single action use case (skip the `createInner()` step)\n\n#### Cons\n- using the single action use case can lead to incorrectly performing \"outer recursion\" via \"single action\" execution on the outer `Scheduler`\n- broad and repetitive surface area\n- awkward existence of type and naming of `Scheduler`/`Recurse` just to support lambda recursion\n",
        "Reading up on recursive lambdas in Java 8 it looks like it was allowed at some point but not in the shipping version ... no idea why not.\n\nPage 49 of http://www.angelikalanger.com/Lambdas/LambdaReference.pre-release.pdf demonstrates it.\n\n> It means that recursive use of lambda expressions is not supported and anonymous inner classes must be used instead.\n\nBrian Goetz showed it as possible back in December 2011 (http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-4.html) like this:\n\n``` java\nfinal Runnable r = () -> {\n  // This reference to 'r' is legal:\n  if (!allDone) { workQueue.add(r); }\n  else { displayResults(); }\n};\n```\n\n... but that no longer works in the shipping version and those examples were removed from the final post by Brian Goetz on the topic: http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html\n",
        "What about `SerialScheduler` instead of `Inner`?\n\n``` java\nclass Scheduler {\n    public abstract SerialScheduler getSerialScheduler(); \n    public int degreeOfParallelism();\n    public long now();\n\n    public abstract static class SerialScheduler implements Subscription {\n        public abstract void schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract void schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n",
        "Okay :-)\n",
        "> maybe it's got something to do with the fact that lambdas aren't compiled to inner classes but use invokedynamic:\n\nI imagine you're right that it's related to that, though with the nuance that it allows them to do different things in the future, even though currently (Java 8 initial release) at runtime they become inner classes.\n\n> I'm not sure how to read Scheduler.Inner. Is it an inner scheduler, e.g. a scheduler for inner loops, or is it just some inner class of Scheduler?\n\nWe think of it as \"Inner Scheduler\" ... the scheduler for inner loops.\n\n> `Scheduler.Trampoline`\n\nThere is an actual `TrampolineScheduler` so we can't call this more generic thing `Trampoline` as well.\n\n>  I'd personally err on the side of making the API so that it can't be used incorrectly\n\nI tend to agree after reviewing the two extremes with @headinthebox and at this point that has pushed us to the simplest API with the least surface area. \n\n> If the single-use usecase is common...\n\nYes, we can always add something like `scheduleOnce` but I'm going to avoid that right now as that can be added in the future if we decided it is needed. It's a little more verbose in the operators without it, but it is very clear as to what is being done.\n",
        "I have submitted a pull request that is the simplified API: https://github.com/Netflix/RxJava/pull/1047\n\nI'm copying the description here for completeness on this thread as the design changed slightly during implementation:\n- I changed `getInner()` to `inner()` as both \"get\" and \"create\" seem wrong since it's up to the `Scheduler` implementation as to what happens when the `Inner` is instantiated.\n- I had to made the `Inner.schedule` methods return `Subscription` for the 4th use case listed below.\n\n---\n\n``` java\nclass Scheduler {\n    public abstract Inner inner(); \n    public int degreeOfParallelism();\n    public long now();\n\n    public abstract static class Inner implements Subscription {\n        public abstract Subscription schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract Subscription schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n\nWhile migrating to this I found a 4th use case in addition to the previously discussed 3 that required the `schedule` methods inside `Inner` to also return `Subscription` for canceling the individual tasks as opposed to the entire `Inner`.\n\nHere are the use cases:\n\n#### 1) Single Action\n\n``` java\nfinal Inner is = scheduler.inner();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here\n    }\n})\n\nis.unsubscribe()\n```\n\nwith lambda\n\n``` java\nfinal Inner is = scheduler.inner);\nis.schedule(() -> {\n        // do work here\n})\n\nis.unsubscribe()\n```\n\n#### 2) Inner Recursion\n\n``` java\nfinal Inner is = scheduler.inner();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here then recursively reschedule\n    is.schedule(this); // this will NOT work with lambdas, only anonymous inner classes\n    }\n})\n\nis.unsubscribe()\n```\n\n#### 3) Outer Recursion\n\n``` java\nfinal Inner is = scheduler.inner();\n\npublic void onNext(T t) {\n    is.schedule(new Action0() {\n\n        @Override\n        public void call() {\n            // do work here\n        }\n    })\n}\n\nis.unsubscribe()\n```\n\n#### 4) Outer Recursion with Task Cancellation\n\nThis is used for things like `debounce` and `throttleLast` where tasks are being scheduled and cancelled as `onNext` notifications are received.\n\n``` java\nfinal Inner is = scheduler.inner();\nSerialSubscription serial = new SerialSubscription();\n\npublic void onNext(T t) {\n    // schedule a new task and cancel previous if not yet executed\n    serial.set(is.schedule(new Action0() {\n\n        @Override\n        public void call() {\n            // do work here\n        }\n    }));\n}\n\nis.unsubscribe()\n```\n",
        "Items open for discussion still ...\n\n1) The `Inner` name is still not great.\n2) The `Subscription` being returned by `Inner.schedule` has a different meaning than the `Inner implements Subscription` and could be a source of confusion, but I don't see a better way to handle it.\n\nAn `Inner` must be `unsubscribed` after finishing work, whereas the `Subscription` returned from `inner.schedule` is optional (only for canceling a task).\n\nAfter migrating the codebase to this API my impression is:\n- the small surface area of the API is preferable\n- the lack of specific support of inner recursion is not a problem in practice (the few places it's needed it will be okay to not use lambdas since Oracle decided to not allow recursive use of lambdas)\n- the `inner()` factory method forces thinking about the `Subscription` behavior and I found/fixed bugs\n",
        "After sleeping on this I'm thinking it may make sense after all to call the factory method `createInner()`.\n\nEven though some implementations will reuse an inner event loop, even those will create a new `Inner` each time since it also represents the `Subscription` and lifecycle of all actions scheduled on that `Inner`. Thus, it does create something new each time and needs to be disposed of.\n\nUsing `inner()` or `getInner()` does not convey the resource lifecycle, whereas `createInner()` does.\n\nUsage would be like this:\n\n``` java\nfinal Inner is = scheduler.createInner();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here\n    }\n})\n\n// clean up at some point\nis.unsubscribe()\n```\n\nor when inside an `OnSubscribe` function it needs to be like this:\n\n``` java\nfinal Inner is = scheduler.createInner();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        onNext();\n        onCompleted();\n        // then cleanup\n        is.unsubscribe()\n    }\n})\n```\n\nBecause of the cleanup requirements, I think it should be `createInner()` so the signature of `Scheduler` is:\n\n``` java\nclass Scheduler {\n    public abstract Inner createInner(); \n    public int degreeOfParallelism();\n    public long now();\n\n    public abstract static class Inner implements Subscription {\n        public abstract Subscription schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract Subscription schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n",
        "Anyone else think it's cleaner to change `degreeOfParallelism()` to just `parallelism()`? \n",
        "Possible replacements for `Scheduler.Inner`:\n- Scheduler.Serial\n- Scheduler.Loop\n- Scheduler.Queue\n- Scheduler.SerialQueue\n- Scheduler.Sequence\n\nYes ... I'm just trolling the thesaurus.\n\nIn code these would be:\n- `scheduler.createInner()`\n- `scheduler.createSerial()`\n- `scheduler.createLoop()`\n- `scheduler.createQueue()`\n- `scheduler.createSerialQueue()`\n- `scheduler.createSequence()`\n\nI'm trying to figure out what word communicates that we are creating something that ...\n- executes tasks sequentially\n- has a lifecycle\n- must be cleaned up\n",
        "Current state:\n\n``` java\nclass Scheduler {\n    public abstract Inner createInner(); \n    public int parallelism();\n    public long now();\n\n    public abstract static class Inner implements Subscription {\n        public abstract Subscription schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract Subscription schedule(Action0 action);\n        public Subscription schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n",
        "Task is a single thing, whereas `Inner` represents a queue of tasks to be executed. Also, `Task` is more synonymous with `Future`, especially since that's what .Net uses to represent `Future`.\n",
        "I'm proceeding with merging this as it currently stands, but not yet releasing it. \n\nThe only thing left to debate I believe is if someone can give a better name than `Scheduler.Inner`.\n",
        "> this scheduler is backed by an Executor thread-pool that will grow as needed; \n\nFor the IO scheduler, this detail is no longer true as it does not use an `Executor` any longer, and can change. So the important part is that it will grow as needed and allocate threads (whether from a pool or new) to support blocking IO.\n\n> Using Scheduler\n\nThe examples look good, but would result in leaks as they never call `inside.unsubscribe()`. You refer to this later, but I'm concerned people would miss that and copy/paste those examples without realizing that. \n\nGenerally it can't be done synchronously (after the `schedule`) call as that defeats the whole point, so the `inside` needs to be added to the `Subscriber` to be unsubscribed when it is, or inside the action itself it needs to unsubscribe when done if it is a fire-and-forget style execution.\n\nThus, there are 2 approaches to handling the subscription:\n\n1) inside the action, as your example shows\n2) by registering with a `Subscriber` such as `subscriber.add(inside)` so the `Scheduler.Inner` gets unsubscribed when the `Subscriber` is.\n\nIn short, the docs look great (thank you!), it's just the unsubscribe requirement that I think needs clarification.\n",
        "We have adopted the simplified `Scheduler` design, but the `Scheduler.Inner` name still exists and is still not liked. Final chance before releasing to debate and change the name ...\n\nPossible replacements for `Scheduler.Inner`:\n- `Scheduler.Worker`\n- `Scheduler.Serial`\n- `Scheduler.Loop`\n- `Scheduler.Queue`\n- `Scheduler.SerialQueue`\n- `Scheduler.Sequence`\n\nIn code these would be:\n- `scheduler.createWorker()`\n- `scheduler.createSerial()`\n- `scheduler.createLoop()`\n- `scheduler.createQueue()`\n- `scheduler.createSerialQueue()`\n- `scheduler.createSequence()`\n\nI'm trying to figure out what word communicates that we are creating something that ...\n- executes tasks sequentially\n- has a lifecycle\n- must be cleaned up\n\nWe do not want something specific like `EventLoop` as that has more specific connotation that may not hold true in an implementation of `Scheduler.Inner`. We also don't want something redundant like `Scheduler.InnerScheduler` or `Scheduler.SerialScheduler`.\n\nPlease vote on the above, or provide us with a more inspired name!\n",
        "/cc @samuelgruetter @zsxwing @jmhofer @akarnokd @kirkshoop @mattpodwysocki @headinthebox @daveray @michaeldejong @mttkay @mattrjacobs @johnhmarks @davidmoten \n",
        "> Threadpool.Scheduler\n\nThere's nothing about a `Scheduler` that requires a thread pool, in fact, several of them do not use a thread pool, or even necessarily plural threads. Especially the inner one is not a `pool` since it is specifically sequential in nature.\n\n> `scheduler.createQueue`\n\nI'm okay with this option.\n\nI also like `scheduler.createWorker()` as it implies a single instance of something doing work that then needs to be stopped.\n",
        "Worker looks like it's going to win ... @headinthebox are you okay with this?\n\nThe signature will look like this:\n\n``` java\nclass Scheduler {\n    public abstract Worker createWorker(); \n    public int parallelism();\n    public long now();\n\n    public abstract static class Worker implements Subscription {\n        public abstract Subscription schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract Subscription schedule(Action0 action);\n        public Subscription schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n",
        "I will make the change to `Scheduler.Worker`. This means we're now free to release 0.18 whenever we're ready.\n",
        "Here is the state of scheduler in rxcpp v2. \n\nIn order to allow tight tail-recursion, the rxcpp (v2) scheduler has a type currently called [schedulable](https://rxcpp.codeplex.com/SourceControl/latest#Rx/v2/src/rxcpp/rx-scheduler.hpp)\n\n``` C++\nclass schedulable : public schedulable_base\n{\n    composite_subscription lifetime;\n    scheduler controller;\n    action activity;\n\n    recursed_scope_type recursed_scope;\n\npublic:\n    schedulable()\n    {\n    }\n    schedulable(composite_subscription cs, scheduler q, action a)\n        : lifetime(std::move(cs))\n        , controller(std::move(q))\n        , activity(std::move(a))\n    {\n    }\n\n    inline composite_subscription& get_subscription() ;\n    inline scheduler& get_scheduler() ;\n    inline action& get_action() ;\n\n    inline auto set_recursed(const recurse& r) const;\n\n    // recursed - request tail-recursion\n    //\n    inline void operator()() const ;\n\n    // composite_subscription\n    //\n    inline bool is_subscribed() const ;\n    inline weak_subscription add(shared_subscription s) const ;\n    inline weak_subscription add(dynamic_subscription s) const ;\n    inline void remove(weak_subscription w) const ;\n    inline void clear() const ;\n    inline void unsubscribe() const ;\n\n    // scheduler\n    //\n    inline clock_type::time_point now() const ;\n    inline void schedule() const ;\n    inline void schedule(clock_type::duration when) const ;\n    inline void schedule(clock_type::time_point when) const ;\n\n    // action\n    //\n    inline action_duration::type get_duration() const;\n    inline void operator()(const schedulable& scbl, const recurse& r) const;\n};\n```\n\nThe tail-recursion can only be requested in the callback from the scheduler. So for this implementation, if you transport the schedulable out and then request tail-recursion, the process will exit.\n\nIf I run into the Inner issue in observe_on, I will just make schedulable extract it from the scheduler in the constructor through a private or detail:: accessor.\n\nA scheduler takes a schedulable and ignores the scheduler it contains.\n\n``` C++\nclass scheduler : public scheduler_base\n{\npublic:\n    typedef scheduler_base::clock_type clock_type;\n\n    inline clock_type::time_point now() const ;\n\n    inline void schedule(const schedulable& scbl) const ;\n    inline void schedule(clock_type::duration when, const schedulable& scbl) const ;\n    inline void schedule(clock_type::time_point when, const schedulable& scbl) const ;\n};\n```\n\nThe range operator requests tail-recursion\n\n``` C++\ntemplate<class T>\nstruct range : public source_base<T>\n{\n//...\n    template<class Subscriber>\n    void on_subscribe(Subscriber o) {\n        auto state = std::make_shared<state_type>(init);\n        state->sc.schedule(make_schedulable(\n            o, // share the same subscription with the scheduler\n            [=](const rxsc::schedulable& self){\n                if (state->remaining == 0) {\n                    o.on_completed();\n                    // o is unsubscribed\n                }\n                if (!o.is_subscribed()) {\n                    // terminate loop\n                    return;\n                }\n\n                // send next value\n                --state->remaining;\n                o.on_next(state->next);\n                state->next = static_cast<T>(state->step + state->next);\n\n                // tail recurse this same action to continue loop\n                self();\n            }));\n    }\n};\n```\n\nIn C++ it is essential to keep virtual function calls out of an inner loop. To make tail-recursion work efficiently the recursion objects create a space on the stack inside the virtual function call in the actor that allows the callback and the scheduler to share stack space that records the request and the allowance without any virtual calls in the loop.\n\n``` C++\ntemplate<class F>\ninline action make_action(F&& f, action_duration::type d = action_duration::runs_short) {\n    auto fn = std::forward<F>(f);\n    return action(std::make_shared<detail::action_type>(\n        d,\n        // tail-recurse inside of the virtual function call\n        // until a new action, lifetime or scheduler is returned\n        [fn](const schedulable& s, const recurse& r) {\n            auto scope = s.set_recursed(r);\n            while (s.is_subscribed()) {\n                r.reset();\n                fn(s);\n                if (!r.is_allowed() || !r.is_requested()) {\n                    if (r.is_requested()) {\n                        s.schedule();\n                    }\n                    break;\n                }\n            }\n        }));\n}\n```\n\nThe current_thread uses a thread-local recursion to indicate that tail-recursion is only allowed when the queue is empty\n\n``` C++\n//...\n        const auto& recursor = queue::get_recursion().get_recurse();\n\n        // loop until queue is empty\n        for (\n             auto when = queue::top().when;\n             std::this_thread::sleep_until(when), true;\n             when = queue::top().when\n             )\n        {\n            auto what = queue::top().what;\n\n            queue::pop();\n\n            what(recursor);\n\n            if (queue::empty()) {\n                break;\n            }\n        }\n//...\n```\n",
        "Oh. My.\n\nWell I had a long reply but it just got lost. I know better than to use the web interface. :(\n\nI can't write it again so here is the summary.\n\nRxCpp took the insight from a comment by @akarnokd, I think, to another RxJava issue that the parameter to subscribe is like subscriber which is also like subject in that they are all objects whose single-concern is to bind other single-concern objects together.\n\nIn this case the parameter would be a type that binds the scheduler (with private access to its inner) the action and the subscription together and then expose the functionality of Recurse, Inner, Subscription and Action1. The subscription would be removed from the Action1 in this case. A name that comes to mind is ScheduleAction.\n\nI can still count the lines of Java that I have written so be gentle :)\n\n```\nclass ScheduleAction {\n    public final Action1<ScheduleAction> get_action();\n    public final Subscription get_subscription();\n    public final Scheduler get_scheduler();\n\n    public final bool isUnsubscribed();\n    public final void unsubscribe();\n\n    // action methods - Sorry, I didn't look them up\n    :::\n\n    public long now();\n\n    // uses scheduler\n    public final void schedule();\n    public final void schedule(long delay, TimeUnit unit);\n\n    // uses inner\n    public final void schedule(ScheduleAction action);\n    public final void schedule(ScheduleAction action, final long delayTime, final TimeUnit unit);\n}\n\nclass Scheduler {\n    public final Subscription schedule(ScheduleAction action);\n    public final Subscription schedule(ScheduleAction action, final long delayTime, final TimeUnit unit);\n    public final Subscription schedulePeriodically(ScheduleAction action, long initialDelay, long period, TimeUnit unit);\n    <private to ScheduleAction> abstract Inner createInner(); // I would use a friend decl in C++\n    public int degreeOfParallelism();\n    public long now();\n}\n```\n",
        "Thanks @benjchristensen!\n\nWhat prevents this?\n\n```\n        protected void schedule() {\n            if (counter.getAndIncrement() == 0) {\n                ScheduleAction action(scheduler, new Action1<ScheduleAction>() {\n\n                    @Override\n                    public void call(ScheduleAction inner) {\n                        pollQueue();\n                    }\n\n                });\n                action.schedule();\n            }\n        }\n```\n",
        "I would like to pick up these particular points, in-person at React, if possible :) \n\nEDIT: I am 'kirk dot shoop at microsoft com'\n",
        "I would like to see something descriptive in place of inner. If EventLoop is not descriptive, then use SerialQueue or anything else that specifies the behavior of scheduling on the returned object.\nThere will be code that relies on the behavior of the returned object and it should have a name that matches the contract it implements.\nallactionswililberunintheorderthattheyarescheduledoneatatime is too long a name but Inner is not a name at all.\n\nKirk\n",
        "Worker, +1.\n",
        "@kirkshoop, I actually think Inner should have a less prescriptive name.\n",
        "`Scheduler.SerialScheduler` has a bit too much cowbell for my taste.\n",
        "\"After migrating the codebase to this API my impression is: the small surface area of the API is preferable\"\n\nCode speaks.\n",
        "Like!\n",
        "I can live with that. Guess we have a winner then.\n",
        "Threadpool.Scheduler, although not conforming with the reqs above.\n",
        "What about Task?\n\nFeels natural to me to schedule a task, and it also seems to fit your criterias?\n",
        "Along the way as you're mulling over the interface, I'd appreciate any comments on the Scheduler documentation on the wiki: https://github.com/Netflix/RxJava/wiki/Scheduler\n\nAnything missing or misleading? Any areas that need more attention?\n",
        "I like Worker.\n"
    ],
    "6517": [],
    "905": [],
    "1001": [
        "@benjchristensen I'd like to continue contributing to RxAndroid. Do you have some advice on how/who will be maintaining it moving forward?\n",
        "Based on discussion with @headinthebox we will probably move `rx.joins` into a separate module prior to 1.0 since this API does not yet feel finalized. If over time it matures it can be brought back into core in 1.1, 1.2, etc ... but we can't leave things in the core that may need public API changes.\n\n---\n\nCompleted in https://github.com/Netflix/RxJava/pull/1049\n",
        "Removing deprecated methods/classes. A few still remain to be done before 1.0 but can't be done until all operators are migrated:\n- `Observable.OnSubscribeFunc`\n- `Observable.create(OnSubscribeFunc)`\n- `SafeObservableSubscription`\n- `SafeObserver`\n",
        "Migrating operators to using `lift` and `Subscriber` is now the priority for making progress to 1.0. \n\nI will personally be tackling the back pressure prototypes and eventually propose the change via a pull request. This work is being tracked at #1000.\n",
        "Thanks @akarnokd, I really appreciate your help on this. \n\nI believe the `Scheduler` changes are stable (unless someone quickly comes up with a better name for `Inner`). I'm just waiting on @mattpodwysocki to review the changes so we are in sync with RxJS/Rx.Net going forward before releasing 0.18.\n\nOn the topic of migrating all of the operators, I think there are a few things we should nail down as patterns we want to follow so operator implementations are similar (to ease ongoing maintenance).\n\nThings I can think of are:\n- a common, well tuned ring buffer (SPSC)\n  - ring buffers will become useful in the async operators as well once back pressure allows us to be bounded\n- how we apply locking/synchronization\n  - we have various different approaches and styles right now\n  - when should state machines be used?\n  - when should `synchronized` be used?\n  - when should `lock` be used?\n- when should `OnSubscribe` vs `Operator` + `lift` be used?\n- how should error handling be done?\n  - see `map` as an example\n\nPerhaps we should create a README inside the `rx.operators` package meant as an internal coding guide for decisions to these and other things we determine as practices we want to follow?\n\nWhat patterns do you think we should be following to the above questions and others you are considering?\n",
        "Version 0.18.0 was released with the `Scheduler` changes, removal of `rx.joins` and majority of deprecation cleanup.\n",
        "> wrt to backpressure and groing\n\nOnce we implement #1000 there should be very few places left that require unbounded buffers and we can leverage ring buffers even in places such as `observeOn` and `zip`.\n",
        "@akarnokd \n\nThanks for the feedback, I'll take a stab at writing a README to record this for our sake and anyone else getting involved.\n",
        "What use case are you referring to? Operators assume sequential, correct behavior. \n",
        "Answered the specific question on that issue, more generally ... most operators should not need to concern themselves with `unsubscribe` behavior, unless their purpose is to `unsubscribe`, such as `take`. Operators should also be able to assume sequential notifications and contract compliance. The `serialize` operator is for making a source be sequential if it's not. We don't however have anything to force an operator to not emit anything after `onComplete` or `onError`. Some operators will stop functioning after a terminal state (such as `groupBy`) while others will work just fine (like `map`).\n",
        "With the release of 0.18 I am not aware of any further major breaking changes beyond the final removal of the last remaining deprecated signatures (such as `Observable.OnSubscribeFunc`).\n\nThere are a few operators (such as `buffer`) that @headinthebox is reviewing for correctness and possibly change their behavior from Rx.Net (which we have tried to match) based on his experience over the past couple years.\n\nThe goal is that within a few months we can have a stable API and release 1.0 and let the 1.x version live for a long time without further breaking changes.\n",
        "Thanks @alkemist. I don't know enough quite yet to know what to ask for, but once I do I'll update here.\n",
        "For all contributors involved in this ... for a variety of reasons I'd really like to push towards having a 1.0 Release Candidate with the API locked down and all major features/bugs resolved by July 1st. This is only ~5 weeks away, but I intend on focusing as much as I can towards making this happen.\n\nOnce we hit the 1.0RC phase, I expect we'll stay on RC for a while (month or two?) to ensure testing so that 1.0 Final can be considered battle tested.\n\nIssue #1000 is the biggest hurdle to achieving this as all of the other issues seem to almost be resolved.\n\nAs we approach 1.0RC we will also split the major sub-modules into their own top-level projects.\n\nI'd appreciate input on this.\n",
        "> A few issues with rxjava-core is covered by PRs and there seems to be things not properly exposed in Scala, but otherwise the the current standing is okay. \n\nWe can let RxScala continue pre 1.0 if we want? Our intent is to split it out.\n\n> I don't know about the standing with the new computation scheduler.\n\nI think we can get this stuff solved fairly soon and then let it bake for a while. None of that requires API changes though.\n\n> backpressure is a huge undertaking;\n\nIt is indeed non-trivial but we've done enough prototyping that it's not completely unknown. \n\n> most of us need to learn a new paradigm and way of coding, and it will certainly affect all operators.\n\nMoved over to https://github.com/Netflix/RxJava/issues/1000#issuecomment-44449871 for discussion instead of hijacking this issue with a long discussion on backpressure.\n",
        "@headinthebox and I had a chance to review the roadmap together and we intend on pursuing the following:\n- 0.19.0 with the current set of performance, bug and API fixes\n- 0.19.x releases with continued performance/bug fixes, and additive changes to things like RxScala, though core is mostly settled from an API perspective\n- 0.20.x with backpressure\n- split RxScala, RxAndroid, etc into their own top level projects\n- RxJava (core) 1.0 Release Candidate 1 with all deprecated methods and classes removed and the API frozen (only additive changes going forward)\n- as many 1.0 RCs as needed until they stabilize on performance and bugs\n- 1.0 Final once we consider it fully production worthy\n- each of the new top level projects can choose when they wish to hit 1.0 and can diverge on their release schedule and versioning.\n\nThe plan is for the new top-level projects to live at https://github.com/ReactiveX/\n\nThe anticipated first-round of top-level projects extracted from RxJava are:\n- RxScala\n- RxGroovy\n- RxClojure\n- RxJRuby\n- RxKotlin\n- RxAndroid\n",
        "We also plan to move RxJava over. The work on 0.20 has always been planned (#1000) and hopefully will not delay us (previous work on prototypes is what gives me this view). The APIs and core functionality should be able to be locked down on the time frame. I won't be surprised if there are edge cases that keep us iterating on release candidates for a few things once we get there. \n",
        "Version 0.20 with backpressure (#1000) is approaching release worthiness based on Netflix production canaries. I expect to release 0.20 in the next 2 weeks (though I do need confirmation from Android devs before proceeding).\n\nThe intention is to followup shortly after 0.20.0 with 1.0.0-RC1 that will remove all deprecated methods and types. \n\nItems being tracked for 1.0 are in milestone: https://github.com/Netflix/RxJava/issues?direction=desc&milestone=2&page=1&sort=updated&state=open\n",
        "0.20.0 has been released. RxJava has been moved from Netflix to ReactiveX and RxJava has been split out into multiple top-level projects at https://github.com/ReactiveX\n\nRxJava has a 1.x branch and will be the first to release a 1.0 version. All others are currently set to release 0.21.0 versions and each will make their own determination as to when to bump to 1.0.\n\nRxJava has a 0.20.x branch where maintenance releases will be done with everything combined and still on the com.netflix.rxjava Maven Central GroupID. The 1.0 release will happen on the io.reactivex.rxjava GroupID.\n\nIt will likely be a week or two before the 1.0-RC1 release happens as we get all the new build process and GroupID setup as well as update all the build config.\n\nIf any pull requests are submitted to 0.20.x they will also need to be submitted to the individual projects now that we've split. This will have to be done until each of the projects are successfully running on their own. It will be obnoxious for a couple weeks but it's the nature of the transition.\n\nIf any of you have particular interest in one of the projects, please jump in as each of them needs owners and committers beyond me.\n\nThank you all. We're almost to 1.0.\n",
        "Thanks @daschl \n",
        "@dpsm RxAndroid should continue development practices as it has done under RxJava, except now that it is decoupled it can release as it wishes without being tied to the RxJava release cycle and versions. This means it can increment major versions as much as it wants if it needs to do breaking changes.\n\nRight now I'm still the \"committer\" on all of the projects including RxAndroid, but I'm going to be spreading that out so I'm not the gatekeeper on them for much longer.\n",
        "FYI that I'm working with @quidryan on updating the builds on all of the projects and getting the release process setup so it deploys to Maven Central with GroupID io.reactivex instead of the current com.netflix.rxjava GroupID.\n",
        "Deprecations are being removed in #1621 \n",
        "I'd rather not replace `Action0`. The API has worked very well and is consistent by having `Action0`, `Action1`, etc ... instead of `Runnable` (with `run()`) and `Action1` etc (with `call()`).\n\nIt is very rare to be working with `Runnable` directly when using RxJava, and the memory benefit would not be realized anyways since we always wrap the `Action0` in `ScheduledAction` for functional reasons, and it implements `Runnable`.\n",
        "First 1.0 release candidate has been released: https://github.com/ReactiveX/RxJava/releases/tag/v1.0.0-rc.1\n",
        "I just created the project for it: https://github.com/ReactiveX/RxJavaReactiveStreams\n\nIt will be released as artifact rxjava-reactive-streams and depend on rxjava-1.+ and reactive-streams-\\* and have its own release cycle so it can rev however it needs to separate from RxJava itself.\n\nI'm working on getting RxJava 1.0.0 Final and getting the many separated projects building again so likely won't focus on this adapter until after that.\n",
        "My intent is to have a class such as RxReactiveStreams with methods on it converting in both directions. \n",
        "As part of the move to 1.0 I'm considering moving the `join` and `groupJoin` operators from RxJava into RxJavaJoins (https://github.com/ReactiveX/RxJavaJoins) as I don't feel confident they are battle tested.\n\nAnyone have a reason not to do this?\n\n/cc @headinthebox \n",
        "## Status Update: September 19, 2014\n\nBuild and Release: I have been a bottleneck to getting all the split projects released with the new Maven Central io.reactivex IDs using the new build process. Theoretically most projects should be able to get working quickly now that RxJava itself is building and releasing on the new process. The RxScala and possibly RxAndroid projects may have some extra work to achieve their goals.\n\nRelease Candidates: It seems there will need to be some further time on release candidates due to the backlog of items we have accrued as shown here: https://github.com/ReactiveX/RxJava/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0 \n\nThere is also one blocker affecting Netflix production that is not yet identified enough to have an issue opened. We found it while upgrading from 0.19 to 0.20. Canary tests showed that 0.20 worked, but after a longer period of testing we experienced a very hard to identity bug and the symptoms go away when we rollback to 0.19. Due to this and the other open issues linked to above I am not yet confident calling 1.0 \"Final\" as I want the 1.0 release to mean it is stable and can be trusted, even though we will surely have 1.x.y releases with further bug fixes, features and improvements.\n\nMy personal time the past couple weeks has been pulled in different directions as well so I have caused things to slow down. I hope this won't last much longer so I can help get through the final work for 1.0 Final.\n",
        "Builds are now working for the following projects:\n\nhttps://github.com/ReactiveX/RxScala/releases/tag/0.21.1\nhttps://github.com/ReactiveX/RxGroovy/releases/tag/v1.0.0-rc.1\nhttps://github.com/ReactiveX/RxKotlin/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxApacheHttp/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxRoboVM/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxQuasar/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxJavaDebug/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxJavaAsyncUtil/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxJavaComputationExpressions/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxJavaJoins/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxJavaMath/releases/tag/v0.21.0\nhttps://github.com/ReactiveX/RxJavaString/releases/tag/v0.21.0\n\nNot all of them are on Maven Central yet but are on their way. They can be seen on Bintray: https://bintray.com/reactivex/RxJava\n\nThe following are not yet released:\n- RxSwing: due to https://github.com/ReactiveX/RxSwing/issues/4\n- RxJavaFx: https://github.com/ReactiveX/RxJavaFX/issues/3\n- RxJRuby: https://github.com/ReactiveX/RxJRuby/issues/2\n- RxAndroid: https://github.com/ReactiveX/RxAndroid/issues/2\n",
        "RxAndroid has been released on the new io.reactivex artifact: https://github.com/ReactiveX/RxAndroid/releases/tag/v0.21.0\n",
        "@headinthebox and I are targeting November 18th as the release date for RxJava 1.0 Final.\n\nAll blocking issues appear to be resolved as of 1.0.0-rc.5. The next month will be for other bug fixes found while using RxJava 1.0 release candidates and to provide time for testing and usage.\n\nIf anyone has critical bugs or problems with the public API (method or class signatures) please report them now.\n",
        "1.0.0-rc.10 is released with all known bugs fixed and API changes made. There are new features and backpressure work that will continue in 1.0.x (https://github.com/ReactiveX/RxJava/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0.x) but unless we find something we've missed in the next week 1.0.0-rc.10 is either what will release as 1.0.0 or very close to it.\n\nPlease provide feedback on either:\n\na) critical bugs\nb) mistakes in the public API\n\nI would appreciate you trying 1.0.0-rc.10 in your apps to make sure it works.\n\nThank you.\n",
        "I think we're ready for 1.0 Final as of 1.0.0-rc.11. Does anyone know of any reason not to release 1.0 Final on Tuesday?\n\nThere are obviously still bugs, performance improvements we can pursue and functionality to explore and add, but we need to stabilize and commit to the API at some point, so all of that will come in future releases.\n\nIs there anything more that must be done before 1.0 Final?\n\nHere are the near-term milestones:\n- 1.0 https://github.com/ReactiveX/RxJava/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0\n- 1.0.x https://github.com/ReactiveX/RxJava/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0.x\n- 1.1  https://github.com/ReactiveX/RxJava/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.1\n",
        "/cc @zsxwing @samuelgruetter @akarnokd @jmhofer @mairbek @mttkay @mattrjacobs @davidmoten @jbripley @abersnaze @JakeWharton @headinthebox @daschl and anyone else watching this project.\n\nAny reason not to release 1.0 Final in 3 days on Tuesday, November 18th?\n\nHere is the Javadoc with the public API as of 1.0.0-rc.11 http://reactivex.io/RxJava/javadoc/rx/Observable.html\n",
        "@YannRobert @akarnokd #1886 was included in rc.12 and will be part of 1.0\n@zsxwing Thanks for confirming.\n\nI'm proceeding to release 1.0.0\n",
        "@benjchristensen I'm happy to help with any Gradle related stuff.\n",
        "@benjchristensen will 1.0 include reactive stream adapters?\n",
        "Great thanks, I\u2019ll do my best to get it started.\u00a0\n",
        "One more question: when we need to handle the case that the source Observable doesn't obey the Rx contract?\n\nIn my opinion, if `SafeSubscriber` can not help handle the misbehaving Observable, we need to handle it in the operator.\n",
        "The comment from @akarnokd here: https://github.com/Netflix/RxJava/pull/1115#discussion_r12029695\n",
        "I think I should be able to finish the remaining methods of RxScala in 1-2 weeks.\n",
        "~~-1. @benjchristensen I tried to test rc.11. However, it cannot be found in maven. I checked https://bintray.com/reactivex/RxJava/RxJava/1.0.0-rc.11/view/files/io/reactivex/rxjava/1.0.0-rc.11 here and found the pom file didn't publish.~~\n",
        "+1. Tested RxScala with rc12.\n",
        "Scala bindings are just catchup, nothing fundamental, but I think it is fine to start separating the various bindings so they can move at their own pace such that we can stabilize the core.\n",
        "Thanks @zsxwing! \n",
        "The consistency of having `Actioni` is hard to beat. \n",
        "Like!\n",
        "I'd like to start working on these. Is the Scheduler API stable for now, so any changes to it won't require me to rebase? In addition, could you setup an issue with checkboxes dedicated to each remaining operator? \n",
        "Sorry for the delay, but I needed to implement a few operators to establish a pattern for myself.\n\n_Ring buffer_\nWhenever buffering is required with fixed size, and there is only addition and removal, one should use `ArrayDeque` instead of `LinkedList`. Note however that `ArrayDeque` grows by doubling its capacity and may consume extra memory beyond the intended fixed size. Eventually, we might need a custom ringbuffer implementation.\n\n_Locking & Synchronization_\nFor light contention, such as when an observable and a scheduled action races for a shared object, there isn't much difference between the two. Therefore, I prefer using `synchronized` as it is more readable. For heavy contention, state machines with randomized backoffs on CAS failures seem to be the way to go, but implementing such logic is not trivial. So in case a new concurrent operator needs to be implemented, start off by using synchronized blocks to establish the base behavior then let one of the experts rewrite it to a state machine.\n\n_OnSubscribe vs. Lift_\nUse `OnSubscribe` if the operator works as a primary source of events (`from`) or there are many source observables that need to be mangled together (`merge`). Use `lift` if the operator \"modulates\" a primary source of events (`map`).\n",
        "From the JDK source code `ArrayDeque` appears to round up the initial capacity to the next power-of-2 and doubles it everytime it grows. In addition, the usage pattern in RxJava is as follows: add, check-size, remove, i.e., if it is full, it will add the latest item, discover that it has overgrown the expected capacity and remove on item. If the capacity happens top be power-of-two, adding one element doubles the size which is then wasted.\n",
        "A few issues with rxjava-core is covered by PRs and there seems to be things not properly exposed in Scala, but otherwise the the current standing is okay. I don't know about the standing with the new computation scheduler. However, backpressure is a huge undertaking; most of us need to learn a new paradigm and way of coding, and it will certainly affect all operators. Even if I had the time, I couldn't make it under a month, not to mention, in a battle-ready fashion.\n",
        "Before locking the API down, it might worth considering replacing `Action0` with `Runnable` across all use places. Doing this would reduce the need to wrap one into the other in schedulers (and thus less memory allocation) and the API would get a bit closer to Java 8.\n",
        "I think the merge bug needs to be resolved, but otherwise the release can proceed.\n",
        "+1\n\nOn Sat Nov 15 2014 at 10:29:11 PM Michael Nitschinger <\nnotifications@github.com> wrote:\n\n> No objections from my side - we'll then already ship 1.0.0 with 2.0.2\n> first werk of december (currently 2.0.1 is on rc9)\n> \n> Awesome work from all involved :) and special kudos to you @benchristensen\n> https://github.com/benchristensen of course\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/ReactiveX/RxJava/issues/1001#issuecomment-63193374.\n",
        "@akarnokd wrt to backpressure and groing. Shouldn't - if you want to mirror a ringbuffer - the ArrayDequeue or whatever be initalized to the required size upfront so you dont need to grow it? You can preallocate the slots more or less, so you also have less garbage flying around (like with the LinkedList).\n",
        "@benjchristensen so RxJava will be under the netflix org and the others move to ReactiveX? Or do you also plan to move RxJava over.\n\nAlso, does the addition of a 0.20 move the 1.0 RC behind of the originally anticipated schedule?\n",
        "Awesome progress thanks everyone and of course @benjchristensen!\n",
        "No objections from my side - we'll then already ship 1.0.0 with 2.0.2 first werk of december (currently 2.0.1 is on rc9)\n\nAwesome work from all involved :) and special kudos to you @benjchristensen of course\n",
        "Please include the #1886 bugfix by @akarnokd in 1.0\n"
    ],
    "4693": [],
    "1006": [
        "I'm not sure if this is the same issue described above, but we've seen similar issues where using an anonymous function will result in the subscription being GCed because there is only the WeakReference holding it.\n\nThe only fix so far is to hold a hard reference to the subscription in the Fragment or Activity (and consequently unsubscribing in ondestroy) which kind of defeats the purpose of OperatorWeakBinding and bindFragment over fromFragment.\n\nI'm not sure if there's a good solution since holding a hard ref to the subscription usually means holding a ref indirectly to the fragment as well.\ncc @bencodes\n",
        "Ah yes, it's the same as 979 in my case. I'm not sure if that's what @markus2610 is also talking about.\n",
        "If I have understood you correctly, they use fromFragment instead bindFragement, but the method is deprecated.\n",
        "Yes I did mean it.\n",
        "Isn't this similar to #979? (I think it is, and we should discuss possible solutions there)\n",
        "I believe this was fixed due to #1021 so closing. If not, please re-open with details on what is left to do.\n"
    ],
    "1011": [
        "When this gets fixed, restore the `OperatorGroupByTest.testStaggeredCompletion` unit test.\n"
    ],
    "5304": [],
    "688": [],
    "4319": [],
    "5163": [],
    "105": [],
    "1301": [],
    "461": [],
    "3209": [],
    "3317": [],
    "878": [],
    "311": [],
    "2581": [],
    "1044": [
        "Thanks @samuelgruetter for weighing in. Based on the two of you agreeing, I'll merge that change.\n",
        "Closed as I believe the fix was merged.\n",
        "The problem is that there are two interpretations for `o.retry(3)`: `o.retry(retryCount: Int)` or `o.retry.apply(3)`.\n",
        "Maybe we should remove `apply` method from `trait Observable`, considering it's likely to cause such ambiguities without careful attention.\n\n/cc @samuelgruetter\n",
        "Agree with @samuelgruetter .\n",
        "Yes, I'd vote for removing `def apply(index: Int): Observable[T]`, since it's probably not used that often, and `elementAt` is a better, more explicit name.\n"
    ],
    "1532": [],
    "4370": [],
    "4294": [],
    "3640": [],
    "486": [],
    "4647": [],
    "1359": [],
    "4211": [],
    "6223": [],
    "1054": [],
    "4328": [],
    "292": [],
    "5002": [],
    "4093": [],
    "800": [],
    "3407": [],
    "2834": [],
    "5383": [],
    "1090": [],
    "661": [],
    "5309": [],
    "6308": [],
    "6123": [],
    "6530": [],
    "5717": [],
    "5741": [],
    "6145": [],
    "1116": [
        "@headinthebox  and @akarnokd What is the reason for having the `Scheduler` overloads on the `subscribe` methods? I honestly can not remember why that happened. Seems like that should just be using `subscribeOn` and does not need these overloads.\n\nThis is not something we want to leave as is because it breaks Groovy and Clojure.\n",
        "So do I, let's remove them.\n",
        "Yes, a test like that would be good. You interesting in doing it?\n",
        "Thanks, and I'll delete the methods shortly.\n",
        "Never understood why, this it not in .net ... I would junk that overload. Not even sure what it is supposed to do.\n",
        "Looks like a convenience shortcut and we should avoid ambiguity problems with Java 8 while RxJava is in a \"allowed\" API flux. I vote for removal.\n",
        "It also makes it slightly less convenient to use a Java 8 lambda expressions because you need to add the target type to the expression.\n",
        "Would it be worth some tests that reflectively check the public API for any methods that are overloaded with different SAM types (i.e. this problem) to catch this before leaking out again?\n",
        "Sure, I'll do it.\n\nI'll do something for the methods on `Observable`, it could then later be adapted to other applicable types.\n"
    ],
    "876": [],
    "5851": [],
    "421": [],
    "5826": [],
    "1951": [],
    "6778": [],
    "725": [],
    "1762": [],
    "3624": [],
    "6792": [],
    "1141": [
        "Change done in #1208\n",
        "Actually, looking at the implementation again, I missed that the list is copied before being passed to the subscriber.\n\nI think we can fix this in an even simpler way by not using `ArrayList` at all as the internal buffer, but instead use something like `LinkedList`, which is not backed by consecutive memory so the problem does not even exist.\n\nI've update the issue text and title.\n"
    ],
    "1901": [],
    "6856": [],
    "3259": [],
    "4174": [],
    "3117": [],
    "3116": [],
    "3757": [],
    "2237": [],
    "2973": [],
    "2333": [],
    "5522": [],
    "888": [],
    "6744": [],
    "1157": [
        "It looks like changing the generics can get it to compile.\n\nThis compiles:\n\n``` java\n    public static void main(String[] args) {\n        deferB(() -> {\n           return Observable.from(1); \n        }).toBlockingObservable().single();\n    }\n\n    public final static <T> Observable<T> deferB(Func0<Observable<T>> observableFactory) {\n        return Observable.create(new OperatorDefer<T>(observableFactory));\n    }\n```\n\nbut this does not:\n\n``` java\n    public static void main(String[] args) {\n        deferA(() -> {\n           return Observable.from(1); \n        }).toBlockingObservable().single();\n    }\n\n    public final static <T> Observable<T> deferA(Func0<? extends Observable<? extends T>> observableFactory) {\n        return Observable.create(new OperatorDefer<T>(observableFactory));\n    }\n```\n",
        "Yeah that's not okay :-)\n\nI don't understand the co/contra-variance on the current `defer` implementation, especially since it doesn't seem to work.\n\nThis doesn't compile (inside CovarianceTest.java):\n\n``` java\n    @Test\n    public void testDeferCovariance() {\n        Observable.defer(new Func0<Observable<Movie>>() {\n\n            @Override\n            public Observable<Movie> call() {\n                if(true) {\n                    return Observable.from(new HorrorMovie());\n                }else {\n                    return Observable.from(new ActionMovie());\n                }\n            }\n\n        });\n    }\n```\n\nRight now the signature is this:\n\n``` java\npublic final static <T> Observable<T> defer(Func0<? extends Observable<T>> observableFactory);\n```\n\nit seems to work with lambdas when changed to this:\n\n``` java\npublic final static <T> Observable<T> defer(Func0<Observable<? extends T>> observableFactory);\n```\n\nand definitely works with this:\n\n``` java\npublic final static <T> Observable<T> defer(Func0<Observable<T>> observableFactory);\n```\n\nSince type T is just passing through I don't understand what the `? extends` is getting for us, especially since the `Movie` example doesn't work.\n\nCan you help me understand why co/contra-covariance is buying us on this method? If it is not giving us anything then let's remove it so it works with lambdas. If it actually does serve some value, then let's create a new method (no idea what to call it) without co/contra-variance that works with lambdas for the far more common case.\n",
        "Thanks for the feedback. I'm going to change it to:\n\n``` java\npublic final static <T> Observable<T> defer(Func0<Observable<? extends T>> observableFactory)\n```\n",
        "I also confirmed this code works as of Eclipse Luna 4.4M7. It does not work in the Kepler version where it compiles but never actually invokes the Observable inside `defer`.\n",
        "Apparently that's not happy everywhere. \n\nI need to change it to this:\n\n``` java\nObservable<T> defer(Func0<Observable<T>> observableFactory)\n```\n\nor leave it like this:\n\n``` java\nObservable<T> defer(Func0<? extends Observable<? extends T>> observableFactory)\n```\n\nin order for this code to compile:\n\n``` java\n        Observable<String> deferred = Observable.defer(new Func0<Observable<String>>() {\n\n            @Override\n            public Observable<String> call() {\n                return null;\n            }\n\n        });\n```\n\nHave I mentioned before that I don't like dealing with `? extends`/`? super` generics?!\n\nI want to make it like this:\n\n``` java\nObservable<T> defer(Func0<Observable<T>> observableFactory)\n```\n",
        "I really dislike generics. \n\nThe only way to keep these 3 compiling is to leave the code as is:\n\n``` java\n        Observable<Movie> d = Observable.defer(new Func0<Observable<? extends Movie>>() {\n\n            @Override\n            public Observable<? extends Movie> call() {\n                if (true) {\n                    return Observable.from(new ActionMovie());\n                } else {\n                    return Observable.from(new HorrorMovie());\n                }\n            }\n\n        });\n\n        Observable<String> deferred = Observable.defer(new Func0<Observable<? extends String>>() {\n\n            @Override\n            public Observable<? extends String> call() {\n                return null;\n            }\n        });\n\n        Observable<String> deferred2 = Observable.defer(new Func0<Observable<String>>() {\n\n            @Override\n            public Observable<String> call() {\n                return null;\n            }\n        });\n```\n\nBut this doesn't work with Java 8 lambdas.\n\nThe only thing I can think of doing is having a different operator without `? extends` for the simple cases and supported by lambdas ... and leaving `defer` for the complicated ones using anonymous inner classes.\n\n``` java\ndefer(Func0<? extends Observable<? extends T>> observableFactory)\n```\n\n``` java\nsomeOtherName(Func0<Observable<T>> observableFactory)\n```\n\nThen comes the naming challenge ...\n- there is no other overload of `from` that takes a `Func` so we could use that\n\n``` java\nfrom(Func0<Observable<T>> observableFactory)\n```\n- or it could be a `factory`:\n\n``` java\nfactory(Func0<Observable<T>> observableFactory)\n... or ...\nfromFactory(Func0<Observable<T>> observableFactory)\n```\n\nThe type of code this is trying to cater to is like this: https://github.com/benjchristensen/ReactiveLab/blob/master/reactive-lab-edge/src/main/java/io/reactivex/lab/edge/EdgeServer.java#L46\n\n@headinthebox What do you think the right solution is for this?\n",
        "Try compiling that code from Java 8:\n\n```\nlgml-bechristensen:tmp benjchristensen$ /Library/Java/JavaVirtualMachines/jdk1.8.0/Contents/Home/bin/javac -cp rxjava-core-0.18.3.jar TestDefer.java \nTestDefer.java:9: error: method defer in class Observable<T#2> cannot be applied to given types;\n        Observable.defer(() -> Observable.from(1)).subscribe(System.out::println);\n                  ^\n  required: Func0<? extends Observable<? extends T#1>>\n  found: ()->Observ[...]om(1)\n  reason: no instance(s) of type variable(s) T#3 exist so that Observable<T#3> conforms to ? extends Observable<? extends T#1>\n  where T#1,T#2,T#3 are type-variables:\n    T#1 extends Object declared in method <T#1>defer(Func0<? extends Observable<? extends T#1>>)\n    T#2 extends Object declared in class Observable\n    T#3 extends Object declared in method <T#3>from(T#3)\n1 error\n```\n\nThis is with javac 1.8.0_05\n",
        "@akarnokd Since you are following the JDK 8_u20 stuff closer than us, are these problems going to be solved, or do we need to consider reducing support for co/contra-variance so that the normal use cases can work?\n",
        "Looks like August is when it is scheduled for GA release: http://openjdk.java.net/projects/jdk8u/releases/8u20.html\n",
        "As of java version \"1.8.0_11\"\n\n```\nlgml-bechristensen:tmp benjchristensen$ /Library/Java/JavaVirtualMachines/jdk1.8.0_11.jdk/Contents/Home/bin/javac -cp ~/development/github/RxJavaFork/rxjava-core/build/libs/rxjava-core-0.20.0-RC5-SNAPSHOT.jar TestDefer.java \nTestDefer.java:14: error: method defer in class Observable<T#2> cannot be applied to given types;\n        Observable.defer(() -> Observable.from(1)).subscribe(System.out::println);\n                  ^\n  required: Func0<? extends Observable<? extends T#1>>\n  found: ()->Observ[...]om(1)\n  reason: no instance(s) of type variable(s) T#3 exist so that Observable<T#3> conforms to ? extends Observable<? extends T#1>\n  where T#1,T#2,T#3 are type-variables:\n    T#1 extends Object declared in method <T#1>defer(Func0<? extends Observable<? extends T#1>>)\n    T#2 extends Object declared in class Observable\n    T#3 extends Object declared in method <T#3>from(T#3)\nTestDefer.java:23: error: method defer in class Observable<T#2> cannot be applied to given types;\n        System.out.println(Observable.defer(() -> {\n                                     ^\n  required: Func0<? extends Observable<? extends T#1>>\n  found: ()->{ retu[...]2); }\n  reason: no instance(s) of type variable(s) T#3 exist so that Observable<T#3> conforms to ? extends Observable<? extends T#1>\n  where T#1,T#2,T#3 are type-variables:\n    T#1 extends Object declared in method <T#1>defer(Func0<? extends Observable<? extends T#1>>)\n    T#2 extends Object declared in class Observable\n    T#3 extends Object declared in method <T#3>from(T#3)\n2 errors\n```\n\n``` java\nimport java.util.function.Supplier;\n\nimport rx.Observable;\n\npublic class TestDefer {\n    public static void main(String[] args) {\n        rxDefer();\n        javaDefer();\n    }\n\n    public static void javaDefer() {\n        System.out.println(defer(() -> (() -> 1)).get());\n\n        Observable.defer(() -> Observable.from(1)).subscribe(System.out::println);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Supplier<T> defer(Supplier<? extends Supplier<? extends T>> func) {\n        return (Supplier<T>) func.get();\n    }\n\n    public static void rxDefer() {\n        System.out.println(Observable.defer(() -> {\n            return Observable.from(2);\n        }).toBlocking().single());\n    }\n}\n```\n",
        "Still a problem in java version \"1.8.0_20-ea\" ... so we're going to remove the variance on `defer`.\n",
        "Whether variance is nested, the compiler falls over ... :-(\n",
        "Sounds good, with variance you always loose :-(\n",
        "This compiles, but isn't as slick as a one-liner.\n\n``` java\nFunc0<Observable<Integer>> f = () -> Observable.from(1);\nObservable.defer(f);\n```\n\nI can't remember if a similar question was asked on lambda-dev so you could ask about this issue there. Based on similar questions there, I guess this is one of the many limitation of the new type inference algorithm: it can't propagate types anywhere around lambdas.\n",
        "I can't explain this, but googling around indicates this to be a javac and JLS problem. We can remove the `? extends` after the `Func0<`. We have this pattern on several operators so might worth checking them as well.\n",
        "The issue might be with the Java 8 compiler. There are some changes coming up in 8u20 which might affect this for the better. Also, it might be worth posting a question on lambda-dev.\n",
        "This works in Eclipse 4.4M7 for me with RxJava 0.18.3:\n\n``` java\npublic class Test1 {\n    public static void main(String[] args) {\n        System.out.println(defer(() -> (() -> 1)).get());\n\n        Observable.defer(() -> Observable.from(1)).subscribe(System.out::println);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Supplier<T> defer(Supplier<? extends Supplier<? extends T>> func) {\n        return (Supplier<T>)func.get();\n    }\n}\n```\n",
        "I can only be sure once 8u20 is released; I take the upcoming Eclipse's compiler, which doesn't have this problem, is the indicator that the issue should be solved by the next release of javac. However, [this](http://download.java.net/jdk8u20/changes/jdk8u20-b15.html?q=download/jdk8u20/changes/jdk8u20-b15.html) preview build's change notes doesn't seem to mention the issue at hand. I'd say lets keep the current variance set and if the u20 release doesn't come before last week of June, let's change the signatures.\n",
        "Eclipse Luna (4.4) release works as expected. I can't find any ETA on 8u20 but I guess they will release it right after we changed our signature...\n"
    ],
    "4085": [],
    "5626": [],
    "3899": [],
    "3382": [],
    "4579": [],
    "5318": [],
    "4097": [],
    "4419": [],
    "1173": [
        "Closing as #1178 is merged.\n",
        "To be sure, this works:\n\n``` java\npublic class ComeCrash {\n    public static <T> Observable<T> wrap(Observable<T> source) {\n        return Observable.create((Subscriber<? super T> subscriber) -> {\n            System.out.println(\"Subscribed\");\n            subscriber.add(source.subscribe(subscriber));\n        });\n    }\n    public static void main(String[] args) {\n        wrap(Observable.just(1)).subscribe(System.out::println, \n            Throwable::printStackTrace, () -> System.out.println(\"Done.\"));\n    }\n}\n```\n"
    ],
    "6098": [],
    "2961": [],
    "5056": [],
    "1180": [
        "Thank you, that explains the operation. And also shows that the connect is a must, so it is not possible to chain the calls as I did. Then what is the point of having replay() return anything that resembles an Observable? Or is there some autoconnect method too?\n",
        "Ugh, this doesn't look good. Especially in Java if that nop function has no static method creator. Thanks again.\n",
        "Thank you for the support. I'll look at `refCount()`.\n\nAt the same time, I see that the API of `replay()` is exactly the same as the .NetRx version's. So I guess, the semantics is the same in both implementations. But the documentation is very ambiguous in both places. (At least for me as a non-native English speaker.) It says: \"can be connected and disconnected\". It doesn't mention that nothing is going to happen until is is connected because it starts in disconnected state. Nor does `replay()` mention that it starts disconnected. The modifier \"able\" in the ConnectAbleObserver feels like it's just an addition and doesn't change semantics of the Observer interface. But this is not true and it leads to misuse of the API. \n\nProbably an explicit note in the documentation about `replay()` returning a disconnected by default Observer will help solve this confusion.\n\n@headinthebox I know, I usually try to avoid subjects. However, I have a two way causal chain in my case. In one way goes the calculation result, in the other way goes the cancellation. It's possible to implement without subjects but it will not differ much from what subjects already provide and it would break the scope of my signals. Currently every signal is used only inside a single object and it is pretty easy to follow it this way. Also, it makes debugging a lot easier. But thanks for the note.\n",
        "@DavidMGross  Adding that single line to the `replay()` documentation would be enough to spare the headache with the returned connectable observer.\n",
        "@DavidMGross You're awesome! Instead of whining, I should have done it. Fortunately, there is always next time in open source and I love it!\n",
        "> There isn't any simple operator for that\n\nThere is `refCount()` that does auto-connect.\n",
        "Note that if you _think_ you need subjects, there is a 99% chance you can find a more elegant solution that does not require subjects.  Really.\n",
        "`replay()` creates a `ConnectableObservable` which you need to call `connect()` on, otherwise it won't do anything.\n\n``` java\nConnectableObservable co = s.replay(1);\nco.doOnNext(v -> { System.out.println(v); }).subscribe();\nco.connect();\ns.onNext(\"hello\");\n```\n",
        "There isn't any simple operator for that, though there is an enhancement request (somewhere among the issues) to add those variants. The closest auto-connect version is this:\n\n``` java\ns.replay(o -> o, 1).doOnNext(...).subscribe();\n```\n",
        "The wiki documentation is more explicit about the need to call connect():\n\nhttps://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators\n\nOn Fri, May 9, 2014 at 12:00 PM, andrask notifications@github.com wrote:\n\n> Thank you for the support. I'll look at refCount().\n> \n> At the same time, I see that the API of replay() is exactly the same as\n> the .NetRx version's. So I guess, the semantics is the same in both\n> implementations. But the documentation is very ambiguous in both places.\n> (At least for me as a non-native English speaker.) It says: \"can be\n> connected and disconnected\". It doesn't mention that nothing is going to\n> happen until is is connected because it starts in disconnected state. Nor\n> does replay() mention that it starts disconnected. The modifier \"able\" in\n> the ConnectAbleObserver feels like it's just an addition and doesn't change\n> semantics of the Observer interface. But this is not true and it leads to\n> misuse of the API.\n> \n> Probably an explicit note in the documentation about replay() returning a\n> disconnected by default Observer will help solve this confusion.\n> \n> @headinthebox https://github.com/headinthebox I know, I usually try to\n> avoid subjects. However, I have a two way causal chain in my case. In one\n> way goes the calculation result, in the other way goes the cancellation.\n> It's possible to implement without subjects but it will not differ much\n> from what subjects already provide and it would break the scope of my\n> signals. Currently every signal is used only inside a single object and it\n> is pretty easy to follow it this way. Also, it makes debugging a lot\n> easier. But thanks for the note.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1180#issuecomment-42701498\n> .\n\n## \n\nDavid M. Gross\nPLP Consulting\n",
        "Your wish is my command:\n\nhttps://github.com/Netflix/RxJava/commit/50b618e426075ff3267788ccfd1c78c039234bab\n\nOn Fri, May 9, 2014 at 1:08 PM, andrask notifications@github.com wrote:\n\n> @DavidMGross https://github.com/DavidMGross Adding that single line to\n> the replay() documentation would be enough to spare the headache with the\n> returned connectable observer.\n> \n> \u2014\n> Reply to this email directly or view it on GitHubhttps://github.com/Netflix/RxJava/issues/1180#issuecomment-42708058\n> .\n\n## \n\nDavid M. Gross\nPLP Consulting\n"
    ],
    "6913": [],
    "3312": [],
    "744": [],
    "1330": [],
    "1187": [
        "@zsxwing Is this done after merging that PR?\n",
        "The original implementation uses `(action: => Unit)`. Do you think which one is better? I prefer `(action: => Unit)`.\n",
        "OK. I'll take it and add some examples to test the signature.\n",
        "Yes, already fixed.\n",
        "`=>Unit` would be even better. \n",
        "One caveat, to do recursive scheduling we might want to use  the same method as in Java; which does not seem to work with `=>Unit`. \n\n```\ndef random(seed: Int): Observable[Double] = {\n    Observable(subscriber => {\n      val r: Random = new Random(seed)\n      val inner = rx.lang.scala.schedulers.NewThreadScheduler().createWorker\n      subscriber.add(inner)\n\n      inner.schedule(new Function[Unit, Unit]{\n        override def apply(unit: Unit): Unit = {\n          val n = r.nextDouble()\n          subscriber.onNext(n)\n          inner.schedule(apply)\n        }\n      })\n    })\n  }\n```\n",
        "Cool.\n",
        "this is nice :)\n"
    ],
    "3697": [],
    "4791": [],
    "1196": [
        "@zsxwing  Is this done now after that merge?\n",
        "Yes, already fixed.\n"
    ],
    "1888": [],
    "1009": [],
    "3222": [],
    "1204": [
        "@benjchristensen Asked me to contribute a bit to this issue. We've been noticing some issues with RxJava 0.18.x through our use of Hystrix.\n\nLet me setup our use case first to give you an idea of our usage pattern for this particular service. We have a pretty standard public API (think microservice, single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s. This can burst to over 800/s incoming calls without warning.\n\nThe service is on a pretty modest deployment of c1.mediums, but it's also sitting at about 20% CPU normally. Since deploying Hystrix 1.3.16 w/ RxJava 0.18.2, our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb. Additionally, our CPU percentages really start to rise after a few days. This appears to be linked to our latencyTotal_mean times deviating far from our latencyExecute_mean. As you can see below, the command is decreasing in ops/s but the Hystrix overhead is rising. This rise continues for about 5 days to where it's taking anywhere from 20-30ms of Hystrix overhead and the boxes are running near 80-90% CPU.\n\n![Command execution](https://lh3.googleusercontent.com/-rUdmvgGkn0k/U4ah34FBFdI/AAAAAAAAALE/amiC-VBzbV4/s1600/download+%282%29.png)\n\nI took a heap dump of one of the production servers. I can provide it on request, but shown below is a piece I found interesting:\n\n![Subscription objects](https://lh5.googleusercontent.com/-RoOTaW-h358/U4aohtaU4lI/AAAAAAAAALc/93tZ8ScAiG0/s1600/Screen+Shot+2014-05-28+at+9.23.36+PM.PNG)\n\nApproximately 800K Subscriptions were present in the heap dump at the time, which really smells off to me. Even when I forced GCs they were sticking around. See the below, our heap usage was increasing over time:\n\n![Heap usage](https://lh4.googleusercontent.com/-ZSx4hFVpVIg/U4af1dMwdeI/AAAAAAAAAK0/CXCMgBZM67I/s1600/Screen+Shot+2014-05-28+at+8.47.18+PM.PNG)\n\nI started looking at the CompositeSubscription used by Hystrix, and really drilling into it, ran across this:\n\n![CompositeSubscription array](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-compositesubscription.png)\n\nThe subscription array on this has grown to 400K. Perhaps this is an edge case, but I believe that once it falls behind it really struggles to keep up. This would explain the non-linear jump in Hystrix overhead observed in the graph of the command execution time.\n\n``` java\n        State add(Subscription s) {\n            int idx = subscriptions.length;\n            Subscription[] newSubscriptions = new Subscription[idx + 1];\n            System.arraycopy(subscriptions, 0, newSubscriptions, 0, idx);\n            newSubscriptions[idx] = s;\n            return new State(isUnsubscribed, newSubscriptions);\n        }\n```\n\nFor every addition, it's creating a brand new array and copying the new subscriptions into them? Is there a reason behind that? Removals then iterate the entire array and alloc a new array (usually  twice?):\n\n``` java\n        State remove(Subscription s) {\n            if ((subscriptions.length == 1 && subscriptions[0].equals(s)) || subscriptions.length == 0) {\n                return clear();\n            }\n            Subscription[] newSubscriptions = new Subscription[subscriptions.length - 1];\n            int idx = 0;\n            for (Subscription _s : subscriptions) {\n                if (!_s.equals(s)) {\n                    // was not in this composite\n                    if (idx == newSubscriptions.length) {\n                        return this;\n                    }\n                    newSubscriptions[idx] = _s;\n                    idx++;\n                }\n            }\n            if (idx == 0) {\n                return clear();\n            }\n            // subscription appeared more than once\n            if (idx < newSubscriptions.length) {\n                Subscription[] newSub2 = new Subscription[idx];\n                System.arraycopy(newSubscriptions, 0, newSub2, 0, idx);\n                return new State(isUnsubscribed, newSub2);\n            }\n            return new State(isUnsubscribed, newSubscriptions);\n        }\n```\n\nI don't have a misbehaving instance at the moment, but I'd wonder if profiling would show lots of CPU time spent in `remove()`\n\nUnless I'm missing a key factor here, I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.\n\nLet me know if I'm off base here. I'm very interested in helping resolve this issue.\n",
        "Got it.\n\nIn our use case we're doing a `HystrixCommand#observe()` and passing the observable to \n\n``` java\n    public static <T> ListenableFuture<T> toListenableFuture(Observable<T> observable) {\n        final SettableFuture<T> listenableFuture = SettableFuture.create();\n        final AtomicReference<Subscription> s = new AtomicReference<Subscription>();\n\n        s.set(observable.subscribe(new Observer<T>() {\n                                 @Override\n                                 public void onCompleted() {\n                                 }\n\n                                 @Override\n                                 public void onError(Throwable e) {\n                                    listenableFuture.setException(e);\n                                 }\n\n                                 @Override\n                                 public void onNext(T args) {\n                                    if (listenableFuture.isDone()) {\n                                        listenableFuture.setException(new IllegalStateException(\"Observable should only have a single value\"));\n                                    } else {\n                                        listenableFuture.set(args);\n                                    }\n                                 }\n                             }));\n\n        return listenableFuture;\n    }\n```\n\nThis only happens ~50 times a second per server. `CompositeSubscription` is being used by `HystrixContextScheduler#ThreadPoolWorker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen, am I right about this?\n\nIn my heap dump, these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around. I can't seem to identify where the ThreadPoolWorker instance might be getting reused though.\n",
        "If it's helpful, I also found this interesting, which lead me down the path of investigating `CompositeSubscription$State`\n\n![Stack](https://dl.dropboxusercontent.com/u/11103618/Screenshots/rxjava-subremoval.png)\n\nI can put the heap dump on Dropbox and email you a link if it'd be helpful, Ben.\n",
        "@benjchristensen Hystrix 1.3.16 w/ RxJava 0.18.4 has been in prod for about a day now, I'm happy to report a decrease in garbage (and CPU usage in general). I believe the pressure & the suboptimal subscription removal was causing the leak-like behavior. @mattrjacobs's use case matches a few of our own (fan out commands, wait on all), which is likely the source of the large numbers of subscriptions.\n\nI'll keep an eye out for any similar issues that might crop up.\n\nThanks a lot for all the help and dedication to improving RxJava.\n",
        "The `HashSet` change shouldn't kick in though because these aren't generally large lists (handful at most, not hundreds). I expect it's just far too many of them being created.\n",
        "Thanks @daschl I'd appreciate your help. Profiling and identifying hot spots is what we need most right now.\n",
        "> Observable.subscribe (for both Observer and Subscriber)\n\nNot surprised on this. Were you able to identify what the garbage is? \n",
        "We can definitely improve on the `AtomicReference` by using AtomicFieldUpdater. The others will require more effort to analyze along with sample code to see what's triggering them.\n",
        "I went back in history to 0.16.1 to compare performance of the basic `map`/`flatMap` behavior and found that current master is faster. This fits what I had expected of the work of the past couple months, which means it's not an obvious glaring issue (unless my test is completely flawed).\n\nHere is the code for the test:\n- Branch 0.16 => https://github.com/benjchristensen/RxJava/blob/0.16-perf/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java\n- Master => https://github.com/benjchristensen/RxJava/blob/performance/rxjava-core/src/perf/java/rx/usecases/PerfTransforms.java\n\n### Results\n\n#### 0.16\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  2421210.583    68845.966    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     1017.787       73.597    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  2398541.067    90703.197    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5      990.623      100.735    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  4020548.060   262841.500    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    16205.747      352.618    ops/s\n```\n\n#### Master\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s\n```\n\n### GC\n\nOn the master branch test I'm seeing GC results like this:\n\n```\nIteration   5: 3189218.350 ops/s\n          GC | wall time = 5.001 secs,  GC time = 0.047 secs, GC% = 0.94%, GC count = +98\nIteration   5: 9198.700 ops/s\n          GC | wall time = 5.002 secs,  GC time = 0.048 secs, GC% = 0.96%, GC count = +98\n```\n\nversus 0.16\n\n```\nIteration   5: 2420099.017 ops/s\n          GC | wall time = 5.000 secs,  GC time = 0.046 secs, GC% = 0.92%, GC count = +96\nIteration   5: 993.867 ops/s\n          GC | wall time = 5.001 secs,  GC time = 0.100 secs, GC% = 2.00%, GC count = +212\n```\n\n### Summary\n\nUnless I'm mistaken, current code is better:\n- similar GC behavior on `Observable` with 1 item, better GC behavior with 1024 items\n- higher ops/second on all of the map/flatMap tests\n\nI'll start profiling this and improve ... but this does not reveal the source of the problems seen. Possibly it's related to schedulers, or it's a specific operator. I exercised `map`, `flatMap` (and thus `merge`), `Observable` and `Subscribe` here to get the most fundamental ones.\n",
        "The `observeOn` test shows the cost of scheduling ... particularly `Observable`s of a single item.\n\n``` java\n    @GenerateMicroBenchmark\n    public void observeOn(UseCaseInput input) throws InterruptedException {\n        input.observable.observeOn(Schedulers.computation()).subscribe(input.observer);\n        input.awaitCompletion();\n    }\n```\n\n```\nr.u.PerfObserveOn.observeOn        1  thrpt         5   457830.180     9943.221    ops/s\nr.u.PerfObserveOn.observeOn     1024  thrpt         5    14496.430      518.463    ops/s\n```\n\nThus, with an `Observable` of 1 item we can do 457k onNext/second, with an `Observable` of 1024 items we can do 14.8million onNext/second (14.5k \\* 1024).\n",
        "By the way, all testing is just being done on my Mac laptop ... so these numbers are all relative and not representative of proper server hardware.\n",
        "Converting from `AtomicReference` to `AtomicReferenceFieldUpdater` improved performance from this:\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3184873.133   172320.420    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9079.937      343.905    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3411785.677    73767.161    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10860.963      294.309    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  7208334.997   703327.745    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    18720.797      278.529    ops/s\n```\n\nto this:\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3459205.110   124790.906    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9225.037      604.720    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  3639603.060   225599.038    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11135.613      337.022    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  7264202.633   214787.109    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    18795.790      713.668    ops/s\n```\n",
        "> wrapping those Unsafe calles in a PlatformDependent util class.\n\nThis sounds like a valid approach for us. As we mature Rx we'll want to squeeze as much performance out of it as we can, while still remaining portable.\n",
        "Testing with:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.*'\n```\n\n##### May 21st https://github.com/Netflix/RxJava/commit/0efda073f1068b105478145904d788b2206d7c4e\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4597237.797   227193.650    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12334.190      214.479    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4522036.147   216489.787    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    12293.223      321.573    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  9133316.230   303274.438    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    19698.323      150.313    ops/s\n```\n\n##### May 26th https://github.com/Netflix/RxJava/commit/a34cba2bcd96f99e3a0d193009a7ce25775a4ad2\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4367166.623   145506.857    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11382.233      425.976    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4468497.400    83649.115    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    11374.780      780.039    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  8851147.610   303583.393    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    19649.227     1134.279    ops/s\n```\n\nAccording to these results we got slower (though within mean error it appears, so if not slower, then no better).\n",
        "/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk\n",
        "Master branch with /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4378589.533   109056.155    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    10702.953      447.216    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust        1  thrpt         5  4341206.933   184228.619    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingJust     1024  thrpt         5    10961.550      545.574    ops/s\nr.u.PerfTransforms.mapTransformation                 1  thrpt         5  8996983.320   226242.030    ops/s\nr.u.PerfTransforms.mapTransformation              1024  thrpt         5    19423.813      779.759    ops/s\n```\n",
        "Here is a [simple test](https://gist.github.com/benjchristensen/0e821794b0e510e0feed) without JMH (but using same coding pattern) that shows significant increases in throughput from 0.16 -> 0.17 -> 0.18 -> current master branch for this code:\n\n``` java\n    public void mapTransformation(UseCaseInput input) throws InterruptedException {\n        input.observable.map(i -> {\n            return String.valueOf(i);\n        }).map(i -> {\n            return Integer.parseInt(i);\n        }).subscribe(input.observer);\n        input.awaitCompletion();\n    }\n```\n\n##### master\n\n```\nRun: 10 - 10,333,567 ops/sec \nRun: 11 - 10,235,100 ops/sec \nRun: 12 - 10,269,259 ops/sec \nRun: 13 - 10,170,560 ops/sec \nRun: 14 - 10,072,319 ops/sec \n```\n\n##### Version 0.18.3\n\n```\nRun: 10 - 7,973,782 ops/sec \nRun: 11 - 8,695,425 ops/sec \nRun: 12 - 8,283,768 ops/sec \nRun: 13 - 8,283,562 ops/sec \nRun: 14 - 8,270,888 ops/sec \n```\n\n##### Version 0.17.6 (using `OnSubscribe`)\n\n```\nRun: 10 - 7,812,927 ops/sec \nRun: 11 - 7,632,713 ops/sec \nRun: 12 - 7,488,673 ops/sec \nRun: 13 - 7,975,944 ops/sec \nRun: 14 - 7,882,146 ops/sec \n```\n\n##### Version 0.17.6 (using `OnSubscribeFunc`)\n\n```\nRun: 10 - 7,049,700 ops/sec \nRun: 11 - 7,175,042 ops/sec \nRun: 12 - 7,173,240 ops/sec \nRun: 13 - 7,069,685 ops/sec \nRun: 14 - 7,248,320 ops/sec \n```\n\n##### Version 0.16.1\n\n```\nRun: 10 - 4,765,899 ops/sec \nRun: 11 - 4,792,623 ops/sec \nRun: 12 - 4,709,982 ops/sec \nRun: 13 - 4,761,451 ops/sec \nRun: 14 - 4,769,627 ops/sec \n```\n",
        "Well that's odd and doesn't help much when two different ways of measuring are giving contradictory results :-(\n",
        "We captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced.\n\n---\n\nThe biggest allocation hotspot is creating `rx.Subscription[]` from `rx.subscriptions.CompositeSubscription$State.remove(Subscription)` and `rx.subscriptions.CompositeSubscription$State.add(Subscription)`.\n\nThis accounts for approximately 104GB of total allocations within the profile (~30% of total allocation).\n\nThere's also ~1.5GB allocated for rx.subjects.SubjectSubscriptionManager$State split pretty evenly from these 3 methods:\n\n```\n- rx.subjects.SubjectSubscriptionManager$State.createNewWith(SubjectSubscriptionManager$SubjectObserver[])\n- rx.subjects.SubjectSubscriptionManager$State.terminate()\n  - rx.subjects.SubjectSubscriptionManager.<init>()\n```\n\nAnother ~1.2GB of allocations for `rx.subjects.SubjectSubscriptionManager$SubjectObserver[]` from 4 sources:\n\n```\n- rx.subjects.SubjectSubscriptionManager$State.<init>(boolean, CountDownLatch, SubjectSubscriptionManager$SubjectObserver[])\n- rx.subjects.SubjectSubscriptionManager$State.<init>()\n- java.util.Arrays.copyOf(Object[], int) called by rx.subjects.SubjectSubscriptionManager$State.addObserver(SubjectSubscriptionManager$SubjectObserver)\n- rx.subjects.SubjectSubscriptionManager$State.removeObserver(SubjectSubscriptionManager$SubjectObserver)\n```\n\nHere's a list of top allocated rx.\\* objects that exceed 100MB\n(numbers are in bytes):\n\n```\nrx.Subscription[]                                           97,870,643,480\nrx.subjects.SubjectSubscriptionManager$State                1,624,120,080\nrx.subjects.SubjectSubscriptionManager$SubjectObserver[]    1,315,680,480\nrx.subscriptions.Subscriptions$1                            849,212,800\nrx.subscriptions.CompositeSubscription$State                837,518,872\nrx.subscriptions.CompositeSubscription                      641,083,960\nrx.observers.SafeSubscriber                                 637,599,560\nrx.subjects.SubjectSubscriptionManager$SubjectObserver      618,721,656\nrx.Observable$30                                            585,739,968\nrx.operators.SafeObservableSubscription                     568,522,112\nrx.subjects.SubjectSubscriptionManager$1                    545,755,280\nrx.subjects.ReplaySubject$History                           528,269,104\nrx.subjects.ReplaySubject                                   443,043,720\nrx.Observable                                               395,292,296\nrx.operators.OperatorMerge$1$InnerObserver                  370,883,064\nrx.subjects.ReplaySubject$ReplayState                       340,267,192\nrx.Observable$29                                            288,726,208\nrx.operators.BlockingOperatorToFuture$2                     288,463,944\nrx.subjects.SubjectSubscriptionManager                      281,230,064\nrx.subjects.ReplaySubject$3                                 266,953,480\nrx.subjects.ReplaySubject$2                                 260,071,464\nrx.operators.BlockingOperatorToFuture$1                     256,919,568\nrx.subjects.SubjectSubscriptionManager$1$1                  245,468,584\nrx.subjects.ReplaySubject$1                                 238,637,944\nrx.operators.OperatorCache                                  147,967,240\nrx.observers.Subscribers$1                                  132,742,032\nrx.subscriptions.BooleanSubscription                        107,733,248\nrx.Observable$2                                             105,170,440\n```\n",
        "@Xorlev Thanks for the detailed post, very helpful to have another set of clues beyond what we've been seeing.\n\n> I'd think HashSet would be much more performant in this context for O(1) lookups & removals. I can't imagine that the overhead of the set entries would be more than memory copies. At the very least, an ArrayList would cut down on allocs & copies.\n\nFor the use cases we appear to be triggering, definitely yes. This is partially what @akarnokd was seeking to solve in https://github.com/Netflix/RxJava/pull/1145. \n\nWhen we designed the current implementation of `CompositeSubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `Subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks, and that the extra object allocations to allow use of compareAndSet was okay. \n\nPerformance testing we've done has shown this to be a win (in the cases we've been testing) but obviously there are cases where this is breaking badly.\n\nSo, we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155)), but right now I'm still trying to identify the use cases that are causing this.\n\n> What is worrying is that there is an unsubscribed CompositeSubscription with a non-empty array. When unsubscribed, CompositeSubscription should drop the entire array and don't accept any new additions. Could you tell where that CompositeSubscription is embedded?\n\nThis is an open question. We see the same symptom in our production environment, though not sure if it's an actual leak, or just such high pressure that the GC can't keep up so it looks like they are leaking.\n\nResearching further today ... \n",
        "> `HystrixContextScheduler#ThreadPoolWorker`\n\nYes, that is just a thin wrapper around a real `Scheduler` used by Hystrix to copy state across threads. It is allocated for each command.\n\n>  these 400,000-long arrays of Subscriptions seem to be actively being recycled and used, so somehow those CompositeSubscription instances are sticking around\n\nThat is the key problem I'm trying to find today. I'm going to focus on the Hystrix use cases since it's the one that triggers it. Seems it is either a bug in how Hystrix is using Rx, or it's triggering a bug or unexpected use case in Rx that we need to handle.\n",
        "That is helpful. It points to looking at the `EventLoopScheduler`.\n",
        "This is creating lots of `ArrayList` instances unnecessarily: \nhttps://github.com/Netflix/RxJava/blob/0.18.2/rxjava-core/src/main/java/rx/subscriptions/CompositeSubscription.java#L172\n\n![screen shot 2014-05-29 at 10 35 48 am](https://cloud.githubusercontent.com/assets/813492/3120998/b281d270-e757-11e3-82f4-0c4fb645e6a7.png)\n![screen shot 2014-05-29 at 10 37 45 am](https://cloud.githubusercontent.com/assets/813492/3121021/f843b5a8-e757-11e3-83c5-b18f251952d9.png)\n",
        "![replaystate-arraylist-object](https://cloud.githubusercontent.com/assets/813492/3121057/4f67c9dc-e758-11e3-8f4b-8e9e9c12372c.png)\n",
        "![hystrix rx-with-0 18 2](https://cloud.githubusercontent.com/assets/813492/3121117/ec086eae-e758-11e3-9d54-43bb8b647199.png)\n",
        "Those were from 0.18.2 ... now with Master, plus a [modified](https://gist.github.com/benjchristensen/541c2dbb5fca94ee4155) `CompositeSubscription` we get this:\n\n![hystrix rx-with-master new-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121129/1ce1746c-e759-11e3-918c-4d6e97c92dc2.png)\n",
        "Here is evidence for need of work on `ReplaySubject`:\n\n![replaysubject-1](https://cloud.githubusercontent.com/assets/813492/3121171/8a1b7a6e-e759-11e3-85bc-270167719e34.png)\n\n![replaysubject-2](https://cloud.githubusercontent.com/assets/813492/3121172/8cd26e02-e759-11e3-9544-70f900a80890.png)\n\n![replaysubject-3](https://cloud.githubusercontent.com/assets/813492/3121174/8f90fa46-e759-11e3-8680-898da7e2b3a9.png)\n",
        "![0 18 2-map observeon](https://cloud.githubusercontent.com/assets/813492/3121261/76d1a61c-e75a-11e3-82c4-96e59ac1ddfa.png)\n\n![master-map observeon](https://cloud.githubusercontent.com/assets/813492/3121263/7b1c9600-e75a-11e3-96a7-56e30df059cf.png)\n",
        "The `Subscription[]` issue is definitely being caused by the use of a `Scheduler`. Here is some evidence:\n\n![subscription-array-when-using-scheduler](https://cloud.githubusercontent.com/assets/813492/3121292/c1c39f54-e75a-11e3-97b9-5ba75cdb040b.png)\n\nThen the master branch with `CompositeSubscription` change:\n\n![screen shot 2014-05-29 at 10 58 09 am](https://cloud.githubusercontent.com/assets/813492/3121303/d65be0fc-e75a-11e3-8902-5f9ead818735.png)\n\nThe issue is definitely the `CompositeSubscription` as the following shows where it is master as it currently stands without my changes to `CompositeSubscription`:\n\n![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3121347/3f171634-e75b-11e3-9246-aff40bf88eeb.png)\n",
        "I have submitted a pull request for this: https://github.com/Netflix/RxJava/pull/1281\n\nWe are testing the code in our environment shortly.\n",
        "For anyone wanting to dig into this, Java Flight Recorder has been very helpful, and far better than the other profiling tools I've used and tried for this.\n",
        "Backporting to 0.18.x in https://github.com/Netflix/RxJava/pull/1283\n",
        "Thanks @chrisjenx ... it looks like the most glaring issues are resolved, and low hanging fruit taken care of. There are a few other things for us to improve on, but I think we'll release 0.19 early next week. I would appreciate your feedback on whether you see an improvement.\n\nI have also opened https://github.com/Netflix/RxJava/issues/1299 to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions.\n",
        "@akarnokd Is there anything else that stands out to you that we should fix before closing this issue? I'll continue doing some profiling but it seems the obvious ones are done.\n\nWe'll continue working on performance going forward and those can have their own issues and pull requests, so if nothing else obvious stands out let's close this issue and not leave it open-ended.\n",
        "I think that the object allocation penalty of resizing after a terminal event would be worse.\n\nA cache() overload that takes a capacity hint may be valuable, particularly in the single item case where it could just a single volatile ref instead of an array.  \n",
        "I have opened a new issue for the cache() overload: https://github.com/Netflix/RxJava/issues/1303\n",
        "I'm closing this issue out as I believe we have handled the most glaring problems and don't want this to be a never-ending issue. We will of course continue seeking to improve performance, but let's use individual issues for each improvement/problem we find.\n\nThanks everyone for your involvement on this one as it was rather significant and important.\n\n@Xorlev and @daschl I would appreciate feedback once you've had a chance to try the changes in the master branch (or the portion that was backported to 0.18.4) to know if you see the improvements or still have issues. @Xorlev In particular I'd like to know if the issue you had was only the GC pressure, or if you still see signs of a memory leak (which I have not seen yet).\n",
        "Excellent. Thank you @Xorlev for the confirmation. I'll release Hystrix 1.3.17 in a few days hopefully with RxJava 0.19 as a dependency, and at least one performance optimization I found I can do in Hystrix directly.\n",
        "Superb work guys, I've held off on 18.x on Android as I noticed an increase in GC, really glad you guys take this seriously!\n",
        "The most likely source of garbage is the `CompositeSubscription`: whenever a task is scheduled or a new merge-source appears, the state transition creates a new State object and copies the subscription array. PR #1145 reduces the amount of garbage by switching to HashSet on a larger composite. Since flatMap->mergeMap->merge needs to track the active inner subscriptions, it uses a composite as well and would gain the same benefits.\n",
        "I think that many `AtomicReference` come from mostly the `CompositeSubscription` instances.\n",
        "I've been experimenting with FieldUpdaters and Unsafe for the `SerializedObserver`. It seems that by using Unsafe directly and thus avoiding security checks and an indirection, I can get about 8-10% more throughput. The downsides are that it is scheduled to be removed/standardized in future Java versions and platform dependence in terms of availability. Should I pursue the Unsafe path?\n",
        "Which Java version is this? Java 6 intrinsics isn't as good as the newer versions. Maybe the `wip` field in the merge operator causes more false sharing and needs padding.\n",
        "I run some benchmarks with `AtomicInteger` and `volatile int` inside merge and it appears that JMH benchmark gives 10% more throughput with `AtomicInteger`.\n",
        "Thanks for the details. CompositeSubscription becomes very slow when it grows over the size of the cache line in the CPU and constant add/remove is happening (see #1145).\n\nSubscriptions$2 is perhaps the wrapper for Future, which keeps a final reference to the Future object, which generally shouldn't be a problem if its parent container is removing/clearing it.\n\nWhat is worrying is that there is an unsubscribed `CompositeSubscription` with a non-empty array. When unsubscribed, `CompositeSubscription` should drop the entire array and don't accept any new additions. Could you tell where that `CompositeSubscription` is embedded?\n",
        "The history List in ReplaySubject; since ArrayList uses more memory then actual items, it might be worth compacting it on a terminal state (one time, but might be costly and run out of memory). Alternatively, it could use fixed increment expansion strategy. Third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space.\n",
        "I'll also like to help out here, since its crucial for our uses as well. \n",
        "I did some GC profiling of my test workloads and I'd also like to nominate:\n- BlockingObservable (it seems that especially in the .single() case its not optimized)\n- Observable.subscribe (for both Observer and Subscriber) - in my GC logs they take up 40% of the overall GC pressure.\n\nThe bad news is that i had to fall back out of Observables to plain execution on the hot code path (aside from the overall wrapping observable), because also using it in the path produces way too much garbage (moving away from Rx in the hot code path got my throughput from 20% to 80% according to the GC logs) and it correlates with my findings since I could not sustain constant IO throughput because of full GCs happening way too frequently.\n",
        "I did some changes in my code and will re-profile and post the results here so we get better measurements. \n\nHere is a slightly older profile run which might give you a hint or two.\n![screen shot 2014-05-20 at 10 13 10](https://cloud.githubusercontent.com/assets/29086/3024320/a10a2a64-dff6-11e3-8f2c-3473bdfc7af7.png)\n![screen shot 2014-05-20 at 10 13 00](https://cloud.githubusercontent.com/assets/29086/3024319/a1096bba-dff6-11e3-9c92-0177913e5c47.png)\n",
        "@benjchristensen I suppose the `AtomicReferenceFieldUpdater` mostly comes from less GC pressure, is that why the raw throughput increases in your tests? How did the GC wall time change?\n",
        "If you want me to run a specific workload/type of test let me know so we can compare results.\n",
        "@akarnokd since RxJava also runs on android, I'm not sure how good/standard the support is there.\n\nI know that the netty folks are having the same issues and they are wrapping those Unsafe calles in a PlatformDependent util class.\n",
        "Very good progress! I'll get back to profiling from master next week.\n",
        "I've added some logging to our production instances and discovered that the cause of large Subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `HystrixCommand`s, calls `observe` on them, puts them in an ArrayList, and finally calls `Observable.merge` on this list to have a single place to listen for overall completion.\n\nThis seems like a valid case to support and any work which improves performance for large Subscription arrays would be a meaningful improvement.\n"
    ],
    "965": [],
    "828": [],
    "498": [],
    "1148": [],
    "910": [],
    "5863": [],
    "1218": [
        "Done in https://github.com/Netflix/RxJava/pull/1504\n",
        "Use `Collections.unmodifiableList`? I think `toList` only needs to emit an immutable list.\n",
        "> Perhaps a better internal list implementation other than LinkedList or ArrayList that gives us the contiguous memory and can grow as needed like ArrayList, but doesn't grow unnecessarily or allocate more memory than needed in standard cases (such as an Observable of length 1).\n\nI think which is better depends on the use case. Is it worth to add a `toList` overload like `toList(Func0<? extends List<T>> listFactory)`?\n",
        "Just for some background on why I made the change: it wasn't due to the use of `ArrayList` per se, but due to it using the default constructor which uses a platform dependent initial capacity. Since on Android this capacity is zero, the behavior was inefficient.\n"
    ],
    "1219": [
        "As far as I am concerned, the needs I have is:\n- I have to serialize all my Bluetooth Low Energy communications on Android and requests can come from multiple threads, I'd like my observables to be scheduled one after the other.\n- In [cgeo](https://github.com/cgeo/cgeo), I do not want more than 5 (or 10) concurrent HTTP download connections from Android, as I download large images and the memory pressure will be too high if I download more of them at the same time.\n\nIs there a way to achieve those two goals easily without an executor?\n",
        "My understanding of `ForkJoin` is that it would still have the same need for us to manage a queue externally, otherwise it will process the items on multiple threads concurrently if we put them into the `ForkJoin` queue.\n",
        "That all sounds right except the \"blocking until the Worker() completes\" part. That would okay in Quasar, but not with native threads. It will need to behave like `observeOn` where it releases the thread (think of it as an event loop) and then reschedules back on a thread the next time it receives an `onNext`.\n\nSee observeOn here: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java#L98\n",
        "All interested in this, please try out the new implementation via `Schedulers.newExecutor` as implemented by @akarnokd in https://github.com/Netflix/RxJava/pull/1272. \n",
        "Should we rename `Schedulers.newExecutor` to something else? Reason I'm asking is that it doesn't actually create a new `Executor` like `newThread` does. It is a new `Scheduler` around a given `Executor`. Perhaps it is instead `Schedulers.fromExecutor(Executor e)` or just `Schedulers.executor(Executor e)`?\n",
        "I believe this is done so closing out. \n",
        "I like `Schedulers.from(Executor e)`\n",
        "@benjchristensen you've probably already investigated but does any of the quasar work help or the backported `ForkJoin` for JRE6?\n",
        "@benjchristensen your right....\nSo idea I have at present. Is you spawn a new `SerialExecutor` for each worker. \n- Pass in a Executor into the Scheduler.\n- Create `Worker()` this creates a `SerialExecutor` that _sits on_ a Thread from the passed in Executor.\n- Process through all the actions, blocking until the `Worker()` completes.\n- Complete and return the Thread back to the pool.\n\nNot sure if that would actually solve the problem, but from my understanding, is that we always need to serially execute queued up actions on any one worker.\n",
        "@benjchristensen yeah OK that makes sense.\nI still think it should be noted that people should try to avoid `Executors` where possible. It should be a \"when you really have too\".\n",
        "@samueltardieu This high jacks the issue somewhat but, the `Computation` Scheduler only runs as many concurrent threads as there are cores on the device. (2-4) for most Android Devices.\n\nThe whole point of the new Schedulers is that they execute in order which Executors are not guaranteed to do.\n\nI would use either an IO or Trampoline Scheduler for your BTLE Comms, (Also remember to Bind the `Observable` if you're passing it off to the UI thread @mattias provided that one). \nAs for HTTP; Either use Computation Scheduler or Your own Scheduler, we solved the problem in Retrofit by using the Executor in the `onSubscribe()` method. See [RxSupport](https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/RxSupport.java).\n",
        "@akarnokd I quite like that idea, keep the main lib lean. I'm sure a _contrib-concurrency_ would not be overkill.\nI mean I always use Proguard so bloat isn't so much of an issue for me, but it's great you guys are thinking about it.\n",
        "I guess we need to make sure executing a tasks by the same worker shouldn't hop threads, right? I see a few problems:\n- Generally, threads can die from executing non RxJava tasks and get replaced by fresh threads so thread \"hopping\" is more likely to occur than with the standard schedulers.\n- Since most executors use a single work queue, work might be dequeued by any of the threads. Even if a work item can tell where it should run, one would need some mechanism to toss the work over to the target thread, at which point task reordering can happen. \n  - Maybe a write-cursor and read-cursor pairs may help; plus each worker thread needs dedicated queue with every instance of Scheduler.Worker assigned to it. These queues may then be processed round-robin.\n  - Even if this worker thread affinity is established, one would need constantly running tasks that poll these queues or blocking ones that get unblocked by yet another queue. Since we don't know how many threads there are in the Executor, it becomes difficult to schedule such processing routines if necessary, and even so, they will block out other tasks submitted from elsewhere to the same Executor.\n\nBottom line is, in my opinion, that there aren't any good ways to ensure worker affinity on an Executor whose internal threads and queueing we can't control.\n",
        "There have been a few PRs proposing a Scheduler with fixed thread count and another with thread-caching support. The latter can be extended to put an upper limit on the active thread count if necessary. But unfortunately, these efforts are blocked on the enhancement quest to add load-balancing to the base computation scheduler and the usual concerns about API size and features to expose. I've been fiddling with an idea for some time to ask for a contrib-experimental module where all these \"outcasts\" and other stuff may be put.\n",
        "@headinthebox +1 very consistent!\n",
        "-keep class rx.internal.util.*\\* { *; }\n add it in proguard to resolve few problems\n"
    ],
    "1220": [
        "I also vote no. `BlockingObservable.from()` is sufficient and avoids auto-complete-induced temptation. Ideally if you need blocking, it's in a single, generic spot so it shouldn't even come up that often.\n",
        "We specifically chose the explicit and long name `toBlockingObservable` so people are fully aware of what they're opting into. We also consciously moved all of the blocking operators out of `Observable` into `BlockingObservable` so it is very clear what operators are blocking and which are not.\n\nYou can however use `BlockingObservable.from(o)` which would be the same as `BlockingUtils(observable)`.\n\nThe `await` name isn't quite right, as the method itself is not awaiting anything, it's just giving access to the blocking methods that would await. \n\nWe could suggest to the broader group to alias something shorter like `.blocking()` or `.toBlocking()` to `.toBlockingObservable()`. Then it would be like this:\n\n``` java\nSystem.out.println(bucket.get(\"hello\").blocking().single());\n```\n",
        "@headinthebox @akarnokd @abersnaze @zsxwing Any issues with aliasing `.toBlocking()` for `.toBlockingObservable()` to keep it shorter?\n",
        "@daschl won this one :-)\n\nWe have deprecated `toBlockingObservable()` in favor of `toBlocking()` which is less annoying to use while still being clear, and will better match the pattern with `toParallel()` that will come one day when I get around to it.\n",
        "See https://github.com/Netflix/RxJava/pull/1233 for the change.\n",
        "`toBlocking` +1\n",
        "I vote no, strongly. Autocomplete will type it for you. And as Ben says, it should be there as a blinking danger sign to war you that you are doing something unsafe. That why in Haskell unsafePerformIO has such a long name. \n\nIf you want to make it shorter, I propose .BLOCKING(), all caps.\n",
        "+1 for Alias, `toBlocking()` and `toBlockingObservable()` \n",
        "@daschl I think it needs to remain clear that its is _to_ a blocking Observable, as `blocking()` to me implies its an operator, which it is not.\n",
        "`.toBlocking()` is fine with me.\n",
        "@benjchristensen wdyt?\n",
        "@benjchristensen makes sense! I really like `.blocking()` it is much more concise. Can you bring that to a vote?\n",
        "@chrisjenx what do you think about  just `blocking()`?\n",
        "I submitted a (simple) PR for this in case we get consensus.\n",
        "@headinthebox not sure I can follow. While I can understand that it breaks the idea of async flows, lots of applications, sooner or later at the end of the chain will fall back to blocking so they can return it to a servlet or whatever.\n\nI don't think we should make it hard on people, sync programming is a legit concept, even if it is not as powerful as Rx.\n",
        "@benjchristensen thanks for taking care of it. My users will appreciate it.\n"
    ],
    "4352": [],
    "239": [],
    "1335": [],
    "6512": [],
    "6081": [],
    "4891": [],
    "4616": [],
    "1243": [],
    "4354": [],
    "5898": [],
    "5219": [],
    "6599": [],
    "4619": [],
    "5017": [],
    "518": [],
    "5367": [],
    "4513": [],
    "1033": [],
    "3507": [],
    "2770": [],
    "4361": [],
    "4919": [],
    "6273": [],
    "2471": [],
    "1577": [],
    "1109": [],
    "224": [],
    "5804": [],
    "2814": [],
    "2648": [],
    "3": [],
    "3220": [],
    "3257": [],
    "120": [],
    "4555": [],
    "3780": [],
    "4430": [],
    "3501": [],
    "457": [],
    "5538": [],
    "4815": [],
    "1092": [],
    "6255": [],
    "3416": [],
    "4900": [],
    "3842": [],
    "185": [],
    "4819": [],
    "6764": [],
    "5015": [],
    "5351": [],
    "280": [],
    "4757": [],
    "5252": [],
    "1146": [],
    "2950": [],
    "3193": [],
    "485": [],
    "5476": [],
    "1289": [],
    "5843": [],
    "2593": [],
    "6809": [],
    "2456": [],
    "1052": [],
    "3622": [],
    "803": [],
    "236": [],
    "465": [],
    "253": [],
    "1832": [],
    "824": [],
    "157": [],
    "1383": [
        "/cc @akarnokd @headinthebox\n",
        "Please take a look at an exploration of this in https://github.com/Netflix/RxJava/pull/1384\n",
        "I have created a 'SynchronizedSubscription' for internal use right now. We also have the 'unsubscribeOn' operator, but I have not proven to myself yet that it is all 100% correct. \n",
        "Yes, I could canary this, but the types of issues that this could cause probably would not be easily seen in our environment since it is still mostly request/response and an unsubscribe being missed wouldn't severely affect anything (it would just get filtered out by take for example). Where we do use streams they are infinite and thus never exercise the unsubscribe. \n",
        "Yes I'll need to review those. \n",
        "I've been spending more time on this and it definitely appears to consistently help performance. The one area where I think this change makes us vulnerable is in this signature:\n\n``` java\npublic Subscription subscribe(Subscriber s)\npublic Subscription subscribe(Observer s)\n```\n\nI propose changing these to:\n\n``` java\npublic void subscribe(Subscriber s)\npublic void subscribe(Observer s)\n```\n\nReturning the `Subscription` is useless on synchronous streams, and on asynchronous streams it requires synchronization on `unsubscribe` for the rare occasion someone uses it. I can't figure out a way to do that protection only when it's used without wrapping the Subscription with a SynchronizedSubscription. This adds another object allocation per subscribe that significantly impacts some benchmarks (tight loop of observable.create.subscribe).\n\nIs there any reason (other than being a bad breaking change) for keeping the `Subscription` return? We almost removed them when we did 0.17, but kept them just to not do the breaking change.\n\nCan we keep them without impeding performance?\n",
        "@DylanSale Thanks for helping on this. I'm pretty certain we can't do this change as it is a very significant breaking change for this late in the game. Putting that aside, on your use case, would it work if you use `takeWhile` or `takeUntil` instead of capturing all of the subscriptions? In short, something like this:\n\n``` java\nsomeObservable.takeUntil(activityDestroyed).subscribe(s)\n... or ...\nsomeObservable.takeWhile(activityIsActive).subscribe(s)\n```\n",
        "I did some further testing on different approaches and here are the results (manually formatted to make it more readable while comparing):\n\n```\n                                                             non-volatile           volatile        synchronized     synchronized   AtomicIntegerFieldUpdater\n                                                          SubscriptionList  SubscriptionList    SubscriptionList   SafeSubscriber            Subscriptionlist\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBaseline without RxJava:\n\nr.PerfBaseline.iterableViaForLoopConsumption            1      248,286,785 loops over iterable of 1 item consumed into Observer.onNext\nr.PerfBaseline.iterableViaForLoopConsumption         1000          182,798 loops over iterable of 1000 items consumed into Observer.onNext\nr.PerfBaseline.iterableViaForLoopConsumption      1000000              172 loops over iterable of 1,000,000 items consumed into Observer.onNext  \n\nr.PerfBaseline.iterableViaHasNextConsumption            1      325,036,745\nr.PerfBaseline.iterableViaHasNextConsumption         1000          298,493\nr.PerfBaseline.iterableViaHasNextConsumption      1000000              268\n\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n                                                             non-volatile           volatile        synchronized     synchronized   AtomicIntegerFieldUpdater\n                                                          SubscriptionList  SubscriptionList    SubscriptionList   SafeSubscriber            Subscriptionlist\n---------------------------------------------------------------------------------------------------------------------------------------------------------------                                                       \nFastest we should expect from RxJava. Single Observable subscribed to repeatedly via `unsafeSubscribe` without any wrapping (new Subscriber each time):\n\nr.PerfBaseline.observableConsumptionUnsafe              1      121,447,376        66,666,838         121,434,744      122,254,109                  68,761,481\nr.PerfBaseline.observableConsumptionUnsafe           1000          318,131           319,493             318,508          320,140                     318,099\nr.PerfBaseline.observableConsumptionUnsafe        1000000              315               308                 314              315                         315\n\nr.PerfBaseline.observableViaRangeUnsafe                 1      230,223,319        96,690,586         223,722,344      230,588,005                  99,951,920\nr.PerfBaseline.observableViaRangeUnsafe              1000          310,078           297,840             231,158          311,091                     309,594\nr.PerfBaseline.observableViaRangeUnsafe           1000000              280               268                 200              267                         246\n\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n                                                             non-volatile           volatile        synchronized     synchronized   AtomicIntegerFieldUpdater\n                                                          SubscriptionList  SubscriptionList    SubscriptionList   SafeSubscriber            Subscriptionlist\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nr.PerfBaseline.observableConsumption                    1       54,346,582        29,219,633          37,542,983       32,687,078                  26,254,636\nr.PerfBaseline.observableConsumption                 1000          246,747           231,651             266,484          245,754                     246,173\nr.PerfBaseline.observableConsumption              1000000              252               237                 259              249                         251\n\nr.PerfBaseline.observableViaRange                       1       55,475,749        29,832,040          34,142,305       32,975,147                  29,737,054\nr.PerfBaseline.observableViaRange                    1000          255,971           234,519             168,015          214,055                     255,824\nr.PerfBaseline.observableViaRange                 1000000              222               214                 170              174                         226\n\n\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n                                                             non-volatile           volatile        synchronized     synchronized   AtomicIntegerFieldUpdater\n                                                          SubscriptionList  SubscriptionList    SubscriptionList   SafeSubscriber            Subscriptionlist\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1        8,598,036         8,221,514           8,324,789        8,587,566                   7,908,497 \nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000           81,244           11,1945              98,456           81,036                      81,396 \nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000               72                78                  64               75                          73 \n\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1          102,689           105,055             103,722          103,979                     101,734 \nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000                8                 8                   5                8                           8 \n\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1       10,586,891         9,149,101           9,365,997        9,961,394                   9,045,580 \nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100        1,139,139         1,060,454             962,148        1,134,602                   1,051,191 \nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000           95,961            99,052              79,349          101,080                      98,040 \n\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1        9,794,588         8,852,408           9,040,839        8,803,122                   9,054,888 \nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000               83                82                  74               72                          83 \n\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1           81,126            81,421              81,029           81,481                      80,370 \nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000            5,837             5,670               3,808            5,721                       4,873 \n\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1        9,195,390         7,852,711           8,360,268        8,650,547                   8,238,710 \nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000           77,743            75,857              70,337           79,576                      76,601 \nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000               79                79                  73               71                          79 \n```\n\nConsidering it as unlikely that we can make the necessary changes to allow a `Subscription` to not be thread-safe, it seems that using `synchronized` instead of `volatile` is better in most situations, though all of the alternatives I pursued obviously have a performance penalty.\n\nUnless we make a design change that removes direct use of `Subscription.unsubscribed` and pushes those use cases to `takeWhile`/`takeUntil` and other such operators, I think `Subscription` needs to ensure thread-safety.\n\nIt can not be hidden inside something like a `createUnsafe`, because the `create` has nothing to do with the `Subscription` which is passed into it at subscription time. The issue is that the `Subscription` is given back to the user where by definition if they call `unsubscribe`, it is happening from a different thread, and since `isUnsubscribed` is checked inside tight loops, it must be at least volatile to ensure visibility of changes across threads and comes with the cost.\n\nDoes anyone disagree with my assessment and testing above? Is there a better alternative I'm not considering?\n\n(I can give the raw JMH results if interested. And sorry about the wrong post that I posted then deleted ... and the closing/reopening of this issue ... fat fingered it).\n",
        "By the way, the tests I included above show two different perspectives of RxJava. The `PerfBaseline` ones are showing the fastest possible use cases of RxJava with just the overhead of `Observable` and `Subscriber`. I then include `merge` since it commonly is used via `flatMap`. \n\nThe results show `merge` is impacted far less by this decision, primarily because there is already quite a bit of overhead in doing merge, and all the bookkeeping and concurrency it naturally has. Due to this, the impact of `volatile` is hardly noticeable. \n\nThe point of this issue is to present and discuss the impact of requiring a thread-safe `Subscription` for pipelines that are trying to be as fast as possible, pure pub-sub, or simple `map` transformations, without going through anything \"heavy\" like `merge`, `flatMap` or `observeOn`.\n\nIdeally, if I could go back in time, I think I would change the signature of `Subscription subscribe(Subscriber s)` to `void subscribe(Subscriber s)` and say that `takeWhile` and `takeUntil` are the general approach to handling `unsubscribe`, or calling `unsubscribe` directly from within `Subscriber.onNext`, but rarely or never \"from the outside\" like we allow by returning a `Subscription`.\n",
        "It makes a lot of sense to make the same assumptions for subscribers and observers, and only synchronize in operators like `observeOn` and `subscribeOn`. In fact, I kind of hit myself in the head for not observing this (pun intended).\n\nOne question, is there something like `.serialize` that users can apply to synchronize access.\n\nWould you be able to release this as a canary in production? \n",
        "Makes sense. \n\nSchedulers are another place where both subscriptions and concurrency exist.\n",
        "Mmmm, need to think about this. I do unsubscribe when I subscribe quite often, and it will be a massive breaking change.\n\nSince most operators are defined using `lift` and thus `unsafeSubscribe` it is not an issue there. Can't we introduce an `unsafeCreate` operator that does not protect and use that internally, user code will use the safe variant.\n",
        "I tend to save all current subscriptions in my Android apps on the Activity, then when the Activity is destroyed, it unsubscribes from them all in order to free up resources. It gets used extensively there. \n\nI think it is required because if the Subscription holds a reference to the Activity (via onNext, etc), then the Activity may never be deallocated. I have an app that has a long lasting TCP connection pumping events into a hot Observable that survives multiple Activities and if I could not unsubscribe from it, then those Activities would be leaked. It would require using WeakReferences to the activity inside of subscriptions to overcome I think. That was used in the Android library previously, but was removed because it caused other problems (I cannot recall what they were).\n",
        "Yes, it looks like that would work. Cheers for that!   \n"
    ],
    "3058": [],
    "3207": [],
    "5470": [],
    "3276": [],
    "1907": [],
    "1402": [
        "Great ... I'll remove it in 0.20. I'd rather wait until it matures and possibly bring it back in the 1.x series than leave it in its current state.\n",
        "It has been removed.\n",
        "I'd be totally fine with that; it is a monster that is hard to tame.\n",
        "+1\n"
    ],
    "553": [],
    "3695": [],
    "6199": [],
    "4120": [],
    "1405": [
        "How do you recommend doing it differently? \n",
        "We print them out when `printStackTrace()` is called, but we no longer add them as part of the actual causal chain as it could end up causing circular loops under odd edge-cases. This was just barely changed in the last release: https://github.com/Netflix/RxJava/pull/1388\n\nHere is the code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java\n\nNote how it will print all causes: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L111\n\nWhat version of RxJava are you running to get that stack trace?\n\nIn the example you give, it looks like the chain is being cropped when it had more to display (2 causes).\n\nI'm wondering if Android does something different than normal Java and doesn't actually invoke the `printStackTrace()` method and thus won't see the causal chain?\n",
        "As I said above, we used to use `initCause`, but because this is a composite of many exceptions, we are creating an artificial causal chain and it could result in infinite loops, hence it being removed in 0.19.2.\n\nI can't speak to Bugsense or Crashlytics, but if something printing a stack trace calls `printStackTrace` then it would work and print out the full list of causes.\n\nFor historical information, here is the version that used `initCause`: https://github.com/Netflix/RxJava/blob/ea2249afecbf4d1380f2d7b0775fec60e37e3369/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L108 and the current one without it: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L111\n\nWe need a solution that either does not use `initCause` due to the circular-reference problem, or solves the circular-reference problem. The change done in https://github.com/Netflix/RxJava/pull/1388 was based on the assumption that anything printing a stack trace would do it correctly via the `printStackTrace()` method and thus we can override the printing of the causes so the causal chain is shown, but not actually mutate the chain by using `initCause` which is what causes the issues.\n",
        "Appending the stacktrace to the message is bad practice and would be despised in non-Android environments.\n\nIt's very annoying that Android does the wrong thing for this. \n\nIf we do anything, it would need to special-case behavior just for Android (such as appending the whole stack trace as a message).\n",
        "@mttkay What do you suggest be done for Android and `CompositeException` since it doesn't behave correctly with `Throwable.printStackTrace()`?\n\n@tomrozb According to the code I see for Android, this should work if the logger is calling `printStackTrace()` as it looks exactly like the Java one: https://android.googlesource.com/platform/libcore.git/+/android-4.2.2_r1/luni/src/main/java/java/lang/Throwable.java\n\nHow are the logs being generated? Is this default Android logging that bypasses `printStackTrace()` or a 3rd party logging library?\n",
        "So should we revert to what it was when we fixed it last time and special case Android? Or does someone have a legit fix for this?\n\nI'm planning on reverting to what was a known fix for non-Android, and then following up with a special case for Android.\n",
        "Closing out again as I believe this is solved in https://github.com/ReactiveX/RxJava/pull/1632\n\nAs per comment https://github.com/ReactiveX/RxJava/pull/1632#issuecomment-53595353:\n\n> This passed the Netflix production canary over night. There are no threads spinning on circular references.\n> \n> This pull request should work for both Android and Oracle JVMs as it supports both `printStackTrace` and `getCause` mechanisms. The `printStackTrace` approach is better, but the `getCause` one should work normally and then bail if it sees a circular reference.\n",
        "I can't help to test this as I don't do Android development or have an environment to test with.\n\nThe current implementation uses `getCause()` to provide the causes, so as long as Android calls `getCause()` then it should work. If however it even bypasses that (as it bypasses `printStackTrace`) and reaches into the internal super field, then it won't work, as we don't wire up the causal chain unless `getCause()` is invoked (instead of construction time as non-Android platforms don't need or want that). If Android is doing that ... then apparently it doesn't obey any APIs.\n\nIf Android is completely ignoring even `getCause()` then the only way I can think of fixing this is having two different implementations and an Android specific check that delegates to a different solution. \n\n/cc @mttkay \n",
        "Moving Android specific discussion to https://github.com/ReactiveX/RxAndroid/issues/21\n",
        "Thanks for flagging this. We're still on 0.19.1 so haven't had this problem yet. I'll have a look as well. \n",
        "Just wondering, if the problem is that Android's `Throwable` refuses to print the stack trace when the cause is null, why not simply return `this` from `CompositeException.getCause`? That way we still don't have to `initCause` on the wrapped exceptions and make Android forward to `CompositeException`'s custom printStackTrace impl.\n\nThis is just by reading the discussion mind you, so sorry if I'm not making any sense. I still haven't had time to bump RxJava to a newer version in our app .\n",
        "I'll put some time aside either tomorrow or Thursday to work through a backlog of Rx specific things. I can try to reproduce then.\n\nI haven't personally seen this issue yet (we're on 0.20.3) but I'll double check the crash logs.\n",
        "Just a quick heads up that I can confirm this issue.\n\nNot sure yet _why_ it's happening, but swapping out the exception type does appear to fix it. Which is odd, since `UnknownHostException` _is_ an `IOException`? I also looked at `Exceptions.throwIfFatal` if it had to do with rethrowing exceptions or not, but it does not mention either type.\n",
        "It's really hard to debug, unfortunately. I was able to pour your example in an automated test and run it on a Genymotion 4.3 instance -- that's the easy part. What I'm not able to do is debug into Android's stack trace methods (parts of it are native code, too, but the problem might exist on the Java layer). This might be an issue with the new project setup, I'm usually able to debug platform classes.\n\nI'll poke around some more.\n",
        "Sorry I'm still fighting the tools :-/ I might have to pick this up again another day...\n",
        "We see more threads getting stuck in infinite loops in `removeDuplicatedCauses`.  Re-opening as we will need to re-fix this.\n",
        "What about using `initCause` (API 1) or I'm sure `addSuppressed` is dedicated for this case but as far as I remember it was introduced in java 7, so it's available in KitKat (API 19)\n",
        "I'm using 0.19.2. I've also encountered problems with the previous version when unhandled exception in onError ended up in circular loop and crash of a StringBuilder but current implementation doesn't provide any useful information for debugging. If you are using error logging service like Bugsense or Crashlytics the only information you see is the stacktrace I've pasted above - it's useless.\n\nSolution with `initCause` works perfect for me. What do you think about it?\n",
        "Ok I've dive deeper into the implementation and it turns out that none of the `printStackTrace` methods are called when an `OnErrorFailedException` is thrown. Only `getMessage` and `getCause` methods are called so the real cause is not printed to the output. Here is my simple test with logged methods of the `CompositeException` class.\n\n```\n        AndroidRuntime  D  Shutting down VM\n              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x4195e700)\n gt_CompositeException  I  CompositeException.getMessage\n                        I  CompositeException.getCause\n              dalvikvm  D  GC_FOR_ALLOC freed 453K, 5% free 11287K/11776K, paused 29ms, total 30ms\n gt_CompositeException  I  CompositeException.getCause\n                        I  CompositeException.getMessage\n                        I  CompositeException.getCause\n        AndroidRuntime  E  FATAL EXCEPTION: main\n                        E  rx.exceptions.OnErrorFailedException: a\n                        E   at test.MainActivity.refreshTasksLists(MainActivity.java:267)\n                        E   at test.MainActivity.onCreateOptionsMenu(MainActivity.java:156)\n                        E   at android.app.Activity.onCreatePanelMenu(Activity.java:2504)\n                        E   at com.android.internal.policy.impl.PhoneWindow.preparePanel(PhoneWindow.java:413)\n                        E   at com.android.internal.policy.impl.PhoneWindow.doInvalidatePanelMenu(PhoneWindow.java:775)\n                        E   at com.android.internal.policy.impl.PhoneWindow$1.run(PhoneWindow.java:198)\n                        E   at android.view.Choreographer$CallbackRecord.run(Choreographer.java:749)\n                        E   at android.view.Choreographer.doCallbacks(Choreographer.java:562)\n                        E   at android.view.Choreographer.doFrame(Choreographer.java:531)\n                        E   at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:735)\n                        E   at android.os.Handler.handleCallback(Handler.java:730)\n                        E   at android.os.Handler.dispatchMessage(Handler.java:92)\n                        E   at android.os.Looper.loop(Looper.java:137)\n                        E   at android.app.ActivityThread.main(ActivityThread.java:5103)\n                        E   at java.lang.reflect.Method.invokeNative(Native Method)\n                        E   at java.lang.reflect.Method.invoke(Method.java:525)\n                        E   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737)\n                        E   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)\n                        E   at dalvik.system.NativeStart.main(Native Method)\n                        E  Caused by: test.CompositeException: 2 exceptions occurred. See them in causal chain below.\n                        E   ... 19 more\n gt_CompositeException  I  CompositeException.getMessage\n                        I  CompositeException.getCause\n                        I  CompositeException.getMessage\n                        I  CompositeException.getCause\n\n                           Process 28215 ended\n```\n\nIt turns out Android has its own implementation of a `Throwable` with uses `private void private void printStackTrace(Appendable err, String indent, StackTraceElement[] parentStack)` to print the stacktrace. If the `cause` is `null` nothing is printed to the output.\n\nI don't see any solution for this issue. For KitKat and above the `addSuppressed` is an easy fix, but what about older versions?\n",
        "What about appending the stack trace to the message of a `CompositeException`? This is some kind of a dirty hack but it will work on any platform regardless of `printStackTrace` implementation.\n",
        "I think any working solution would be appreciated by the Android developers society. I ended up wrapping the whole implementation of `onError` in try-catch block so I'm able to log the cause. So far this is a simple workaround but better error logging by the RxJava should be really addressed in the future release.\n",
        "@benjchristensen \nI'm not using any 3rd party logging library. The logs I've attached are from the standard logging tool called logcat. Logs are generated by Android system. The second posted log is slightly different because I'm using tool to present it in a user-friendly way, but the log is still being generated by Android OS.\n\nCrash reporting tools like Crashlytics or Bugsense utilize the `Thread.UncaughtExceptionHandler` to obtain the stack trace and send it to the server. As I wrote above, stack traces obtained this way are exactly the same as printed by the system.\n\nThe `Throwable` implementation is different for Android and plain Java. If they are using the private `printStackTrace` method with 3 arguments to print the stack trace, other public `printStackTrace` methods, which are overridden by RxJava, will not be called when a crash occurred.\n\nI can confirm this bug on:\nGalaxy Nexus 4.3 (stock Android)\nG900F 4.4.2\nGT-I9506 4.4.2\nGT-I9195 4.4.2\nGT-N7100 4.4.2\nSM-T335 4.4.2\nSM-T320 4.4.2\n\nI've not tested this on non-samsung devices but I'm sure this apply to all Android devices.\n",
        "It is very easy to understand what is going under the hood even without writing a line of code.\n\nThe simplest test case:\n\n```\nthrow new RuntimeException(new CompositeException(Arrays.asList(new RuntimeException(\"the real cause\"))));\n```\n\nNo matter which one of the `printStackTrace` methods is called in the first place it end up calling the  `printStackTrace(err, \"\", null)` on a first `RuntimeException`. \n\nNow take a look at the Throwable implementation (Android 4.2.2)\n\n```\n    private void printStackTrace(Appendable err, String indent, StackTraceElement[] parentStack)\n            throws IOException {\n        err.append(toString());\n        err.append(\"\\n\");\n        StackTraceElement[] stack = getInternalStackTrace();\n        if (stack != null) {\n            int duplicates = parentStack != null ? countDuplicates(stack, parentStack) : 0;\n            for (int i = 0; i < stack.length - duplicates; i++) {\n                err.append(indent);\n                err.append(\"\\tat \");\n                err.append(stack[i].toString());\n                err.append(\"\\n\");\n            }\n            if (duplicates > 0) {\n                err.append(indent);\n                err.append(\"\\t... \");\n                err.append(Integer.toString(duplicates));\n                err.append(\" more\\n\");\n            }\n        }\n        // Print suppressed exceptions indented one level deeper.\n        if (suppressedExceptions != null) {\n            for (Throwable throwable : suppressedExceptions) {\n                err.append(indent);\n                err.append(\"\\tSuppressed: \");\n                throwable.printStackTrace(err, indent + \"\\t\", stack);\n            }\n        }\n        Throwable cause = getCause();\n        if (cause != null) {\n            err.append(indent);\n            err.append(\"Caused by: \");\n            cause.printStackTrace(err, indent, stack);\n        }\n    }\n```\n\nWhat is important the only method used on a `cause` is `printStackTrace` with 3 arguments. Our cause is the `CompositeException` which doesn't have a cause and there is no way to override private `printStackTrace` method so that's why it doesn't work this way.\n",
        "There are still issues with stack trace printing on Android with RxJava 0.20.3. For example when `UnknownHostException`  is thrown from `OnSubscribe` implementation nothing is printed to the logcat output. I've tested it on S5 4.4.2, S4 4.4.2, Galaxy Nexus 4.3.\n\nSimple example to reproduce:\n\n```\n        Observable.create(new OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                subscriber.onError(new UnknownHostException());\n            }\n        }).subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Action1<Object>() {\n                    @Override\n                    public void call(Object o) {\n                        // Does nothing intentionally.\n                    }\n                }, new Action1<Throwable>() {\n                    @Override\n                    public void call(Throwable e) {\n                        throw new RuntimeException(e);\n                    }\n                });\n```\n\nLogcat output:\n\n```\n        AndroidRuntime  D  Shutting down VM\n              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x417a7da0)\n        AndroidRuntime  E  FATAL EXCEPTION: main\n                        E  Process: pl.example.test, PID: 25099\n```\n\nChange `UnknownHostException` to `IOException`, now logcat output looks like below:\n\n```\n        AndroidRuntime  D  Shutting down VM\n              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x417a7da0)\n        AndroidRuntime  E  FATAL EXCEPTION: main\n                        E  Process: pl.example.test, PID: 9153\n                        E  rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n                        E      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:175)\n                        E      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)\n                        E      at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)\n                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:169)\n                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:66)\n                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:151)\n                        E      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)\n                        E      at android.os.Handler.handleCallback(Handler.java:733)\n                        E      at android.os.Handler.dispatchMessage(Handler.java:95)\n                        E      at android.os.Looper.loop(Looper.java:136)\n                        E      at android.app.ActivityThread.main(ActivityThread.java:5586)\n                        E      at java.lang.reflect.Method.invokeNative(Native Method)\n                        E      at java.lang.reflect.Method.invoke(Method.java:515)\n                        E      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1268)\n                        E      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1084)\n                        E      at dalvik.system.NativeStart.main(Native Method)\n                        E  Caused by: rx.exceptions.CompositeException: 2 exceptions occurred.\n                        E      ... 16 more\n                        E  Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\n                        E      at android.util.Log.getStackTraceString(Log.java:421)\n                        E      at android.util.Slog.e(Slog.java:151)\n                        E      at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)\n                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\n                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\n                        E      ... 1 more\n                        E  Caused by: java.io.IOException\n                        E      at pl.example.test.MyActivity$3.call(MyActivity.java:48)IOException\n                        E      at pl.example.test.MyActivity$3.call(MyActivity.java:45)\n                        E      at rx.Observable.unsafeSubscribe(Observable.java:8587)\n                        E      at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n                        E      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)\n                        E      at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n                        E      at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n                        E      at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n                        E      at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n                        E      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n                        E      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n                        E      at java.lang.Thread.run(Thread.java:841)\n                        E  Caused by: java.lang.RuntimeException: Duplicate found in causal chain so cropping to prevent loop ...\n                        E      at android.util.Log.getStackTraceString(Log.java:421)\n                        E      at android.util.Slog.e(Slog.java:151)\n                        E      at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)\n                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\n                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\n                        E      at dalvik.system.NativeStart.main(Native Method)\n```\n\nCan anyone confirm this issue with the code I've attached?\n",
        "Maybe there's something wrong with my code. I've put the code above in onResume of a totally empty Activity to nail down where's the issue. If somebody can test this on other devices it would be very helpful. I don't have any non-Samsung devices at the moment.\n",
        "`UnknownHostException` is not the only one that is not logged. I'm sure I've found at least 3 different exceptions that do not produce any output to the logcat. I'll post these exceptions here once I figure out which one causing problems. Good to hear that this issue is confirmed and easy to reproduce.\n"
    ],
    "4458": [],
    "6905": [],
    "5873": [],
    "4291": [],
    "1416": [
        "This would not use `multicast` under the covers and would therefore be more efficient and retain subscription chains as it would not create a \"hot observable\" as `publish` does.\n",
        "I'd have to play with Groovy and Clojure to see. We'd likely want another type like `Operator` that is a cover for generics insanity. Not sure what to call this one.\n",
        "Discussing with @headinthebox the more appropriate name for this is `compose`.\n\n``` java\npublic <R> Observable<R> compose(Func1<? super Observable<T>,? extends Observable<R>> function)\n```\n\nWith the cover type:\n\n``` java\npublic <R> Observable<R> compose(Transformer<T, R> function)\n\npublic interface Transformer<T, R> extends Func1<? super Observable<? super T>,? extends Observable<? extends R>>;\n```\n\nNOTE: Not sure about the co/contra-variance in that signature.\n",
        "I added `compose` in #1568 but wasn't able to figure out the co/contra-variance so I've got #1569 open. Can someone help me out with that black art?\n\nIf super/extends doesn't work for it, then maybe we should change `compose(Transformer<T, R> transformer)` to `compose(Func1<Observable<T>, Observable<R>>)` since the `Transformer` type is not probably not needed if we're not hiding generics complexity.\n\n/cc @headinthebox \n",
        "Thanks @abersnaze for the fix to variance. Closing this.\n",
        "How is that different from `.publish` that's already there?\n",
        "Yes, that's what I imagined. Could we call it `lift` as well, or does that lead to erasure troubles?\n"
    ],
    "460": [],
    "1420": [
        "@benjchristensen Would you be able to provide some information regarding what does the source observable and the chain of operators look like? I guess can can say the after materialize() the complete notification never made it though the internal subscriber in BlockingOperatorToIterator?\n",
        "@benjchristensen great news!\n",
        "> what does the source observable and the chain of operators look like\n\nIt is a list of Observables that each return a single item being merged together.\n\n```\n   java.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    - parking to wait for  <0x00007f69fe0c6798> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)\n    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n    at rx.internal.operators.BlockingOperatorToIterator$2.take(BlockingOperatorToIterator.java:92)\n    at rx.internal.operators.BlockingOperatorToIterator$2.hasNext(BlockingOperatorToIterator.java:72)\n    at rx.internal.operators.BlockingOperatorToIterator$2.next(BlockingOperatorToIterator.java:82)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:348)\n    at com.netflix.api.service....\n    at rx.Observable$2.call(Observable.java:163)\n    at rx.Observable$2.call(Observable.java:156)\n    at rx.Observable.unsafeSubscribe(Observable.java:6846)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.handleNewSource(OperatorMerge.java:127)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:110)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:49)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:54)\n```\n\n> Does it use backpressure?\n\nNothing is explicitly using backpressure except for changes in RxJava itself. The codebase is currently running RxJvaa 0.19.2 and I'm dropping in 0.20.0-SNAPSHOT.\n\nDebugging as I have time ... \n",
        "Pretty certain this is yet another concurrency bug in `merge`.\n",
        "I really don't like the `merge` code, but everything I try to simplify it (such as simple \"add to queue then drain\") kills the performance significantly.\n",
        "The changes in #1422 did not solve this. I ran a new canary and have the same issue. Digging ...\n",
        "No, the simplification in #1422 didn't kill perf.\n\nThe stack trace itself is pretty normal (`merge` does `unsafeSubscribe`) except for the ugliness of how `toBlocking` is being used by the Observables being merged :-(\n\nThus far I still have no idea what causes this to fail. I can't replicate it anywhere except for production and that's making it very hard to track down.\n",
        "I confirmed over the weekend with a production canary that the issue is related to `merge`. I took the code in master branch and reverted `OperatorMerge` to 0.19.x code but left everything else as is. The issue did not occur. Continuing to dig ... I have an idea as to where the issue might be.\n",
        "Code changes I've committed seem to have fixed this issue. I've had the code running in production for 12 hours and the score is good and thread dumps look clean. \n",
        "Looks like this isn't completely solved, as I'm seeing it still, just far less often.\n\nI'm going to commit a change that I know solves it, but it uses synchronization in a bad way. I don't yet understand the actual issue, just the symptoms and the hammer that removes the symptoms.\n",
        "The outer is unbounded (except in the optimized case with `ScalarSynchronousObservable`). The `merge(Observable<Observable<T>>)` case is an odd one, and basically the user is asking for unbounded horizontal buffering.\n\nWe can achieve backpressure vertically (how many items queued per Observable) but not horizontally (number of Observables being merged). The reasoning is:\n- A user can't control how many onNext per Observable flow, but they can generally control the number of Observables they are merging.\n- We can't restrict how many Observables are merged unless the user asks for it (such as `merge(Observable o, int maxConcurrent)` because it may only be the very last Observable that emits, so if we sit waiting on the first ones we may never receive any values and never move on to the final Observable that has the data.\n\nThis is different in the `ScalarSynchronousObservable` case as we treat those as `onNext` and don't even subscribe to them. This is why the `request(1)` behavior occurs in the current `merge` implementation at these two locations:\n- every Observable we receive we automatically request more: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java#L191\n- on `ScalarSynchronousObservable`s we only request more once we have been able to emit their values: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java#L230\n",
        "I've solved this for now with synchronization so am closing. I'll work more on this over time for performance and efficiency reasons, but as of 0.20.0-RC3 the issue is not showing itself and I have successfully passed a 20-hour production canary test in Netflix API production.\n",
        "That is a scary stack trace. Does the simplification kill perf for the non-backpressure case as well? \n",
        "Does it use backpressure?\n",
        "See my zip pr for a candidate. If I have time, I'll look at merge.\n",
        "I had some time but the current merge is so complicated I can't make anything out of it.\n",
        "Could you help me understand how `merge(Observable<Observable<T>>)` works? If the downstream requests 10 elements, how is that translated to requests to the outer and inner observables? Even if any requests are transformed into one-by-one requests, that can't be held in a fixed buffer because either one requests 1 from N observables, which might not deliver or requests 1 from all observables where there could be a buffer overrun if all produce?\n"
    ],
    "5798": [],
    "1905": [],
    "4924": [],
    "1898": [],
    "1130": [],
    "1727": [],
    "5436": [],
    "505": [],
    "6758": [],
    "1451": [
        "This should be fixed in 0.20.0-RC3\n"
    ],
    "1593": [],
    "1361": [],
    "5761": [],
    "718": [],
    "499": [],
    "1081": [],
    "176": [],
    "1466": [
        "@dvtomas there already is a static Observable.using() method in RxScala.\n",
        "Looks much nicer to me. I'd also appreciate having `using` implemented in the scala bindings.\n",
        "Review design as part of 0.20: https://github.com/Netflix/RxJava/issues/1580\n",
        "So this would change from:\n\n``` java\n    public final static <T, Resource extends Subscription> Observable<T> using(\n            Func0<Resource> resourceFactory, \n            Func1<Resource, ? extends Observable<? extends T>> observableFactory) \n```\n\nto\n\n``` java\n    public final static <T, Resource> Observable<T> using(\n           Func0<Resource> resourceFactory,\n           Func1<? super Resource, ? extends Observable<? extends T>> observableFactory,\n           Action1<? super Resource> dispose) \n```\n",
        "Is this a correct change => https://github.com/Netflix/RxJava/pull/1592 ?\n",
        "@davidmoten Can you please review this so I can finish this up and release 0.20?\n",
        "This was reviewed and merged.\n",
        "I like this idea. @headinthebox could you help evaluate it?\n"
    ],
    "6546": [],
    "5672": [],
    "6728": [],
    "1159": [],
    "1476": [],
    "4927": [],
    "3895": [],
    "1480": [
        "I have fixed the outer backpressure, but the inner still needs to be done.\n"
    ],
    "1481": [
        "This is actually an issue with `concat`. Looking at it now.\n",
        "Also occurs in master at time of this comment, probably related to #1480.\n"
    ],
    "430": [],
    "4431": [],
    "3874": [],
    "1485": [
        "Currently non-deterministically broken so marking as bug to be done in 0.20\n"
    ],
    "4125": [],
    "3818": [],
    "3088": [],
    "377": [],
    "742": [],
    "6722": [],
    "259": [],
    "127": [],
    "3400": [],
    "2474": [],
    "1508": [
        "Closing per  #3683\n"
    ],
    "967": [],
    "4117": [],
    "4139": [],
    "1123": [],
    "3506": [],
    "555": [],
    "4257": [],
    "6525": [],
    "1522": [
        "Thanks for the report, I'll take a look soon.\n",
        "This test is passing now.\n",
        "@benjchristensen I'm working on it. Looks a bug in takeLast\n"
    ],
    "1300": [],
    "3126": [],
    "1757": [],
    "1035": [],
    "6891": [],
    "4946": [],
    "6887": [],
    "4265": [],
    "571": [],
    "4674": [],
    "3404": [],
    "5648": [],
    "1546": [
        "This is a bug, but it's been a bug for a while and doesn't affect public APIs so moving from 1.0 to 1.x milestone.\n",
        "What happens is that take(10) shuts down the emitter thread as soon as it receives the 10th Observable so the downstream receives random amount of data before the emitter checks again its client for unsubscription. Changing it to buffer(10) gives the required 10 items and doesn't hang.\n\n``` java\n        hotStream().buffer(10).take(5).flatMap(w -> {\n            return Observable.from(w).startWith(999999999);\n        }).toBlocking().forEach(System.out::println);\n```\n",
        "The hang happens because the flatMap never receives an onCompleted from the emitter and thus unable to release the latch in the blocking forEach.\n"
    ],
    "751": [],
    "1617": [],
    "1550": [
        "``` java\n        Observable.from(1, 2, 3, 4).mergeMap(i -> {\n            if (i < 3) {\n                return Observable.just(\"value_\" + i);\n            } else {\n                return Observable.empty();\n            }\n        }).forEach(System.out::println);\n```\n",
        "It also correctly infers it is a String:\n\n``` java\n        Observable<String> mergeMap = Observable.from(1, 2, 3, 4).mergeMap(i -> {\n            if (i < 3) {\n                return Observable.just(\"value_\" + i);\n            } else {\n                return Observable.empty();\n            }\n        });\n```\n",
        "This code compiles and runs for me:\n\n``` java\nimport rx.Observable;\n\n\npublic class Issue1550 {\n\n    static class User {\n        String name;\n        int age;\n\n        User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        savedUser()\n                .mergeMap(Observable::just, e -> fetchUser(), Observable::empty)\n                .forEach(user -> System.out.println(user.name));\n    }\n\n    static Observable<User> savedUser() {\n        return Observable.error(new IllegalStateException(\"there are no saved users\"));\n    }\n\n    static Observable<User> fetchUser() {\n        return Observable.just(new User(\"Adel\", 13));\n    }\n\n}\n```\n\nIt outputs:\n\n```\nAdel\n```\n",
        "Ah interesting, it works in Eclipse, but not from command line.\n\n```\nlgml-bechristensen:libs benjchristensen$ /Library/Java/JavaVirtualMachines/jdk1.8.0_0.jdk/Contents/Home/bin/javac -cp rxjava-core-0.20.0-RC4-SNAPSHOT.jar Issue1550.java \nIssue1550.java:18: error: incompatible types: no instance(s) of type variable(s) T#1 exist so that Observable<T#1> conforms to ? extends Observable<? extends R>\n                .mergeMap(Observable::just, e -> fetchUser(), Observable::empty)\n                         ^\n  where T#1,R,T#2 are type-variables:\n    T#1 extends Object declared in method <T#1>empty()\n    R extends Object declared in method <R>mergeMap(Func1<? super T#2,? extends Observable<? extends R>>,Func1<? super Throwable,? extends Observable<? extends R>>,Func0<? extends Observable<? extends R>>)\n    T#2 extends Object declared in class Observable\n1 error\n```\n",
        "I believe this is now fixed as of https://github.com/Netflix/RxJava/pull/1558.\n\nIf you can confirm against the branch, please do. Reopen if there are still issues.\n",
        "@zsxwing You're good at figuring this kind of stuff out, so is there anything we should be doing differently here, or is this just a weakness of Java 8?\n",
        "so @akarnokd is it your assessment that there is not anything better we can do with the RxJava APIs and it's just up to the language/compiler itself?\n",
        "I'm considering this \"as good as it can get\" then since our `flatMap` matches the Stream interface definition:\n\n``` java\n<R> Observable<R> flatMap(Func1<? super T, ? extends Observable<? extends R>> func)\n```\n\nThanks @akarnokd for the insight.\n",
        "@benjchristensen actually, I know little about Java type inference. I try the following codes and it works:\n\n``` java\nimport rx.Observable;\nimport rx.functions.*;\n\npublic class Issue1550 {\n\n    static class User {\n        String name;\n        int age;\n\n        User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        Func0<Observable<User>> empty = () -> Observable.empty();\n        Func1<User, Observable<User>> just = (User user) -> Observable.just(user);\n        savedUser().flatMap(\n                just,\n                e -> fetchUser(),\n                empty)\n        .forEach(user -> System.out.println(user.name));\n    }\n\n    static Observable<User> savedUser() {\n        return Observable.error(new IllegalStateException(\"there are no saved users\"));\n    }\n\n    static Observable<User> fetchUser() {\n        return Observable.just(new User(\"Adel\", 13));\n    }\n\n}\n\n```\n\nSo I guess it's a weakness of Java type inference. Looks we have to write a temp variable to tell the compiler type information.\n",
        "The following codes work, too:\n\n``` java\nimport rx.Observable;\nimport rx.functions.*;\n\npublic class Issue1550 {\n\n    static class User {\n        String name;\n        int age;\n\n        User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        Func0<Observable<User>> empty = Observable::empty;\n        Func1<User, Observable<User>> just = Observable::just;\n        savedUser().flatMap(\n                just,\n                e -> fetchUser(),\n                empty)\n        .forEach(user -> System.out.println(user.name));\n    }\n\n    static Observable<User> savedUser() {\n        return Observable.error(new IllegalStateException(\"there are no saved users\"));\n    }\n\n    static Observable<User> fetchUser() {\n        return Observable.just(new User(\"Adel\", 13));\n    }\n\n}\n```\n",
        "Java 8 type inference has some weaknesses, and javac won't compile code that will compile just fine in Eclipse 4.4. Based on some comments in lambda-dev, those javac shortcommings won't be fixed until Java 9.\n",
        "Java 6 and 7 developers would need the full covariance in the parameter types and only Java 8 non-Eclipse developers have to do workarounds such as above. Besides, the Stream.flatMap has full covariance in its signature:\n\n```\n<R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper)\n```\n\nSo it is either lambda workarounds for Java 8 devs or unchecked casting for Java 6/7 to bypass the lack of variance.\n",
        "@benjchristensen \nhere's the example that won't compile because of the variance/contravariance and java 8 lambda's type inference:\n\n``` java\nstatic class User {\n    String name;\n    int age;\n\n    User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\npublic static void main(String[] args) {\n    savedUser()\n            .mergeMap(Observable::just, e -> fetchUser(), Observable::empty)\n            .forEach(user -> System.out.println(user.name));\n}\n\nstatic Observable<User> savedUser() {\n    return Observable.error(new IllegalStateException(\"there are no saved users\"));\n}\n\nstatic Observable<User> fetchUser() {\n    return Observable.just(new User(\"Adel\", 13));\n}\n```\n",
        "@benjchristensen I don't have the rights to reopen the issues\nbut I cloned the master, built the jar and tried to compile:\n\n```\n$JAVA8_HOME/bin/javac Test.java -cp rxjava-core-0.20.0-RC5-SNAPSHOT.jar\nTest.java:19: error: incompatible types: no instance(s) of type variable(s) T#1 exist so that Observable<T#1> conforms to ? extends Observable<? extends R>\n                .mergeMap(Observable::just, e -> fetchUser(), Observable::empty)\n                         ^\n  where T#1,R,T#2 are type-variables:\n    T#1 extends Object declared in method <T#1>empty()\n    R extends Object declared in method <R>mergeMap(Func1<? super T#2,? extends Observable<? extends R>>,Func1<? super Throwable,? extends Observable<? extends R>>,Func0<? extends Observable<? extends R>>)\n    T#2 extends Object declared in class Observable\n```\n\nI don't really think this is an issue, because expanding the method ref as a `new Func1...` works just fine, but is ugly in java8\nso I thought maybe it's me who's doing something wrong\nI am very bad with co- and contravariance so I can't even figure out how to change `mergeMap`'s signature so that the thing compiles with method references\n",
        "@benjchristensen I'm using Oracle JDK on Ubuntu 14.04\n\n```\n$JAVA8_HOME/bin/javac -version\njavac 1.8.0_11\n```\n"
    ],
    "6187": [],
    "3514": [],
    "1386": [],
    "1554": [],
    "962": [],
    "1556": [
        "Who knew flatMap didn't preserve order? I'll fix `mapcat` to work as documented.\n",
        "@timmc That's what I was thinking. \n",
        "Two possible solutions:\n- Implement order-preserving semantics and update mapcat's docstring with a warning about the effect of concat on async. Add another function for the merge semantics\n- Change mapcat's docstring to match its current behavior and add an example of composing map and concat to get order preservation\n\nSince it's named `mapcat` which has a particular meaning in Clojure I think I'm leaning toward the first solution (clearly since someone's already been bitten by the difference).\n",
        "Addressed here: https://github.com/Netflix/RxJava/pull/1570\n",
        "@daveray Can you weigh in on this please?\n",
        "Is the term flatMap not used in Clojure? I'm assuming mapcat is idiomatic naming for Clojure otherwise 'flatMap' and 'concatMap' would be used?\n",
        "FlatMap in a synchronous/pull scenario is deterministic and ordered. In an async/push it is not, that is the nature of merging async streams. Hence the existence of concatMap (which is very rarely wanted in async stream composition as it is effectively blocking as it won't subscribe to the next stream until the previous completes). \n",
        "Since `mapcat` has meaning in Clojure, and it appears to mean `concatMap` it should definitely use `concatMap`. That said, `flatMap` is normally what is wanted in a push system. I suggest using the term `flatMap` since that's what is used almost every where to mean \"merge map\".\n\nHere is concatMap: http://netflix.github.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)\n",
        "That totally depends on what monad it is defined.\n",
        "@daveray Any plans for a Clojure wrapper replacement that does have flatMap's semantics after tihs change? (\"mapmerge?\")\n",
        "I don't know of a clojure function or idiom for merging sequences with arbitrary interleaving. (In fact, we had a bug in our code due to incorrect use of flatMap since we were assuming it acted like Clojure's mapcat!) So I think any wrapper of flatMap in the Clojure adapter will need a new name.\n\nActually, 'flatmap' would probably be the best name for any wrapper of flatMap because of the novel semantics. :-)\n"
    ],
    "6337": [],
    "4055": [],
    "2930": [],
    "1563": [
        "I would refer to Item 41 in Effective Java by Josh Bloch. Bloch warns to use overloading judiciously for this specific reason. Josh's advice would be to create methods such as @abersnaze suggested. Overloading in Java is broken.\nI'll take a quote from the book for those who don't have access \"A safe, conservative policy is never to export two overloadings with the same number of parameters\"\n",
        "I do like these changes. I think it will be less confusing for users. However, I think it is a bit confusing to keep the `just` methods. I believe a typical user would study the javadoc for the `just` and `item` and find that they are very similar and wonder in what situations they should use one over the other. I did this the first time used `just` and `from`. The user would then have to look at the source to see that `item` calls `just`.\n\nThis could also be fixed by changing the JavaDoc to say that `item` calls `just`. Though, I would prefer removing `just`.\n",
        "+2 for B\n",
        "I support a change. Methods that do different things should have different names. It's currently ambiguous if the call `Observable.from(new ArrayList<T>())` should return `Observable<T>` or `Observable<ArrayList<T>>`. I'm partial to not having a raw `from(...)` and break them out into their own methods.\n- `fromItems(T...)`\n- `fromFuture(Future<T>)`\n- `fromIterable(Iterable<T>)`\n\nand maybe :smiley:\n- `fromEnumerable(Func0<Enumeration<T>>)`\n",
        "@headinthebox I'm not against overloads. Just overloads that do different things. There will still be plenty of overloads in my proposal:\n- `fromFuture(Future<T>)`\n- `fromFuture(Future<T>, Scheduler)`\n- `fromFuture(Future<T>, long, TimeUnit)`\n- `fromFuture(Future<T>, long, TimeUnit, Scheduler)`\n- `fromItems(T)`\n- `fromItems(T, T)`\n- `fromItems(T, T, T)`\n- `fromItems(T, T, T, T)`\n- `fromItems(T, T, T, T, T)`\n- `fromItems(T, T, T, T, T, T)`\n  ...\n\n@benjchristensen, @mattrjacobs: could 0.20 depreciate `from(...)` and friends and 1.0 delete to appease the naysayers?\n",
        "In light of this change, would it make sense to rename RxScala's items(T_) to just(T_) as well?\n",
        "Done in #1586\n",
        "Not a big deal for Clojure-land. We'd just change `rx/return` to use `fromItems(T)` instead of `just` and `rx/seq->o` to use `fromIterable()` or whatever. We (at least me and my team) don't use any of the other overloads.\n",
        "I'm not a fan of removing 'from(T)' this late in the game (almost to 1.0). Most of the time it is desired to itemize an Iterable. The 'just' operator is there for when it shouldn't be itemized. \n\n/cc @headinthebox\n",
        "If we do pursue this change I'd probably do ...\n- delete 'just'\n- leave 'from(T)'\n- change 'from(Iterable)' to 'fromIterable(Iterable)'\n\nThe thing I don't like about this is it will break most uses of 'from(Iterable)' that itemizes as most people want it to. \n",
        "By the way, the reason why it is designed the way it currently is is because an Observable is intended for itemized sequences of data. It is rare that the desired output is Observable<Iterable<T>> instead of Observable<T>. \n\nThus in the Foo<T> case it would correctly convert T into an itemized sequence, which is what \"from\" is for. If a scalar response is desired that is what \"just\" is for. \n\nSo if Foo<T> should emit Observable<List<T>> then use Observable.just rather than the more common Observable.from. \n",
        "Any further comments or discussion on this? The key deterrent to changes here are:\n\n1) Massive breaking change to eliminate `from(T)` or `from(Iterable i)`\n2) The intended design of `from` is to itemize to `Observable<T>` and of `just` is to not itemize.\n",
        "I also don't like `fromXXX` method names.\n\nI agree that the current semantics are somewhat awkward and could have been designed better. However, the cost of changing this is not worth the massive break on almost all existing applications since `from` is such a commonly used method signature. \n\nI don't think this change should be made right before hitting 1.0. Eventually when 2.x is done (not anytime soon) this could be cleaned up, but in well over a year of usage by many people, this issue is the first time I'm aware of this issue being been brought up, thus I don't think the confusion is significant enough to warrant a breaking change.\n",
        "/cc @zsxwing @akarnokd @jmhofer @mttkay @daveray @davidmoten @daschl @gorzell and anyone else who has an opinion to share. \n",
        "It is not the design I'm disputing, it's how badly this breaks almost all apps. Is this problem (that no one has complained about for over a year) really so bad as to warrant the breakage? \n\nWhether the methods are deleted in 0.20 or 1.0 doesn't matter, whenever it happens the break happens (though if we do this we'd deprecated in 0.20 and delete in 1.0).\n",
        "If we do make a change ....\n\nCurrent:\n\n``` java\nfrom(Future<? extends T>);\nfrom(Future<? extends T>, long, TimeUnit);\nfrom(Future<? extends T>, Scheduler);\nfrom(Iterable<? extends T>);\nfrom(Iterable<? extends T>, Scheduler);\nfrom(T);\nfrom(T, T);\nfrom(T, T, T);\nfrom(T, T, T, T);\nfrom(T, T, T, T, T);\nfrom(T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T, T, T);\nfrom(T...);\nfrom(T[], Scheduler);\njust(T);\njust(T, Scheduler);\n```\n\nI would delete the `just` methods and then pursue something like this:\n\n``` java\nfromFuture(Future<? extends T>);\nfromFuture(Future<? extends T>, long, TimeUnit);\nfromIterable(Iterable<? extends T>);\nfromArray(T[]);\nfrom(T);\nfrom(T, T);\nfrom(T, T, T);\nfrom(T, T, T, T);\nfrom(T, T, T, T, T);\nfrom(T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T, T, T);\n```\n\nor maybe:\n\n``` java\nfrom(Future<? extends T>);\nfrom(Future<? extends T>, long, TimeUnit);\nfrom(Iterable<? extends T>);\nfrom(T[]);\nitems(T);\nitems(T, T);\nitems(T, T, T);\nitems(T, T, T, T);\nitems(T, T, T, T, T);\nitems(T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T, T, T, T);\n```\n\nor:\n\n``` java\nfrom(Future<? extends T>);\nfrom(Future<? extends T>, long, TimeUnit);\nfrom(Iterable<? extends T>);\nfrom(T[]);\nfromItems(T);\nfromItems(T, T);\nfromItems(T, T, T);\nfromItems(T, T, T, T);\nfromItems(T, T, T, T, T);\nfromItems(T, T, T, T, T, T);\nfromItems(T, T, T, T, T, T, T);\nfromItems(T, T, T, T, T, T, T, T);\nfromItems(T, T, T, T, T, T, T, T, T);\nfromItems(T, T, T, T, T, T, T, T, T, T);\n```\n",
        "After 0.20 we will immediately move to 1.0-RC1 with the only change being the deletion of deprecated methods/types. Therefore, API cleaning and changing should be done, with only outstanding work shown here: https://github.com/Netflix/RxJava/issues?q=is%3Aopen+is%3Aissue+milestone%3A0.20\n\nSome small breaking changes have been done in 0.20, but nothing on major APIs (removal of `pivot` and deprecation of `mergeMap` which duplicated `flatMap`). All major work of 0.20 has been additive (backpressure).\n",
        "Please review proposed changes in https://github.com/Netflix/RxJava/pull/1576. Ignore the deluge of unit test changes and focus on Observable.java.\n\nI deprecated the `from(T)` methods, added `item(T)` and `items(T*)`, left `just` alone. I also deprecated the unnecessary `from(*, Scheduler)` overloads where `subscribeOn` can just be used.\n\nNothing should break in 0.20 with this. The deprecated methods will be removed in 1.0RC1 with all other deprecated methods.\n\nIf there are naming or signature changes to debate, let's make sure to get it correct now so please review and speak up.\n",
        "What is better for a single item, Observable.just(T) or Observable.item(T)?\n\nFor multiple should it be Observable.just(T, T) or Observable.items(T, T)\n",
        "I think I do too. It would mean we stick with 'from' and 'just' instead of introducing yet another name to discover. \n\nThe 'just' name also conveys it will emit \"just\" what it is given. \n",
        "##### Current\n\n``` java\nfrom(Future<? extends T>);\nfrom(Future<? extends T>, long, TimeUnit);\nfrom(Future<? extends T>, Scheduler);\nfrom(Iterable<? extends T>);\nfrom(Iterable<? extends T>, Scheduler);\nfrom(T);\nfrom(T, T);\nfrom(T, T, T);\nfrom(T, T, T, T);\nfrom(T, T, T, T, T);\nfrom(T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T, T);\nfrom(T, T, T, T, T, T, T, T, T, T);\nfrom(T...);\nfrom(T[], Scheduler);\njust(T);\njust(T, Scheduler);\n```\n\n##### Proposal A\n\nNOTE: This will break `from(T)` usage but not `just(T)`.\n\n``` java\nfrom(Future<? extends T>)\nfrom(Future<? extends T>, long, TimeUnit)\nfrom(Future<? extends T>, Scheduler)\nfrom(Iterable<? extends T>)\nfrom(T[])\nitem(T)\nitems(T, T)\nitems(T, T, T)\nitems(T, T, T, T)\nitems(T, T, T, T, T)\nitems(T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T, T, T, T)\njust(T)\n```\n\n##### Proposal B\n\nNOTE: This will break `from(T)` usage but not `just(T)`.\n\n``` java\nfrom(Future<? extends T>)\nfrom(Future<? extends T>, long, TimeUnit)\nfrom(Future<? extends T>, Scheduler)\nfrom(Iterable<? extends T>)\nfrom(T[])\njust(T)\njust(T, T)\njust(T, T, T)\njust(T, T, T, T)\njust(T, T, T, T, T)\njust(T, T, T, T, T, T)\njust(T, T, T, T, T, T, T)\njust(T, T, T, T, T, T, T, T)\njust(T, T, T, T, T, T, T, T, T)\njust(T, T, T, T, T, T, T, T, T, T)\n```\n\n##### Proposal C\n\nNOTE: This will break `from(T)` and `just(T)`.\n\n``` java\nfrom(Future<? extends T>)\nfrom(Future<? extends T>, long, TimeUnit)\nfrom(Future<? extends T>, Scheduler)\nfrom(Iterable<? extends T>)\nfrom(T[])\nitem(T)\nitems(T, T)\nitems(T, T, T)\nitems(T, T, T, T)\nitems(T, T, T, T, T)\nitems(T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T, T, T)\nitems(T, T, T, T, T, T, T, T, T, T)\n```\n\nI prefer B as I find the `item`/`items` differentiation awkward, and I prefer not breaking usage of `just`.\n\nAny other proposals? \n\nI'd like to make a decision on this within the next 24 hours so I can release the next RC.\n\nPlease weigh in ...\n",
        "Thanks everyone for your votes. I'm merging the pull request with option B.\n",
        "Merged https://github.com/Netflix/RxJava/pull/1576.\n\nThe ambiguity will still exist in 0.20 due to the deprecated methods. In 1.0 the deprecated methods will be deleted.\n",
        "My $0.02\n\nThe current design is certainly confusing and could be changed. However, the tax on users that this backward incompatible change would bring because of the shear intrusiveness of `Observable.just()` and `Observable.from()` in our codebase does not justify this change.\n\nI would vote for keeping the current API at this point.\n",
        "I don't like the ambiguity of `from(T)` and `from(Iterable<T>)`. From the discussion, I think the question is when to fix it. IMO, I prefer starting it early.\n",
        "I personally don't like `fooXXX(XXX foo)` names. That's why java has overloading. But if overloading does not work, we have no choice.\n",
        "I don't buy \"appeal to authority figure\" arguments. Just saying.\n",
        "+1 for B (agree item/items is super awkward)\n",
        "Go ahead.\n",
        "I think we should keep `just`, first because it adds clarity on the call site, and second because of the problem @runningcode mentioned with `from(Iterable)` exploding lists. We use observables a lot to emit items in batches/pages, since that's how they're returned from the server, and most of the time there's no value in exploding a page into individual emissions, since we'd have to turn them back into batches again. This is where `just` helps, since it takes the list and emits it as is.\n\nTo summarize:\nI'd vote to keep the current API, with `from(Iterable<T>)` for conversion to `Observable` as per the duality principle, `just(T)` to emit single values. If anything, I'd drop the `from(T)` overload that takes a single argument, since there's a chance it won't do what you expect it to do.\n",
        "I would prefer `just`, and it already exists so people are familiar with\nwhat it does.\n",
        "B\n",
        "+1 for B\n",
        "+1 B\n",
        "In RxScala, we call it `Observable.items` instead of `Observable.from` (see [docs](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable$)). IMHO it would be nice to do the same in RxJava.\n",
        "I'd take @benjchristensen's second proposal, but keep the `just` methods, since they don't \"hurt\":\n\n``` java\nfrom(Future<? extends T>);\nfrom(Future<? extends T>, long, TimeUnit);\nfrom(Iterable<? extends T>);\nfrom(T[]);\nitems(T);\nitems(T, T);\nitems(T, T, T);\nitems(T, T, T, T);\nitems(T, T, T, T, T);\nitems(T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T, T, T);\nitems(T, T, T, T, T, T, T, T, T, T);\njust(T);\njust(T, Scheduler);\n```\n\nSo the only change would be `from(T*) --> items(T*)`. I imagine that `from(T*)` is only used rarely (except for toy examples), so the change should not break too much code.\n",
        "My 2c - \n\nThe current design is not correct, as described above.  In particular, it's definitely surprising for a user that `Observable.from(list1, list2)` emits 2 lists, and `Observable.from(list1)` emits all elements of list1.\n\nHowever, this seems like a severe cost in terms of migration for moderate-at-best benefit.  I've been involved with keeping a large multi-language codebase up-to-date with RxJava as it evolves, and this migration would be a painful one.  \n\nMy vote is to leave it as-is, and document the `from(...)` and `just(...)` Javadocs, as well as the Observable creation page with a clear explanation of how they are intended to be used.\n",
        "+3 for B\n",
        "I'm not fond of changing this, but if there are good reasons I'm okay with it. In my whole codebase I never ran across an issue with that, and sometimes I even explicitly use the \"just\" instead of a from(T) to make it clear I'm returning just one item, basically.\n\nI'm good if we get to something more clear, but on the other hand as @benjchristensen said it will break a good deal of libraries I'm sure (fixing it is not very hard, though). \n\n@benjchristensen strictly speaking, are we done with cleaning the API yet with 0.20 or is there still opportunity for 1.0? SUBJ: in my opinion we gain too less and risk too much annoyance with breaking this, since its just very minor API nuances?\n",
        "I also like @benjchristensen's second proposal but would suggest that \n`items(T)` should be `item(T)` to avoid the ambiguity of `items(<Iterable<Foo>>)`\n",
        "I like the consistency of item and items. 'just' for multiple seems odd.\nOn 14 Aug 2014 21:33, \"Ben Christensen\" notifications@github.com wrote:\n\n> I think I do too. It would mean we stick with 'from' and 'just' instead of\n> introducing yet another name to discover.\n> \n> The 'just' name also conveys it will emit \"just\" what it is given.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/Netflix/RxJava/issues/1563#issuecomment-52172556.\n"
    ],
    "1571": [
        "Opening discussion about confusion between `EmptyObserver` and `Observers.empty()`: https://github.com/ReactiveX/RxJava/issues/1741\n",
        "It will no longer throw an exception when a delegate is not provided. That was a mistake.\n",
        ":+1: \n",
        "I had a problem with this to when using the `TestObserver` to test errors.\nI'm using mockito so I worked this around creating my TestObservers like this:\n\n```\n    @SuppressWarnings(\"unchecked\")\n    public static <T> TestObserver<T> createTestObserver()\n    {\n        Observer<T> delegate = mock(Observer.class);\n        return new TestObserver<T>(delegate);\n    }\n```\n"
    ],
    "1125": [],
    "1578": [
        "Yes.\n"
    ],
    "2601": [],
    "1579": [
        "Yes.\n"
    ],
    "6917": [],
    "1377": [],
    "5743": [],
    "820": [],
    "5051": [],
    "6095": [],
    "3307": [],
    "1594": [
        "I like Single but just to throw more alternatives, Observable1 or OneObservable can be considered to avoid mixing up with other class names/libraries.\n",
        "That is what this would be aiming to replace. Future is a really bad abstraction.\n",
        "> it's been a challenge to sift through the wiki finding just the methods I need for these kind of tasks\n\nThe `flatMap` operator would almost certainly exist on the `rx.Future`. For example, see the Twitter Future that has `flatMap`: https://twitter.github.io/util/docs/index.html#com.twitter.util.Future\n\nWhat makes the use of `flatMap` not intuitive on an `Observable` that has a single value versus multiple values?\n",
        "> What's \"unflat\" about a Scalar value? \n\nAn async continuation that returns another `Future` needs to be flattened:\n\n``` java\naFuture.flatMap(value -> {\n   return doWithThatReturnsAnotherFuture(value);\n})\n```\n\nIn that case the `flat` part is flattening the returned `Future`, otherwise you'd end up with a `Future<Future<T>>` rather than a `Future<T>`.\n\n> What part of the operation involves mapping of any kind\n\nThe function can `map` from `T` to `R` however you wish. \n\n``` java\nFuture<R> Future.flatMap(Func1<T, Future<R>> mapper)\n```\n\nIf there is no need to flatten then it would be `map`:\n\n``` java\nFuture<R> Future.map(Func1<T, R> mapper)\n```\n\nIf it is purely a side-effect, then the naming is up in the air but in RxJava thus far it is `doOn*` method names to signal the side-effects, so something like `doOnSuccess`/`doOnError` on a scalar `Future` and just pass the value through:\n\n``` java\nFuture<T> Future.doOnSuccess(Action1<T> sideEffect)\nFuture<T> Future.doOnError(Action1<Throwable> sideEffect)\n```\n",
        "> However I thought the more general question was whether RxJava would get a Task/Future like structure at all? \n\nYes, that's the more general question. I tend to think we should.\n\n> having a single library for all kinds of asynchronous things and with the possibility for interaction between structures ... would be even nicer.\n\nAgreed, which is why I want it part of RxJava. Most everything would be shared, mostly just the type signature would differ. \n",
        "Represent request/response of a single value. It is purely a design thing, not functional. Many, many people would prefer to represent scalar values such as IO request/response (think HTTP, REST, RPC) as a Future/Task but be able to merge them into Observable streams. It is one of the most common questions I get.\n\nRx.Net has it because .Net already has `Task` that works nicely with `Observable` since they were built for each other. The Java `Future` is unusable in this sense and `CompletableFuture` in Java 8 can be made to work but it's entire API design is incredibly different and they are always \"hot\". \n",
        "FYI, I plan on tackling this myself as we want to use it at Netflix for something. \n",
        "I'm still interested in pursuing this. The only thing holding us up right now is a final decision on what we should call it. \n\nIt seems `Single` is the name we are converging on: https://github.com/ReactiveX/RxJava/pull/2641#issuecomment-100985990\n\nAny reason not to merge an `@Experimental` version of `rx.Single`?\n",
        "@akarnokd I don't quite understand what you are proposing with the brackets: \"Scalar(Task, Observable, Future)\". What is meant by the (Task, Observable, Future) after the \"Scalar\"?\n\nI agree with @headinthebox on this that `Scalar` is not what we want here. Others agree: https://github.com/ReactiveX/RxJava/pull/2641#issuecomment-83744414 and https://github.com/ReactiveX/RxJava/pull/2641#issuecomment-85245426\n\nI also don't really like the idea of having a long name like `SingleObservable`. It can't be `Async` because the type can be either synchronous or asynchronous, just like an `Observable`.  We can't use `Future` as that collides too much. We could use `Task`, though it collides with some other `Task` definitions, and with the C# usage which behaves differently. Also, semantically `Task` doesn't seem right as a \"task\" is typically intended to mean a \"one-shot\" execution whereas this type could be invoked multiple times. \n\nThis brings us back to `Single` again. \n\n@akarnokd How about let's proceed with `Single` and let us all start using the code in the `@Experimental` state and over the next months of usage see if it feels right as an abstraction and name? Over the coming months we'll mature towards a final status in v1.1 or v1.2 and have a chance before then to change if we come to a different agreement?\n",
        "Here are examples of using `Single`:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.Single;\nimport rx.Single.Promise;\nimport rx.schedulers.Schedulers;\n\npublic class SingleExperiment {\n\n    public static void main(String... args) {\n        Observable<String> a_merge_b = getDataA().mergeWith(getDataB());\n\n        Single<String> a_and_b = getDataA().flatMap(t -> {\n            return getDataB().map(r -> t + r);\n        });\n\n        Single<String> a_transformed = getDataA().map(a -> a + \"_response\");\n\n        Observable<String> a_concat_b = getDataA().concatWith(getDataB());\n\n        /**\n         * This shows flatMapping a Single with an Observable\n         */\n        Observable<String> a_with_c = getDataA().flatMapObservable(a -> {\n            return getDataC().map(c -> a + \"-\" + c);\n        });\n\n        Single<String> aWithTimeout = getDataA().timeout(100, TimeUnit.MILLISECONDS);\n\n        Single<String> aWithTimeoutAndSimpleDefaultValue = aWithTimeout.onErrorReturn(t -> \"DefaultValue\");\n\n        /**\n         * We can use toObservable() for a Single to interact with an Observable.\n         * Or we can add the various overloads to Observable.merge/concat/zip/mergeWith/concatWith/zipWith/etc\n         * Adding the overloads though does result in a lot of API clutter.\n         */\n        getDataC().mergeWith(getDataA().toObservable());\n\n    }\n\n    public static Single<String> getDataA() {\n        return Single.<String> create(o -> {\n            o.onSuccess(\"DataA\");\n        }).subscribeOn(Schedulers.io());\n    }\n\n    public static Single<String> getDataB() {\n        return Single.just(\"DataB\")\n                .subscribeOn(Schedulers.io());\n    }\n\n    public static Observable<String> getDataC() {\n        return Observable.interval(10, TimeUnit.MILLISECONDS).map(i -> \"c\" + i);\n    }\n\n    /**\n     * Example of Single.Promise\n     */\n    public static Single<String> getDataD() {\n        Promise<String> p = Single.Promise.create();\n        new Thread(() -> {\n            p.onSuccess(\"data-d-from-thread\");\n        }).start();\n        return p.getSingle();\n    }\n}\n```\n",
        "Reposting a modified version of https://github.com/ReactiveX/RxJava/pull/2641#issuecomment-73593232 to provide reasoning for this proposal:\n\n---\n\nThe evolution of thinking after using RxJava for a couple years is that libraries that expose public APIs can benefit from being able to communicate if something is scalar or vector \u2013 despite the \"functional\" argument that a scalar is just a \"list of one\". We are able to choose to use `T` or `List<T>` when creating a synchronous API, so why not for async as well? In other words, why should the use of RxJava exclude communicating when we do know something is a scalar, which is a very common use case, and results in a simpler mental model? \n\nWhen composition occurs that results in multiple values then the type changes to an `Observable`. Not all composition and transformation requires this though \u2013 `zip`, `amb`, `map`, `flatMap` all can return `Single`. Others like `merge` will return an `Observable`. \n\nAnother consideration is that APIs that expose data access are generally separate from the consuming code that composes them, and it is these data access APIs where the scalar `Single` is most effective at providing communicating via a static type such as:\n\n``` java\nSingle<T> getData()\n```\n\nversus\n\n``` java\nObservable<T> getData()\n```\n\n> does this actually simplify anything?\n\nThere is one thing I think it simplifies that is more than just making it easier due to familiarity. It communicates when a user does NOT need to think about multiple values, and that does indeed simplify code. \n\nA `Single` will always behave in one of 3 ways:\n\n1) respond with an error\n2) never respond\n3) respond with a success\n\nAn `Observable` on the other hand may:\n\n1) response with an error\n2) never respond\n3) respond successfully with no data and terminate\n4) respond successfully with a single value and terminate\n5) respond successfully with multiple values and terminate\n7) respond successfully with one or more values and never terminate (waiting for more data)\n\nThe mental model for these extra possibilities do definitely increase the complexity and are a big part of the pushback for using RxJava that I have seen for request/response models. \n\nThese more complex models do still end up happening as soon as composition occurs, but now that composition is declared by the consumer, and the consumer knows the contract of the producer to be simpler if it is a `Single`.\n\nFor example, in \"service layer\" type code we could have getters like this:\n\n``` java\nSingle<T> getDataA(arg);\nSingle<R> getDataB(arg);\nObservable<R> getDataC(arg);\n```\n\nThis is now simpler to understand because the types narrow the scope for `A` and `B` so we know we don't need to consider multi-value or infinite cases (which generally need to be explained in the javadoc). The `C` type in contrast clearly indicates that it wants to support multiple values otherwise it would have just been a `Single`.\n\n> familiarity can always be learned, but complexity is harder to avoid\n\nMy thinking has evolved to think that trying to force everything to be a vector results in increased complexity of a different kind that can be addressed by a slight increase in complexity of the RxJava APIs (2 types instead of 1). Static types communicate common information that simplifies the mental model and constrains available states and operations that can be applied. This seems worth the increase in API surface area. \n",
        "> could you explain why there is a need for this embedded Promise type\n\n@sdeleuze it is not required and I should probably remove it. I added it to prove a common programming model.\n\nBelow are two ways of achieving the same thing. The first eliminates nesting but does involve an extra type. However, Promises are \"hot\" whereas the `Single.create` approach supports hot and cold execution. \n\n``` java\n    public static Single<String> getDataD() {\n        Promise<String> p = Single.Promise.create();\n        doStuffWithCallback(d -> p.onSuccess(d + \"-from-thread\"));\n        return p.getSingle();\n    }\n\n    public static Single<String> getDataE() {\n        return Single.create(o -> {\n            doStuffWithCallback(d -> {\n                o.onSuccess(d + \"-from-thread\");\n            });\n        });\n    }\n```\n",
        "An `@Experimental` version was merged in https://github.com/ReactiveX/RxJava/pull/3012\n",
        "> Rx.net has seamless integration between observable and task.\n\nYes, but RxJava hasn't. An integration/interfacing with Bolts could be an option instead of separate implementation, but it would probably require som changes to Bolts as well. Bolts, unlike RxJava, rely on [Executors](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html). \n\n> However without async await syntax, tasks/futures do not provide much advantage\n\nOver what? Observables? Simpler syntax and easier learning curve would be one. Right now I'm using Observables for Scalar data (HTTP responses) because that's the only thing [Retrofit](https://github.com/square/retrofit) supports, but it's been a challenge to sift through the wiki finding just the methods I need for these kind of tasks. [continueWith=flatMap](http://stackoverflow.com/questions/27107000/how-do-you-do-continuations-with-rxjava-observables)? Not intuitive. I simply feel I'm using the wrong tool for the job.\n",
        "> What makes the use of flatMap not intuitive on an Observable that has a single value versus multiple values?\n\nFirst and foremost the naming. \"FlatMap\" doesn't tell me anything. What's \"unflat\" about a Scalar value? What part of the operation involves mapping of any kind? Promise.then is much more descriptive to me. \n\nBut I realize it might be my background coming from Tasks in C# to Promises in Javascript and then Observables that might be \"polluting my mind\". I also might have misunderstood this isse. Maybe you could elaborate, since you're the OP?\n",
        "Ok thanks for taking the time to answer my questions, it made things clearer.\n",
        "https://github.com/BoltsFramework/Bolts-Java is the java version of .net's task.\nRx.net has seamless integration between observable and task. \n\nHowever without async await syntax, tasks/futures do not provide much advantage. I don't ever expect async await to be added to java BTW.\n",
        "`flatMap` in RxJava is `selectMany` in C#. Since you mention you know Tasks form C# you should read this http://blogs.msdn.com/b/pfxteam/archive/2013/04/03/tasks-monads-and-linq.aspx. Technically speaking the Task API is a so-called _co-monad_, but since they are _continuations_, Task can also be formulated as a monad. In Rx .NET we had `manySelect` for a while that corresponds to `continueWith`.\n",
        "Let's go for it!\n",
        "http://en.wikipedia.org/wiki/Scalar: \"Variable (computing), or scalar, an atomic quantity that can hold only one value at a time\". Why use a complex term like \"scalar\" when you just mean \"single\"?\n",
        "Can someone explain what this Future/Task should do, or more specifically, what is the underlying issue we want to solve that `Observable` or `Async` can't do (efficiency?)?\n",
        "`Single` sounds odd to me. Here are my candidates: Scalar(Task, Observable, Future), Single(Task, Future), Async(Task, Scalar, Future), ObservableScalar; however, I suspect most combinations are already taken by some other library.\n\nEdit: `Just`.\n",
        "@benjchristensen I meant potential postixes, i.e., ScalarTask, ScalarObservable or ScalarFuture, etc.\n\nSince we will use the experimental annotation, let's proceed with `Single` and come back to the name in a few months once enough use experience has been accumulated.\n",
        "I would also be curious to see what value this adds other than introducing a concept that developers familiar with other frameworks or languages are used to. So just to play devil's advocate: if `Observable` is semantically a superset of `Task` as it's capable of producing N results rather than just 1 (and N can be 1), does this justify introducing a new type? I am worried that this really only adds cognitive overhead and redundancy, as we're essentially dealing with the same thing, but one is a specialization of the other? Will people start asking when to use a Task and when to use an Observable?\n\nI should add that we use almost always scalar Observables in our app, and I never thought that it feels awkward. An `Observable.just(list)` seems no more or less confusing to me than a `Future.value(list)` (to draw the comparison again to Twitter's composable Futures.)\n\nThat said, is the actual problem we're trying to solve one of naming and expectation, because people are looking at Observable and expecting a Scalar, because that's what Futures do? So is the problem more discoverability of the API rather than a gap in functionality?\n\nI do need to say here that if I had to pick one design aspect of RxJava that I think really stands out, then it's its universal applicability, and that's partially because of a healthy lack of assumptions--emitting a single result is an assumption--and I find this to be a powerful combination in library design.\n",
        "I think I meant to respond on the PR, as the discussion seemed to have moved there. Sorry.\n",
        "As said in the PR comments, I fully agree with the need to have a scalar observable type, especially when exposing such type in application public API.\n\nThe main thing that confuses me in the implementation proposal is the embedded `Task.Promise` type. I understand this is done differently in .NET since `Task` already exists, but on other platforms I would just expect a single type that I would expose in my API instead of `Observable` for scalar result.\n",
        "@benjchristensen I like this new proposal but could you explain why there is a need for this embedded `Promise` type?\n",
        "I think it's confusing, because the http://reactivex.io/intro.html first array tells that for single item, the concept to use is a Future.\n",
        "Would obs.toSeq, obs.single return Task? Certainly I'd like to see that but we'd need to make sure that doesn't interfere with people who don't want to use Task ...\n",
        "I really would love to see this because of 2 reasons:\n- There is no good (async & composable) `Future` type in the Java standard library if you have to target < Java8. Even with `CompleteableFuture` available this uses executors for the continuations. For an RxJava integration using an Rx Scheduler is a better match - we can then receive Observable events and Future continuations on the same scheduler.\n- The alternative is using an AsyncSubject. The problem with AsyncSubject is that the user only sees an `Observable` in the API and thereby won't know that it emits only a single item. He also won't know if it's hot (the function call which returns the `Observable` will immediatly start an operation without the need for `Subscribe()` or not (needs `Subscribe()`). Therefore I think the ability to model such single return-value async operations with Futures makes an API better understandable.\n",
        "I think the issue here is that `flatmap` is a description what happens in general whereas `then` or `continueWith` describe it in a more concrete way for the `Future` type.  \nSome time ago I had no experience with FP programming, so `flatmap` didn't tell me anything. However `continueWith` is more self-describing so I could understand it and it's easier to discover in an API documentation. I like it. But as I later learned that `then/continueWith` are equivalent to `flatmap` so now I understand it too. Maybe the same applies to other users?  \nWhy not expose both function signatures? Don't think it would be a problem and I think it would make the familarity higher for OO as well as FP programmers.\n\nHowever I thought the more general question was whether RxJava would get a Task/Future like structure at all? I would still like to see it. Bolts looks good, but having a single library for all kinds of asynchronous things and with the possibility for interaction between structures (futures to observables and the other way around, sharing of schedulers, ...) would be even nicer.\n"
    ],
    "3733": [],
    "1374": [],
    "156": [],
    "793": [],
    "1398": [],
    "665": [],
    "220": [],
    "4064": [],
    "1651": [],
    "1610": [],
    "4882": [],
    "3357": [],
    "2966": [],
    "379": [],
    "3253": [],
    "6895": [],
    "1961": [],
    "1567": [],
    "5987": [],
    "4467": [],
    "3129": [],
    "4606": [],
    "1014": [],
    "5771": [],
    "1642": [
        "I have also encountered this issue with RxJava 0.20.4. Here is a minimal test method that exhibits the issue:\n\n``` java\n@Test\npublic void combineLatestNullCombinerFailureTest() {\n\n    // Create source subjects. Types don't matter, Integer arbitrarily chosen.\n    PublishSubject<Integer> subject0 = PublishSubject.create();\n    PublishSubject<Integer> subject1 = PublishSubject.create();\n\n    // Create a function that ignores inputs and always returns a null Integer\n    Func2<Integer, Integer, Integer> nullIntegerReturningCombiner = new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer i0, Integer i1) {\n            return null;\n        }\n    };\n\n    // Create the combine-latest observable\n    Observable<Integer> combineLatestObservable = Observable.combineLatest(\n            subject0, subject1, nullIntegerReturningCombiner);\n\n    // Create an observer that simply asserts that any emission is null on any emission\n    Observer<Integer> combineLatestObserver = Observers.create(new Action1<Integer>() {\n        @Override\n        public void call(Integer shouldBeNull) {\n            Assert.assertNull(shouldBeNull);\n        }\n    });\n\n    // Subscribe the observer to the combine-latest observable\n    combineLatestObservable.subscribe(combineLatestObserver);\n\n    // Produce a single emission from each subject. Emission values don't matter, arbitrarily chosen.\n    subject0.onNext(0);\n    subject1.onNext(1);\n\n    // The second emission above results in a ClassCastException, with the following (abbreviated) stack trace,\n    // as of RxJava 0.20.4:\n    //\n    // rx.exceptions.OnErrorNotImplementedException: rx.internal.operators.NotificationLite$2 cannot be cast to java.lang.Integer\n    //     at rx.Observable$36.onError(Observable.java:8416)\n    //     at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)\n    //     at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)\n    //     ...\n    // Caused by: java.lang.ClassCastException: rx.internal.operators.NotificationLite$2 cannot be cast to java.lang.Integer\n    //     at RxJavaCombineLatestTest$2.call(RxJavaCombineLatestTest.java:28)\n    //     at rx.Observable$36.onNext(Observable.java:8421)\n    //     at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:105)\n    //     ...\n}\n```\n\nI agree with @DylanSale that there may be a problem in the OnSubscribeCombineLatest tick() operation, but my proposed fix is slightly different.\n\nNotificationLite.ON_NEXT_NULL_SENTINEL is private and should not be publicly exposed. However, NotificationLite includes a getValue(Object n) operation which does the check for the ON_NEXT_NULL_SENTINEL instance and returns properly typed null if it is encountered.\n\nMy suggestion is to replace:\n\n``` java\nchild.onNext((R) o)\n```\n\nwith:\n\n``` java\nchild.onNext(NotificationLite.<R> instance().getValue(o))\n```\n\nin the tick() operation.\n",
        "I have a proposed workaround while we await review of this issue. Change the return type of the combiner Func2 to Object to avoid the ClassCastException, and introduce a mapping function that uses the NotificationLite getValue() method to handle the null sentinel value if encountered.\n\nIn my test case above, the changed blocks would be:\n\n``` java\n...\nFunc2<Integer, Integer, Object> nullIntegerReturningCombiner = new Func2<Integer, Integer, Object>() {\n    @Override\n    public Object call(Integer i0, Integer i1) {\n        return null;\n    }\n};\n...\ncombineLatestObservable\n    .map(new Func1<Object, Integer>() {\n        @Override\n        public Integer call(Object o) {\n            return NotificationLite.<Integer> instance().getValue(o);\n        }\n    })\n    .subscribe(combineLatestObserver);\n...\n```\n\nI have created a generic function to encapsulate the mapping part of this workaround, as follows:\n\n``` java\npublic static <T> Func1<Object, T> combineLatestWorkaround() {\n    return new Func1<Object, T>() {\n        @Override\n        public T call(Object o) {\n            return NotificationLite.<T> instance().getValue(o);\n        }\n    };\n}\n```\n\nWherever I have a combineLatest observable with a combiner function that may (validly) emit null values, I have applied this workaround for the time being.\n",
        "My thanks @edenman for taking the time to create a pull request. Here's hoping it makes it into the RxJava 1.0.0 release.\n",
        "I put together a PR that fixes this issue with @gfee's suggested fix and adds a test to confirm the breakage/fix: \nhttps://github.com/ReactiveX/RxJava/pull/1705\n",
        "@benjchristensen thanks for merging the PR! can probably close this issue now.\n",
        "Thank you!\nOn 30 Sep 2014 03:31, \"edenman\" notifications@github.com wrote:\n\n> I put together a PR that fixes this issue with @gfee\n> https://github.com/gfee's suggested fix and adds a test to confirm the\n> breakage/fix:\n> #1705 https://github.com/ReactiveX/RxJava/pull/1705\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/ReactiveX/RxJava/issues/1642#issuecomment-57202005.\n"
    ],
    "6885": [],
    "5437": [],
    "4423": [],
    "6197": [],
    "3951": [],
    "5195": [],
    "1668": [
        "Moving to 1.x as this is additive and non-essential.\n",
        "The other way we could do this is make `Observable` methods non-final and then we could change the return types on all of the methods in `GroupedObservable` ... but need to keep the methods in sync (whenever we add one to `Observable` we'd need to add the cover method to `GroupedObservable` to change the return type).\n",
        "Or we make `GroupedObservable` not extend from `Observable` and only have the operators desired for it ... and then `toObservable()` to get all other operators.\n",
        "... or we just admit it was wrong to remove `GroupedObservable.from` and bring that back.\n\nDiscussing with @headinthebox the options for solving this (due to Java restrictions) are not pleasant and the single use case where this is needed is probably best solved by keeping `GroupedObservable.from`.\n\nTo summarize:\n\n1) We make methods in `Observable` non-final and override all of them in `GroupedObservable` with a new return type.\n\nPro: it works.\nCon: massive maintenance to keep methods and javadocs synced between the two\nCon: allowing overrides of methods on `Observable`\n\n2) We make `GroupedObservable` not extend from `Observable` and implement all operators in `GroupedObservable`\n\nPro: it works while leaving methods final in `Observable`\nCon: massive maintenance to keep methods and javadocs synced between the two\nCon: combinatorial operators in `Observable` must now have overloads for `GroupedObservable` such as on `flatMap` and `merge` otherwise `GroupedObservable` won't work with them since it's not an `Observable` any longer\n\n3) Restore `GroupedObservable.from` for the use cases where a `GroupedObservable` needs to be passed around after modifying it into an `Observable`.\n",
        "@headinthebox and I feel that despite (c) being ugly, it's the simplest. \n",
        "Added `GroupedObservable.from` and `GroupedObservable.create` in https://github.com/ReactiveX/RxJava/pull/1789\n"
    ],
    "752": [],
    "3235": [],
    "1673": [
        "I'm in favor of removing it, as you say it's mostly used incorrectly and someone who wants to control parallelism can always use the ExecutorScheduler.\n",
        "@davidmoten Those signatures don't take a function with the work to do while in parallel so aren't correct. \n\nI suggest we remove them and allow a new RxJavaParallel project to explore alternatives and only once it is proven and matured to merge it into RxJava itself. This would include something like a `ParallelObservable` that allows `map`, `flatMap`, `take`, `filter` and other basic operators to execute in parallel without the normal serialized emission restriction.\n",
        "Work on `ParallelObservable` will be done in https://github.com/ReactiveX/RxJavaParallel\n",
        "This has been completed and will be released in 0.20.5 and 1.0 RC4.\n\nAnyone looking for a replacement to the simple \"run things in parallel\" use case, you likely want this:\n\n``` java\nstreamOfItems.flatMap(item -> {\n   doStuffWithItem(item).subscribeOn(Schedulers.io());\n});\n```\n\nThe `doStuffWithItem` needs to return an `Observable` obviously ... but the point is kick off your work for each item inside `flatMap` using `subscribeOn` to make it async, or with a function that already makes the calls be async.\n",
        "@rishi-anand please post your question on StackOverflow with details on what you have already implemented.",
        "Hi, @benjchristensen , @davidmoten , @jbripley , I agree with using flatMap(). I have 1 question, flatMap will do the operation and merge it back to main thread and onNext() will be called. What if one Observable ends with Observable.error() in that case Observable.error() will be called in main thread? If yes, then main thread will shut down and what will happen to other Observables running in parallel? If no, then result from other Observable will be triggered in onNext?\r\n\r\nCorrect me If I am wrong as I have just started with RxJava.",
        "Thanks for raising this one, it's been on my list to mention. \n\nA while back I used the parallel method for an HPC task and found it confusing. I expected to find Scala collections `par` method or equivalent but not to be found. For clarity's sake I later switched the code to use `flatMap`+`onSubscribe` to get the desired behaviour. I think the existing method tries to do too much (why get it to apply the sharding function when it could be done prior). \n\nCould we simplify `Observable.parallel` so it just does:\n\n```\nObservable<T> parallel() {\n    return flatMap( o -> o.subscribeOn(Schedulers.computation()));\n}\n```\n\nand an overload to specify the scheduler:\n\n```\nObservable<T> parallel(Scheduler scheduler) {\n  return flatMap( o-> o.subscribeOn(scheduler));\n}\n```\n",
        "Oh yeah woops, the merge means the parallel is lost. So I wonder what the rx-java analogy to the Scala collections par method is?\n",
        "I suppose it's likely to be \n\n```\nObservable<Observable<T>> parallel() {\n    return map( o -> just(o).subscribeOn(Schedulers.computation()));\n}\n```\n\nI wonder if that's of use?\n",
        "I just had a look at Scala's `par` and it looks like it returns a special Parallel instance of the collection in question. So the analogy would be \n\n```\nParallelObservable<T> parallel(Scheduler scheduler) {\n    return new ParallelObservable<T>(this, scheduler);\n}\n```\n\nwhere `ParallelObservable<T>` is really `Observable<Observable<T>>` under the covers but you can interact with it as though it is `Observable<T>`. I imagine that `ParallelObservable.subscribe` would perform the flatten before normal subscription.\n\nBlimey I've got reading problems, Ben suggested exactly this. Ta Ben.\n"
    ],
    "5581": [],
    "770": [],
    "4893": [],
    "3840": [],
    "1789": [],
    "814": [],
    "1682": [
        "I know this isn't possible for even 1.0 but could `Subscription schedule(Action0 action)` be changed to\n`Observable<Void> schedule(Action0 action)`. That way the caller can get both the ability to subscribe to get the subscription and notification of completion or failure.\n",
        "The added logging is nice, but why not continue throwing the error if it's fatal (like `OnErrorNotImplemented`)? Minus `observeOn` your program would crash because you aren't handling the exception - it wouldn't just log the exception.\n",
        "Thanks, I understand the problem a lot better now. I'll have to think on it; not sure there is a good solution.\n",
        "I've been researching this and there isn't a whole lot of choice in what to do when an Exception is thrown on a random `Scheduler.Worker` thread beyond catching and printing the error using `System.err`.\n\nI can't throw the exception anywhere else as the whole issue here is an unhandled exception being thrown.\n\nThus, I'm going to catch the exceptions in `ScheduledAction` and `e.printStackTrace()` them with a warning about exceptions being thrown.\n\nThis is an edge case that an app should not allow ... and the reason why Observables propagate errors as events ... to avoid this very case, so seeing these types of messages in log output signals a \"bad thing\" that should be resolved. \n\nThis would NOT be good for system performance to allow these types of errors to be logged, but I feel this is far better to yell and scream about bad code rather than silently swallowing errors as it does now.\n",
        "An error such as this will be printed:\n\n```\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:46)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$36.onError(Observable.java:7387)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:177)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$0(OperatorObserveOn.java:161)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:153)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)\n    ... 7 more\nCaused by: java.lang.RuntimeException\n    at rx.exceptions.ErrorsOverAsyncBoundaries.testSubscriberOnErrorFails(ErrorsOverAsyncBoundaries.java:43)\n```\n",
        "I have merged the change. If anyone can suggest a better approach that would be great, please let me know here.\n",
        "@dlew how would you solve this differently? The error is occurring on a separate thread, so the most violent death that can occur is killing that thread inside the ThreadPoolExecutor. The error can not propagate to the `main` thread and thus does not kill the JVM.\n\nThe `Throwable` gets caught inside `java.util.concurrent.FutureTask`:\n\n``` java\n    public void run() {\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex); //  <------------- THIS IS WHERE THE EXCEPTION GOES\n                }\n                if (ran)\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\nOne can use `ThreadPoolExecutor.afterExecute` to extract the caught error, but rethrowing only causes the `ThreadPoolExecutor` to kill the thread, not the JVM since it can't propagate to the `main` thread (the nature of async): http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable,%20java.lang.Throwable)\n\nThe only alternative I can think of is to reverse schedule events up the Observable chain, like having an `onError` on the `Observable.OnSubscribe` and having a `Scheduler` on the producing side, not just the consuming side. That however is a crazy amount of overhead and infrastructure for a degenerate case. \n\nIf you can submit a pull request that offers a better solution I'd appreciate that.\n",
        "A calling thread could not get a reference, as `void onNext` is the signature the caller invokes. It is on the wrong side of the thread where the exception is caught, scheduled from inside the `onNext`. The calling (parent) thread has already left by the time the child thread throws the exception. \n\nThere is no issue catching the exception on the child thread, it's what to do with it that is the question. \n",
        "ObserveOn propagates errors downstream. We just can't send them upstream across thread boundaries. \n",
        "Would you prefer that over this:\n\n> Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n\nI've never that so have no idea how it behaves especially with thread pools. \n",
        "That sounds good, since then we are free to add listeners at any of the 3 levels, but just registering the default global listener (most likely) will still work and it will propagate to it.\n\nhttp://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html\n\n> When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.\n\nThanks for bringing this to my attention @loganj I honestly wasn't even aware of this capability in the JVM and my use cases don't generally result in uncaught exceptions so I hadn't ever gone looking for it.\n",
        "I have not tried this issue on TrampolineScheduler but that may be okay as it's all on the same thread. ExecutorScheduler probably does need this, but let's get it solved for `ScheduledAction` first and then we can go fix that one in a separate PR.\n",
        "I have confirmed this fix is working nicely after the changes by @loganj in #1766 \n",
        "Best of the worst.\n",
        "It would be great if we could add another plugin that gets called in place of the `printStackTrace`.  Similar to `RxJavaErrorHandler`, but only for otherwise unhandled errors.\n",
        "No, you're right, we can just use the built-in handler mechanism directly.\n\nWe go directly `Thread.getDefaultUncaughtExceptionHandler()` today, but that's probably wrong.  That handler is the global last-resort handler for all threads.  It looks like what we really want is `Thread.currentThread().getUncaughtExceptionHandler()`.\n\nI'll get a PR together.\n",
        "No problem, we're really good at making exceptions happen.\n\nI'm basically done, but not sure if I should I apply the same handling to Schedulers that don't use ScheduledAction.  ExecutorScheduler _seems_ to need it.  What about ImmediateScheduler and TrampolineScheduler?  Do people rely on their current throwing behavior?  Is that behavior contractual?\n",
        "There is a related discussion here: https://github.com/ReactiveX/RxJava/issues/969\n\nI haven't checked in a while, but IIRC part of the issue was that some operators like ObserveOn weren't forwarding errors?\n"
    ],
    "1262": [],
    "1684": [
        "I prefer `countLong` as well. We used `longCount` because of .Net but `countLong` makes more sense.\n",
        "@headinthebox Are you okay with changing to `countLong` so it shows up alphabetically?\n",
        "Rx .NET uses the same name.\n\nhttp://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.100).aspx\n",
        "Let's do it. \n\n(It has advantages to be dyslectic ;-)\n",
        "I'm also in slight favour of `countLong`. You can spot it much easier in the IDE and it keeps it consistent with the regular `count`.\n"
    ],
    "1685": [
        "Yes, it is by design that if an error handler is not provided, but an error occurs it will throw `OnErrorNotImplementedException`. We never swallow errors automatically.\n\nIf you want to swallow an error prior to the subscribe you can do something like this:\n\n``` java\nstream.onErrorResumeNext(t -> Observable.empty()).subscribe();\n```\n\nThe `subscribe` overloads that don't take an error handler assume you are handling the error cases in the stream, or that errors \"won't happen\". \n",
        "The hang may be that you're not seeing the `OnErrorNotImplementedException` be thrown due to the scheduling happening on delay: https://github.com/ReactiveX/RxJava/issues/1682\n\nI haven't confirmed, but you should definitely see an exception be thrown somewhere.\n",
        "This one was kind of tricky ... I have to catch the error and wait until all subscribers receive the `onError` and then allow it to be thrown so that all subscribers are released.\n\nGreat bug. Thanks for reporting this.\n",
        "The plain `subscribe()` has an onError handler which throws an `OnErrorNotImplementedException` and disrupts the event delivery inside the `PublishSubject`.\n",
        "The following example hangs\n\n``` java\n    ReplaySubject<Object> subject = ReplaySubject.create();\n\n    Observable.error(new RuntimeException(\"oops\"))\n        .materialize()\n        .delay(1, TimeUnit.SECONDS)\n        .dematerialize()\n        .subscribe(subject);\n\n    subject.subscribe();\n    subject.materialize().toBlocking().first();\n\n    System.out.println(\"Done\");\n```\n\nwhere as \n\n``` java\n    ReplaySubject<Object> subject = ReplaySubject.create();\n\n    Observable.error(new RuntimeException(\"oops\"))\n        .materialize()\n        .delay(1, TimeUnit.SECONDS)\n        .dematerialize()\n        .subscribe(subject);\n\n    subject.subscribe(n -> {}, e -> {});\n    subject.materialize().toBlocking().first();\n\n    System.out.println(\"Done\");\n```\n\ndoes not. \n",
        "Is that by design?\n",
        "@benjchristensen? \n\nWe're trying to see if we need to stop using subscribe() without an onError handler due to this behavior even when we don't need to handle the error notification.\n"
    ],
    "4645": [],
    "491": [],
    "1688": [
        "Pull request is merged.\n",
        "I think I see what to do to fix. I'll make a PR. If someone is already working on it let me know and I'll stop.\n"
    ],
    "1223": [],
    "1134": [],
    "6826": [],
    "5883": [],
    "1702": [
        "Thanks for the report. I'll take a look.\n",
        "Fixed (I hope) in #1736 \n",
        "Hi. Fixed in 1.x branch via #2471. Can you verify the fix works for your case?\n"
    ],
    "3556": [],
    "3896": [],
    "6291": [],
    "4912": [],
    "4469": [],
    "4024": [],
    "2928": [],
    "254": [],
    "1724": [
        "Interesting ... so yes, `merge` almost gets the behavior we want, but it then allows concurrent execution and that means we can get things out of order which we can't allow. \n\nFiguring out what needs to be done...\n",
        "Just merged a fix that I believe resolves this while making it work with backpressure.\n",
        "Nice catch.\n"
    ],
    "218": [],
    "437": [],
    "4428": [],
    "2968": [],
    "1741": [
        "I think deleting `EmptyObserver` is the best approach. It serves no value.\n",
        "I deleted `EmptyObserver` and updated the `Observers.empty()` javadocs to be clear that it throws `OnErrorNotImplementedException`. \n\nIf someone wants to swallow errors they need to actively code for that. RxJava will not swallow errors itself.\n",
        "Like!\n"
    ],
    "4580": [],
    "115": [],
    "1744": [
        "See https://github.com/ReactiveX/RxJava/pull/1745 for proposed addition.\n",
        "/cc @headinthebox \n",
        "Thanks for the review. Merged. This will simplify our answer to the \"event bus\" use cases that often are done with Subjects.\n\nI just had one show up in Netflix prod this week that was breaking things because it wasn't thread-safe :-)\n",
        "@akarnokd I haven't added instance methods to `Subject` as I'm being very conservative about those types of things. Once added we can't remove them any longer as we're just about to hit 1.0 and we have shown over the past year that it is easy to add something in the name of ease that we later regret.\n\nI'm not a fan of making Observable instance methods non-final, but it's always an option of course. \n\nTherefore at this point I've only added the `SerializedSubject` type which is very non-intrusive, matches the existing pattern of `SerializedObserver` and `SerializedSubscriber` and would be needed for a `toSerialized()` or `.serialize()` instance method.\n\nWe can open a new issue for discussing the addition of the instance methods and spend more time getting consensus on that.\n",
        "Opened issue https://github.com/ReactiveX/RxJava/issues/1748 for discussion of instance methods.\n",
        "Cool with it, the explicit solution is tricky. And if we have `SerializedXXX` why not also `SerializeXYZ`.\n",
        "That is another option.\n",
        "Why not have a `.toSerialized()` method on the `Subject` instance? Alternatively, if `Observable.serialize()` wouldn't be final, `Subject` could override it and return a `Subject`.\n"
    ],
    "5797": [],
    "2855": [],
    "1748": [
        "Moving to 1.0 as this is easy to add.\n",
        "> we can call xs.toSerialized().....toSerialized()\n\nI can do that on an `Observable` as well.... `observable.serialize().serialize().serialize()`\n\n> if the semantics of toSerialized are \"make sure that it's a serialized subject\"\n\nYes it can check that is in an instance of the already wrapped Subject and not wrap again. \n",
        "The signature could be:\n\n``` java\npublic SerializedSubject<T, R> toSerialized();\n```\n\nThis way it is clear what is being returned.\n",
        "I added `toSerialized`. I did not make `SerializedSubject` an interface because it follows the same pattern as `SerializedObserver` and `SerializedSubscriber`. The \"serialized\" part IS the implementation of the `Subject`.\n\nEven if we were to make `SerializedSubject` into an interface we'd also need to make `SerializedObserver` and `SerializedSubscriber` into interfaces. \n\nAlso, there are really only 3 ways to approach this that I'm aware of:\n- Using blocking synchronization. We are trying to avoid that. We used to have `SynchronizedObserver` and replaced it with `SerializedObserver`. \n- Using queues and thread-stealing to push through. This is the model `SerializedObserver` and `SerializedSubject` use.\n- Using an MPSC queue with a separate thread to drain (standard producer/consumer). We don't want to add extra concurrency so are avoiding that. If an extra thread is wanted then `observeOn` is the answer.\n\nThus, there is really only one approach we want for this, and that is the `SerializedObserver` approach, hence `SerializedSubject`, which is an implementation of `Subject` that adds the `Serialized` capability.\n",
        "> public SerializedSubject<T, R> toSerialized();\n\nIf using this one, the case mentioned by @samuelgruetter cannot work.\n\n> This would also be extensible, because users could add a MyOwnSerializedSubject, which does not extend SerializedSubject, but only Subject, and also returns this in the toSerialized method.\n",
        "It is sad that Java has no extensions methods. \nHowevere it is a bit weird since (Imassume) serialized subject is also a subject, so we can call xs.toSerialized().....toSerialized()\n\nI vote to keep things as is for now.\n",
        "Sounds good.\n",
        "I agree with @headinthebox that  `xs.toSerialized().....toSerialized()` looks a bit weird at first sight, but if the semantics of `toSerialized` are \"make sure that it's a serialized subject\" instead of \"wrap the subject in a serialized subject\", it makes sense. That is, the default implementation in `Subject` would be to return a `new SerializedSubject`, and `SerializedSubject` would override it and just return `this`. This would also be extensible, because users could add a `MyOwnSerializedSubject`, which does not extend `SerializedSubject`, but only `Subject`, and also returns `this` in the `toSerialized` method.\n",
        "We could make an abstract `SerializedSubject` class which is just for labelling, and rx would provide a default implementation.\n"
    ],
    "246": [],
    "548": [],
    "891": [],
    "374": [],
    "3167": [],
    "6799": [],
    "1296": [],
    "4290": [],
    "1759": [
        "I have used it in the Turbine project with success. \n\nHelp me confirm the confusion, is it because it has both `onNext(T)` and `onNext(T, timeInMilliseconds)`?\n\nIf that's why then yes I can see why it's confusing. It works, but only if you know how to use it. \n\nHere is an examples of me using it: https://github.com/Netflix/Turbine/blob/22246ce26d812813e2a242d2f42cfc432a45a8b2/turbine-core/src/test/java/com/netflix/turbine/aggregator/StreamAggregatorTest.java#L604\n",
        "@headinthebox Do you have an opinion on keeping or removing this? I'm okay removing it due to its confusion.\n",
        "Added docs in https://github.com/ReactiveX/RxJava/pull/1796 while reviewing with @headinthebox \n",
        "+1 for removing TestSubject\n"
    ],
    "4112": [],
    "1777": [],
    "4824": [],
    "3402": [],
    "5569": [],
    "2573": [],
    "1772": [
        "I'm open to that. Want to submit a pull request?\n",
        "Merged.\n",
        "went ahead and implemented the method (see pull request)\n"
    ],
    "6091": [],
    "3327": [],
    "6876": [],
    "4070": [],
    "1782": [],
    "6839": [],
    "1785": [
        "Pull request if we agree -> https://github.com/ReactiveX/RxJava/pull/1788\n",
        "@headinthebox and I reviewed and agreed. The methods are removed.\n"
    ],
    "3424": [],
    "5935": [],
    "1791": [
        "Manually merged in https://github.com/ReactiveX/RxJava/pull/1793\n\nThank you @alexwen for submitting a bug report and then this fix!\n"
    ],
    "1446": [],
    "4690": [],
    "1797": [
        "This has nothing to do with Java 8 vs 7. It's about RxJava not including non-essential functionality. The fact that we accrued a few random utility functions is not reason enough to keep them and sets precedent for adding more (which is generally not wanted). So why should these be kept? They are rarely used and trivial to implant in an application if needed. \n",
        "Thanks for the feedback.\n",
        "I was using this... but I suppose it is easy enough to roll you own.\n",
        "I use them, I'd vote for keeping them as support for < Java 8 (my work codebase is still at Java 7 and will stay that way till next year sometime). I'm not very interested in `returnNull`.\n",
        "I checked my codebase and I use very little so I'm happy for them to be removed. \n"
    ],
    "1798": [],
    "1799": [
        "I added them to support the join patterns but only onErrorFrom was ever used. They can be deleted from core but onErrorFrom needs to be moved over and actualized in Plan1...PlanN.\n"
    ],
    "4712": [],
    "1804": [
        "The only thing in rc8 that seems related is this: https://github.com/ReactiveX/RxJava/pull/1793\n",
        "I can not replicate with this code:\n\n``` java\nimport java.util.List;\n\nimport rx.functions.Func1;\n\npublic class Testing {\n\n    public static void main(String... args) {\n        List<String> subThings = Observable.range(0, 1000)\n                .map(new Func1<Integer, String>() {\n\n                    @Override\n                    public String call(Integer i) {\n                        return String.valueOf(i + 1);\n                    }\n\n                })\n                .filter(new Func1<String, Boolean>() {\n\n                    @Override\n                    public Boolean call(String t) {\n                        return t != null;\n                    }\n\n                }) //\n                .distinct() //\n                .toList() //\n                .toBlocking() //\n                .single();\n\n        System.out.println(subThings);\n    }\n}\n```\n",
        "The code that is being interrupted is this: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/observables/BlockingObservable.java#L473\n\n``` java\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted while waiting for subscription to complete.\", e);\n        }\n```\n\nThis means the thread was blocked on the latch waiting for a result but while it was waiting it got interrupted. \n\nI don't know what thread you are doing this on, nor do I know much about Android. If Android is using pools of threads it could perhaps retain the right to interrupt and reclaim threads? I know event loops in some frameworks do that kind of thing if something is blocked in them and new work is scheduled. \n\nRxJava itself does not interrupt threads anywhere (that I'm aware of ... and I can't think of any reason we would) so I'm inclined to suggest looking at what thread you are blocking in and see if Android itself could be interrupting it?\n\nAlso, could you move to a model where you don't block and instead compose it all together reactively?\n",
        "Moving to 1.0.x as it's not obvious yet what is going on here.\n",
        "Does Android ever interrupt a thread based on user or system activity? If so then the `toBlocking()` will always be vulnerable to interruption since anytime a thread is blocked/waiting it can be interrupted. \n\nIs request.onNext ever being called concurrently, or is it sequentially? I can't tell for sure but it looks okay as it looks like it's only ever the single UI thread that would trigger an onNext. If you intend on calling it concurrently wrap it in a SerializedSubject.\n\nIf the UI event listener triggers before `ObserveThings.start` completes then `request` may not yet be initialized, or the pipeline may not yet be initialized. It looks like that could be race condition ... but I don't understand how `MainActivity` works well enough. Is that all on the UI thread, or does a background thread do that and then the `setOnClickListener` register with the UI thread?\n\nI don't particularly see anything wrong in this code ... though to be more idiomatic I would suggest using the Observable sequence to manipulate the data instead of doing it inside the `subscribe`. You really should never need to use `toBlocking`. The only 3 times that is ever intended are:\n\n1) Example code in a main method\n2) Unit tests (and even then you should probably use TestSubscribe.awaitTerminalEvent instead)\n3) Bridging between a blocking and non-blocking system, such as a Servlet \n\nIn this case, instead of doing flatMap.subscribe(all logic here) do something like this instead:\n\n``` java\nrequest.flatMap(mapResult)\n.map(transformFunction)\n.filter(notNull())\n.distinct()\n.toList()\n.subscribe(yourListHere)\n```\n\nThis is more idiomatic, doesn't involve creating another Observable and never requires doing the `toBlocking` stuff.... which is kind of the point of Rx. You should only ever have 1 subscribe at the very end of your flow and it should just be the side-effect, no actual processing in it.\n",
        "@edenman\n\n> Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.\n\nCan you provide a reference to documentation about how Android does this? That would be helpful. If it does this then any sort of blocking would be vulnerable to interruption. \n\n> Not everyone have their entire codebase under their control.\n\nUnderstood, though I still suggest putting most of the processing into the Observable chain and not even having a `subscribe` step and just going direct to `toBlocking()` if you actually are just using it as an Iterable with higher-order functions. \n",
        "If this doesn't happen on rc7 but does on rc8 then let's binary search what is causing it. Here is what changed: https://github.com/ReactiveX/RxJava/releases/tag/v1.0.0-rc.8\n\nThis is the only change that may be related: https://github.com/ReactiveX/RxJava/pull/1793/files\n\nNote how it now triggers the unsubscribe upwards before the onNext is emitted whereas before it was after.\n\nThis could theoretically result in work upstream canceling a Future which interrupts a thread if everything is happening on the same thread. \n",
        "> Maybe worth seeing if it's rxjava itself that is interrupting the thread?\n\nYup, I pointed to a change in rc8 above that could potentially cause this. I'm trying to hunt down options. \n",
        "Here are the two places I can see that may result in an interrupt:\n- https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/subscriptions/Subscriptions.java#L102\n- https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java#L65\n\nThe first one is used by virtually all use of Schedulers to allow canceling work on a Scheduler. \n\nI still can't replicate an interrupt with `take` but conceptually I can see how an interrupt could happen.\n",
        "I can replicate:\n\n``` java\n    @Test\n    public void testInterrupt() throws InterruptedException {\n        final AtomicReference<Object> exception = new AtomicReference<Object>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {\n\n            @Override\n            public void call(Integer t1) {\n                try {\n                    Observable.just(t1).toBlocking().single();\n                } catch (Exception e) {\n                    exception.set(e);\n                    e.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }\n\n        });\n\n        latch.await();\n        assertNull(exception.get());\n    }\n```\n\n```\ncancelling ... and can interrupt\njava.lang.RuntimeException: Interrupted while waiting for subscription to complete.\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:475)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:349)\n    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:376)\n    at rx.internal.operators.OperatorTakeTest$12.call(OperatorTakeTest.java:1)\n    at rx.Observable$31.onNext(Observable.java:7209)\n    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:104)\n    at rx.internal.operators.OperatorTake$1.onNext(OperatorTake.java:70)\n    at rx.internal.operators.OnSubscribeRedo$2$1.onNext(OnSubscribeRedo.java:229)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onNext(OperatorSubscribeOn.java:76)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:41)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:1)\n    at rx.Observable.unsafeSubscribe(Observable.java:7374)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:45)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.InterruptedException\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)\n    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:472)\n    ... 20 more\n```\n\nReverting https://github.com/ReactiveX/RxJava/pull/1793 does fix this.\n\nSo now to figure out if https://github.com/ReactiveX/RxJava/pull/1793 can be achieved in a different way, or if we need to solve the interruption issue.\n",
        "Here is a simpler test:\n\n``` java\n    @Test\n    public void testInterrupt() throws InterruptedException {\n        final AtomicReference<Object> exception = new AtomicReference<Object>();\n        final CountDownLatch latch = new CountDownLatch(1);\n        Observable.just(1).subscribeOn(Schedulers.computation()).take(1).subscribe(new Action1<Integer>() {\n\n            @Override\n            public void call(Integer t1) {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    exception.set(e);\n                    e.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }\n\n        });\n\n        latch.await();\n        assertNull(exception.get());\n    }\n```\n",
        "Ugh ... choosing whether to default to interrupting or not is a difficult one. It seems that perhaps we should not. Any insights on this?\n",
        "I have submitted a possible fix but want to think about this more.\n\nI can't find an authoritative answer on whether we should default to interrupting or not when the scheduled future is canceled. I think we should change to not interrupting but want to be sure that's correct as we've had it set to interrupt all along.\n",
        "@headinthebox A consideration here is that the place we are interrupting the threads is really just for unscheduling any scheduled actions from a Scheduler. I think we intend `subscription.isUnsubscribed()` to be the mechanism for something to gracefully stop. \n\nIt seems to me that we should not interrupt a thread automatically and that if a developer needs to do that their `Observable` should register a `Subscription` via `subscriber.add` that chooses to do so.\n\nWe can work around this particular `take` issue, but it makes me wonder if we would trigger this type of issue anywhere else. It seems that interrupting threads is a very nuanced thing that most code doesn't handle well and that we shouldn't be interrupting threads \"under the covers\".\n\nTherefore I suggest we change from `future.cancel(true)` to `future.cancel(false)` for the 2 places we capture a `Future` and cancel it when unsubscribing. \n",
        "@roman-mazur Thanks for that information, it is useful information. If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?\n\nAs far as RxJava is concerned, I'm suggesting we eliminate the two places where RxJava is the culprit for interrupting the thread (despite #1832 working around the particular issue of using `single` that triggers the issue).\n",
        "@roman-mazur \n\n> I wonder what happens when toBlocking().single() is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?\n\nIf it is interrupted while waiting on the single item we just fail right now. I suppose we could call `unsubscribe` upwards before throwing. \n\nThis is what currently happens:\n\n``` java\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted while waiting for subscription to complete.\", e);\n        }\n```\n",
        "@Alexander-- \n\n> Or is it some internal mechanic for disposing of Schedulers only?\n\nRxJava core libraries only interrupt when unsubscribing a scheduled action on a `Scheduler` that is still running. This is in turn just leveraging the `Future.cancel` semantics of Java. RxJava does not actually ever call `Thread.interrupt`.\n\nThe async-utils are just utility methods on top of Schedulers so unless there is some effort to specifically prevent interrupt (nothing I can see while browsing the code) they will also be interrupted if they are still executing when unsubscribe is invoked. \n\n> unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it?\n\nIf a Scheduler is not involved RxJava itself does nothing other than invoke `Subscription.unSubscribe` which flips a boolean and calls any registered callbacks. Thus, an `Observable` implementation can choose to register a `Subscription` that then interrupts and interruptible unit of work. \n\nI'm wondering if that is better for an Observable implementation (via `Observable.create`) to opt-in to interrupts rather than the current `Scheduler` interrupt mechanism which seems like it could be surprising. \n",
        "I'm gonna work on putting together a minimal test Android app to try and isolate the issue.\n",
        "https://dl.dropboxusercontent.com/u/7829307/RxJavaBlockingBug.zip\n\nI wasn't able to repro until I added the PublishSubject layer...maybe the issue is the nested toBlocking() calls?\n",
        "MainActivity all happens on the main thread, as does the onClickHandler.\n\nI've worked around the problem in our app by no longer using `toBlocking` in our subscribe method, but I still think there might be an Rx bug here.  Android shouldn't interrupt unless there's a deadlock of some sort, and I'm afraid the nested toBlocking calls (discouraged though they may be) are causing the thread to stall.  Regardless, the workaround is easy, so I don't think this should be a 1.0 blocker.  Thanks for looking into it!\n",
        "Deprecated seems wrong to me since it's never actually going to be removed.  I'm all in favor of updating the docs to reflect the recommended uses of toBlocking, though.  \n\nOr maybe deprecate `toBlocking()` and delegate to a new method called `areYouReallySureYouNeedToBlocking()` or something obnoxious like that?\n",
        "Can't find any Android docs that describe what we're seeing.  [Here](http://developer.android.com/training/articles/perf-anr.html)'s the docs on ANR (Application Not Responding) but we're seeing an actual crash.  \n\nMaybe worth seeing if it's rxjava itself that is interrupting the thread?\n",
        "You should really only ever call to blocking in command line test scripts but never in production code.\n\nIf you really need to end up blocking, you may as well push all the blocking backwardsvand write regular synchrounius code. \n",
        "Maybe we should mark toblocking as depricated (forever) such that you get a warning every time you use it. \n",
        "> but want to think about this more. \n\nsame here.\n",
        "Encountered this on Jellybean. Code in my Application subclass:\n\n``` java\nObservable<SomeSharedPreferencesWrapper> prefsPrefetch = Async.start(this::prefetchPrefs);\n```\n\nAnd later in same class:\n\n``` java\nreturn prefsPrefetch.toBlocking().single();\n```\n\nI can't grasp exact circumstances, when issue reproduces itself. At first glance they seem to be random, but happens often enough to make prefetching stuff with RxJava pretty much impossible.\n",
        "> You should really only ever call to blocking in command line test scripts but never in production code.\n\nNot everyone have their entire codebase under their control. Also in Android there are already plenty of ways to move tasks to background threads: all those legacy `Loader`s, `AsyncTask`s and `AbstractThreadedSyncAdapter`s requires certain data to be available directly without Observable shenanigans.\n\n> Does Android ever interrupt a thread based on user or system activity?\n\nI am not sure about this one, but FutureTask/ExecutorService combo was working just fine before migrating to RxJava (so was the previous version of RxJava, before updating to rc8).\n",
        "> It seems to me that we should not interrupt a thread automatically\n\nWait, so you DO interrupt threads right now, don't you? Does that mean, that unsubscribing from Observale (in currently released version), during interruptable operation will interrupt it? Will operations, created with `async-utils` (e.g. via `Async.fromCallable()`) be interrupted? Or is it some internal mechanic for disposing of Schedulers only?\n\nIf former, it would be really cool to leave it be.\n\n> If I understand correctly you are saying there are normal cases when Android can and will interrupt a thread and thus application code must account for this. Is this what you're saying?\n\nI wouldn't call `AbstractThreadedSyncAdpter` a normal case. Interrupting worker thread is just an implementation detail, which can be changed by overriding single method. Also Sync Framework in general is rather special and restrictive environment, and interrupting threads isn't worst thing awaiting developer there (for example, failure to intercept any exceptions may result in Sync Adapter being completely banned from execution by OS).\n",
        "A quick note about `Thread` interruptions on Android. AFAIK application process is killed in case of ANRs (either automatically or after a user confirmation). So ANRs do not lead to thread interruptions.\n\nHowever, there is a case when I use `toBlocking` and get an interruption: sync adapter thread. \n\nOn Android we can create a component that will be plugged to the sync part of the framework. Basically Android framework spawns a new thread for you and invokes your code in that thread. Application sync is supposed to be finished when this thread finishes. In our sync adapter code we build a chain of observables that can perform some operations concurrently using other threads. So the sync adapter code invoked in the sync thread looks like `buildChainOfObservables().toBlocking().single();`.\nSync can be canceled (e.g. by user request, unchecking a checkbox in system settings, or when it takes too long). And a default implementation of cancelation request is this sync thread interruption.\n",
        "@benjchristensen I would rather say that Android framework is unlikely to interrupt an application thread. The sync worker is the only known example. And interruption is a default behaviour that can be changed.\n\nBut note that I'm forced to use `toBlocking` within this thread because there is no other way to indicate that sync is finished.\nI wonder what happens when `toBlocking().single()` is interrupted. As far as I understand an error is propagated. Does it lead to un-subscriptions?\n"
    ],
    "2986": [],
    "3634": [],
    "1812": [
        "Thanks for reporting it.\n"
    ],
    "1816": [],
    "6344": [],
    "1135": [],
    "1818": [],
    "5494": [],
    "4828": [],
    "366": [],
    "1824": [
        "What would differentiate `@Beta` and `@Experimental`. Would `@Beta` be something we think is ready but just need time and testing whereas `@Experimental` is something to not be trusted at all?\n",
        "It seems that this Guava code is a good model to follow: https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/annotations/Beta.java\n\nWhat package should this live in, a new `rx.annotations` or somewhere else? It can't be inside `rx.internal` as this is supposed to be public. \n\n``` java\n/*\n * Copyright (C) 2010 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally from https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/annotations/Beta.java\n */\npackage rx.annotations;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Signifies that a public API (public class, method or field) is subject to\n * incompatible changes, or even removal, in a future release. An API bearing\n * this annotation is exempt from any compatibility guarantees made by its\n * containing library. Note that the presence of this annotation implies nothing\n * about the quality or performance of the API in question, only the fact that\n * it is not \"API-frozen.\"\n *\n * <p>It is generally safe for <i>applications</i> to depend on beta APIs, at\n * the cost of some extra work during upgrades. However it is generally\n * inadvisable for <i>libraries</i> (which get included on users' CLASSPATHs,\n * outside the library developers' control) to do so.\n *\n@Retention(RetentionPolicy.CLASS)\n@Target({\n    ElementType.ANNOTATION_TYPE,\n    ElementType.CONSTRUCTOR,\n    ElementType.FIELD,\n    ElementType.METHOD,\n    ElementType.TYPE})\n@Documented\n@GwtCompatible\n@Beta\npublic @interface Beta {}\n```\n",
        "I have updated the README to document the lifecycle and versioning policies. Are these acceptable?\n\nhttps://github.com/ReactiveX/RxJava/blob/1.x/README.md#versioning\n\n### Versioning\n\nVersion 1.x is now a stable API and will be supported for several years.\n\nMinor 1.x increments (such as 1.1, 1.2, etc) will occur when non-trivial new functionality is added or significant enhancements or bug fixes occur that may have behavioral changes that may affect some edge cases (such as dependence on behavior resulting from a bug). An example of an enhancement that would classify as this is adding reactive pull backpressure support to an operator that previously did not support it. This should be backwards compatible but does behave differently.\n\nPatch 1.x.y increments (such as 1.0.0 -> 1.0.1, 1.3.1 -> 1.3.2, etc) will occur for bug fixes and trivial functionality (like adding a method overload). New functionality marked with an `@Beta` or `@Experimental` annotation can also be added in patch releases to allow rapid exploration and iteration of unstable new functionality.\n\n#### `@Beta`\n\nAPIs marked with the `@Beta` annotation at the class or method level are subject to change. They can be modified in any way, or even removed, at any time. If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard, shading, etc).\n\n#### `@Experimental`\n\nAPIs marked with the `@Experimental` annotation at the class or method level will almost certainly change. They can be modified in any way, or even removed, at any time. You should not use or rely on them in any production code. They are purely to allow broad testing and feedback.\n\n#### `@Deprecated`\n\nAPIs marked with the `@Deprecated` annotation at the class or method level will remain supported until the next major release but it is recommended to stop using them.\n",
        "Does https://github.com/ReactiveX/RxJava/pull/1905 look good to you all?\n",
        "The audience annotation is interesting. We ended up using the `rx.internal.*` packaging and excluding those from the Javadocs. \n\nThanks for weighing in on this. And definitely consistent use is important. \n",
        "Merged based on confirmation from @daschl and @akarnokd \n",
        "+1. Both `@Beta` and `@Experimental` are good to me.\n",
        "In .NET we experimented with separate experimental and stable releases, but that was too confusing. The dual of `@depricated` makes a lot of sense.\n",
        "Interesting approach! We decided to split up audience and stability: https://github.com/couchbase/couchbase-jvm-core/tree/master/src/main/java/com/couchbase/client/core/annotations\n\nWhere the stabilites are experimental, uncomitted and comitted. I'm +1 on the proposed ones here too. I think it is more important that they are used consistently :)\n"
    ],
    "4783": [],
    "3887": [],
    "1936": [],
    "1831": [
        "That is an excellent question and a major oversight. Same issue with `scan`.\n",
        "Added overloads for `scan` and `reduce` that take a factory.\n",
        "We had to revert these changes due to issues shown in #1883. It was done in #1884.\n\nYou can instead use `collect` for the mutable reduce use case which now uses a factory for the initial value.\n\nWe'll have to evaluate whether `scan` needs a new signature to support this and if so add it later in 1.1 with a new name such as `scanTo` since we can't overload the method due to generics, type erasure and lambdas colliding.\n"
    ],
    "4531": [],
    "4391": [],
    "2553": [],
    "6075": [],
    "6565": [],
    "1472": [],
    "3323": [],
    "3086": [],
    "1144": [],
    "4798": [],
    "389": [],
    "3536": [],
    "1660": [],
    "2331": [],
    "496": [],
    "6529": [],
    "4236": [],
    "177": [],
    "1047": [],
    "4729": [],
    "1881": [
        "I have submitted #1883 to fix the ambiguity that happens with lambdas. \n\nI have changed `scan`, `reduce` and `collect`. I don't see anywhere else that needs to change.\n",
        "I'm going to pull the factory overload until 1.1 so we make sure we get this right. \n",
        "Fixed in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action.\n",
        "I'd be happy with `Func<0>` as the only way, but then we have to do the same for `reduce` and anything else that takes a seed.\n",
        "BTW, if we do this, then we should consider generalizing to returning `S` since we are side-effecting `R`, so it does not matter to return return the mutable state variable since that is passed in by the implementation.\n\n`scan(Func0<R>, Func2<R, ? super T, S>)`\n"
    ],
    "4826": [],
    "6090": [],
    "4488": [],
    "234": [],
    "4714": [],
    "6795": [],
    "2788": [],
    "1558": [],
    "3324": [],
    "6770": [],
    "1110": [],
    "1903": [],
    "409": [],
    "5836": [],
    "1908": [
        "What versions of Android are supported? `Deque`/`ArrayDeque` are usually preferred if you are API 9 and up (which is Java 6, 99.5% of active Android devices).\n",
        "On Android we generally prefer the up-front allocation over lazy allocation of somewhat disposable wrapper objects (such as that inside of a LinkedList). This is for the benefit of comparatively poor handling of short lived objects as well as avoiding the GC as much as possible in our 60fps world. We also definitely wouldn't want to pay the cost of having the array expand unless it exceeded the 16 value.\n",
        "Possible linked list implementations:\n- https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java\n- https://github.com/JCTools/JCTools/issues/39\n",
        "Here are some tests with `MpscLinkedQueue` and `SpscLinkedQueue` with `merge` and `observeOn`.\n\n```\nMerge\n\nBenchmark                                          (size)   Mode   Samples  SpmcArrayQueue  ||     Synchronized LinkedList    ||  MpscLinkedQueue7^\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5     5448592.507  ||  5332264.735    5358807.217    ||       5280793.113\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5       54425.611  ||    52385.763      52409.485    ||         51982.505\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5          52.477  ||       53.928         54.128    ||            59.971\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5       92792.488  ||   103554.112     104711.192    ||        104769.406\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5           4.957  ||        4.194          4.143    ||             4.750\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5     4608856.070  ||  4294087.613    4688656.691    ||       4274735.897\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5      431920.261  ||   451007.165     333391.274**  ||        440251.858\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5       52309.410  ||    49952.664      50057.346    ||         49188.282\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5     5815289.623  ||  5558593.305    5575812.189    ||       5576949.872\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5          52.525  ||       49.788         49.567    ||            51.102\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5       77640.706  ||    79530.128      79472.088    ||         75433.006\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5        3000.748  ||     2358.716**     2397.035**  ||          2881.911\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5     5397752.619  ||  5282943.171    5361848.221    ||       5445358.040\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5       29257.005  ||    34150.793      35196.066    ||         34305.563\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5          35.506  ||       25.827**       26.517**  ||            33.594\n\n^MpscLinkedQueue7 => This can be used by merge and observeOn.  Currently unbounded and needs to be bounded.\n\n\n\nObserveOn\n\n\nBenchmark                                         (size)   Mode   Samples SpmcArrayQueue  ||        Synchronized LinkedList    || MpscLinkedQueue7^ || SpscLinkedQueue^\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5     109192.288  ||    111037.202       110112.152    ||       106683.693  ||      109647.796\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5       6952.955  ||      2846.331**       2821.400**  ||         6280.963  ||        7117.558\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5         12.267  ||         9.988**         10.063**  ||           12.667  ||          13.786\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5   16430666.170  ||  16284869.881     16504292.796    ||     15826734.130  ||    16052912.021\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5     153431.778  ||    158892.599       157288.399    ||       153065.062  ||      155336.587\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5        150.061  ||       159.481          149.546    ||          153.177  ||         152.810\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5      16899.056  ||     16111.396        16532.411    ||        14405.399  ||       15836.574\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5       7262.566  ||      5742.547**       5504.293**  ||         7081.180  ||        8112.809\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5         13.520  ||        10.364**          9.954**  ||           12.881  ||          14.937\n\n\n^MpscLinkedQueue7 => This could be used since observeOn supports single-consumer. Currently unbounded and needs to be bounded.\n^SpscLinkedQueue7 => This could be used since observeOn supports single-producer, single-consumer. Currently unbounded and needs to be bounded.\n```\n\nJMC while running `merge` tests for 60 seconds:\n\n![screen shot 2014-11-29 at 8 47 43 pm](https://cloud.githubusercontent.com/assets/813492/5236831/3006bb10-7809-11e4-98dc-0c2c78749187.png)\n\nWe can't use these queues as-is since they are single-consumer and we need multi-consumer for `merge`. Also, `observeOn` is showing some test failures. \n\nHowever, the results do suggest that we can get a data structure to achieve performance without object pooling. \n",
        "Here is an example of what we don't want as far as object-allocation.\n\n`observeOn` using JCTools linked list (good):\n\n![observeon-jctools-linkedlist](https://cloud.githubusercontent.com/assets/813492/5236838/e082ccea-7809-11e4-88eb-d0b439df8d27.png)\n\n`observeOn` using JCTools array queue without pooling (bad):\n\n![observeon-jctools-arrayqueue](https://cloud.githubusercontent.com/assets/813492/5236839/ece56a10-7809-11e4-964c-6372a3e0eb97.png)\n\nNote the massive object allocation.\n",
        "Yes it should work and the other spsc/mpsc queue impls work so it suggests an issue with those impls (they aren't yet officially released). \n",
        "I manually attach JFR after the test passes the warmup and hits the first iteration. I increase the integration time to some longer number (been doing 25 seconds) so it runs far longer than the 60 seconds I capture via JFR.\n\n```\n./gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 25 .*OperatorObserveOnPerf.*'\n```\n\nI start flight recording when the first iteration starts:\n\n```\n# Run progress: 0.00% complete, ETA 00:19:30\n# Warmup: 5 iterations, 1 s each\n# Measurement: 5 iterations, 25 s each\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: rx.operators.OperatorObserveOnPerf.observeOnComputation\n# Parameters: (size = 1)\n# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/bin/java\n# VM options: -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -Xmx512m -Dfile.encoding=UTF-8\n# Fork: 1 of 1\n# Warmup Iteration   1: 76564.389 ops/s\n# Warmup Iteration   2: 105044.060 ops/s\n# Warmup Iteration   3: 108520.068 ops/s\n# Warmup Iteration   4: 108104.151 ops/s\n# Warmup Iteration   5: 109615.544 ops/s\nIteration   1:\n```\n\n![screen shot 2014-11-30 at 11 03 48 am](https://cloud.githubusercontent.com/assets/813492/5238883/b02797e8-7880-11e4-94df-f71ec1ae27aa.png)\n\n![screen shot 2014-11-30 at 11 03 56 am](https://cloud.githubusercontent.com/assets/813492/5238885/bdca1efc-7880-11e4-8c9e-5b5bd32e9213.png)\n",
        "> some unit tests failing with this that need to be debugged\n\nJust a silly oversight on my part. These are unbounded queues and our use cases requires them to be bounded. Thus, the `offer` never returns false so we never hit the backpressure exception:\n\n``` java\n        if (!queue.offer(on.next(o))) {\n            throw new MissingBackpressureException();\n        }\n```\n\nIf we use one of these unbounded queues we'll need to add the overhead of tracking the size, or modify the queue implementation to correctly do that for us. \n",
        "ConcurrentLinkedQueue takes a performance hit compared with the JCTools implementations for `observeOn`:\n\n```\nObserveOn\n\nBenchmark                                         (size)  SpmcArrayQueue  ||   ConcurrentLinkedQueue\nr.o.OperatorObserveOnPerf.observeOnComputation         1      109192.288  ||              110221.988\nr.o.OperatorObserveOnPerf.observeOnComputation      1000        6952.955  ||                6016.298**\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000          12.267  ||                  10.748**\nr.o.OperatorObserveOnPerf.observeOnImmediate           1    16430666.170  ||            16245304.118\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000      153431.778  ||              156059.398\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000         150.061  ||                 155.667\nr.o.OperatorObserveOnPerf.observeOnNewThread           1       16899.056  ||               16700.144\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000        7262.566  ||                6813.449**\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000          13.520  ||                  10.655**\n```\n\nIt's okay for `merge`:\n\n```\nBenchmark                                          (size)  SpmcArrayQueue  ||  MpscLinkedQueue7^  ||  ConcurrentLinkedQueue\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1     5448592.507  ||       5280793.113   ||            5292601.594\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000       54425.611  ||         51982.505   ||              51990.637\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000          52.477  ||            59.971   ||                 59.967\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1       92792.488  ||        104769.406   ||             103669.636\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000           4.957  ||             4.750   ||                  4.074\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1     4608856.070  ||       4274735.897   ||            4360997.158\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100      431920.261  ||        440251.858   ||             438544.154\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000       52309.410  ||         49188.282   ||              49382.440\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1     5815289.623  ||       5576949.872   ||            5577426.641\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000          52.525  ||            51.102   ||                 49.899\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1       77640.706  ||         75433.006   ||              78623.524\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000        3000.748  ||          2881.911   ||               2696.428\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1     5397752.619  ||       5445358.040   ||            5346115.873\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000       29257.005  ||         34305.563   ||              34051.746\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000          35.506  ||            33.594   ||                 35.157\n```\n",
        "I modified `RxRingBuffer` to use its own counter for bounding the links lists and am now using `SpscLinkedQueue`\n\nThe only unit test failing is `RxRingBufferSpmcTest.testConcurrency` which is a valid failure since I am only using an spsc queue.\n\nScroll to the right to see the `SpscLinkedQueue+Size` values:\n\n```\nMerge\n\nBenchmark                                          (size)  SpmcArrayQueue  ||     Synchronized LinkedList    ||  MpscLinkedQueue7^  ||  ConcurrentLinkedQueue  || SpscLinkedQueue+Size\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1     5448592.507  ||  5332264.735    5358807.217    ||       5280793.113   ||            5292601.594  ||          5332726.909\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000       54425.611  ||    52385.763      52409.485    ||         51982.505   ||              51990.637  ||            49268.224\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000          52.477  ||       53.928         54.128    ||            59.971   ||                 59.967  ||               50.742\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1       92792.488  ||   103554.112     104711.192    ||        104769.406   ||             103669.636  ||           104210.342\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000           4.957  ||        4.194          4.143    ||             4.750   ||                  4.074  ||                4.688\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1     4608856.070  ||  4294087.613    4688656.691    ||       4274735.897   ||            4360997.158  ||          4888816.598\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100      431920.261  ||   451007.165     333391.274**  ||        440251.858   ||             438544.154  ||           445969.294\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000       52309.410  ||    49952.664      50057.346    ||         49188.282   ||              49382.440  ||            49817.351\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1     5815289.623  ||  5558593.305    5575812.189    ||       5576949.872   ||            5577426.641  ||          5707051.084\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000          52.525  ||       49.788         49.567    ||            51.102   ||                 49.899  ||               43.819**\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1       77640.706  ||    79530.128      79472.088    ||         75433.006   ||              78623.524  ||            78480.286\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000        3000.748  ||     2358.716**     2397.035**  ||          2881.911   ||               2696.428  ||             2627.181*\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1     5397752.619  ||  5282943.171    5361848.221    ||       5445358.040   ||            5346115.873  ||          5352179.516\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000       29257.005  ||    34150.793      35196.066    ||         34305.563   ||              34051.746  ||            35081.657\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000          35.506  ||       25.827**       26.517**  ||            33.594   ||                 35.157  ||               35.378\n\n\n^MpscLinkedQueue7 => This can be used by merge and observeOn.  Currently unbounded and needs to be bounded.\n\n\n\nObserveOn\n\n\nBenchmark                                         (size)  SpmcArrayQueue  ||        Synchronized LinkedList    || MpscLinkedQueue7^ || SpscLinkedQueue^  || ConcurrentLinkedQueue   || SpscLinkedQueue+Size\nr.o.OperatorObserveOnPerf.observeOnComputation         1      109192.288  ||    111037.202       110112.152    ||       106683.693  ||      109647.796   ||            110221.988   ||           105952.032\nr.o.OperatorObserveOnPerf.observeOnComputation      1000        6952.955  ||      2846.331**       2821.400**  ||         6280.963  ||        7117.558   ||              6016.298** ||             6615.249\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000          12.267  ||         9.988**         10.063**  ||           12.667  ||          13.786   ||                10.748** ||               11.381\nr.o.OperatorObserveOnPerf.observeOnImmediate           1    16430666.170  ||  16284869.881     16504292.796    ||     15826734.130  ||    16052912.021   ||          16245304.118   ||         16294413.530\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000      153431.778  ||    158892.599       157288.399    ||       153065.062  ||      155336.587   ||            156059.398   ||           157113.031\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000         150.061  ||       159.481          149.546    ||          153.177  ||         152.810   ||               155.667   ||              157.675\nr.o.OperatorObserveOnPerf.observeOnNewThread           1       16899.056  ||     16111.396        16532.411    ||        14405.399  ||       15836.574   ||             16700.144   ||            15718.673\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000        7262.566  ||      5742.547**       5504.293**  ||         7081.180  ||        8112.809   ||              6813.449** ||             7248.917\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000          13.520  ||        10.364**          9.954**  ||           12.881  ||          14.937   ||                10.655** ||               12.344\n\n\n^MpscLinkedQueue7 => This could be used since observeOn supports single-consumer. Currently unbounded and needs to be bounded.\n^SpscLinkedQueue7 => This could be used since observeOn supports single-producer, single-consumer. Currently unbounded and needs to be bounded.\n```\n\nobserveOn Flight Recorder\n\n1.0.1\n\n![observeon-1 0 1](https://cloud.githubusercontent.com/assets/813492/5239162/be5d01a8-788b-11e4-9fbf-93324edb3691.png)\n\nModified to use SPSC Linked List\n\n![observeon-spsc](https://cloud.githubusercontent.com/assets/813492/5239164/c7513a7c-788b-11e4-8840-0e169da74f62.png)\n\nmerge Flight Recorder\n\n1.0.1\n\n![merge-1 0 1](https://cloud.githubusercontent.com/assets/813492/5239166/d8dd8944-788b-11e4-96d4-85c39259a418.png)\n\nModified to use SPSC Linked List\n\n![merge-spsc](https://cloud.githubusercontent.com/assets/813492/5239165/d716f726-788b-11e4-8953-440768dfa2a9.png)\n\nThe flight recorder stuff, particularly for `merge` needs more evaluation. \n\nIt does seem though that the trade-offs in performance and object allocation are not severe and thus probably warrants the change to allow avoiding object pooling. \n\nI'll submit a PR with the changes for evaluation and further experimentation. \n",
        "PR https://github.com/ReactiveX/RxJava/pull/1909 contains the code for the previous perf tests. \n",
        "A note while we're working on this ... whatever decision we make here I think should target 1.1 since it will affect memory and GC behavior so is larger than a patch. \n\nI also want to give enough time to really think through this ... sleeping on whatever solutions we work on since this is very nuanced and the tradeoffs need to be thought through. \n",
        "I've been exploring weak and phantom references tonight while exploring whether it's possible to continue using object pooling but without manual release. I have it working, and performance is good, but at high velocity on JMH tests the ReferenceQueue is filling up in an unbounded manner. \n\nAnyone have good experience using WeakReferences for an object pool with high throughput? \n\nI wish there was a better way to get a callback from the WeakReference than it being put into a ReferenceQueue.\n",
        "> The problem with pooling is that it can now become the congestion point: multiple threads might want to grab an element from the pool at the same time.\n\nSure, but if it's a concurrent queue, which it is, then that contention should not be severe. It's using an `MpmcArrayQueue` optimized for performance. \n\nI agree it is a point of contention, but if that contention is cheaper than the object allocation/collection then it's a net win. \n\n> reference counting\n\nThis could work but is effectively synchronizing unsubscribe and queue usage (cheaper than mutex, but still a form of synchronizing) which definitely has a cost, both performance and cognitive every time this queue is used. Hence us pursuing either a solution that doesn't need to be pooled, or my pursuit of weak references so the release to the pool is automated. \n",
        "I have some some benchmarking on different solutions that have been posted, including removing the pooling altogether and here are the numbers. Note that we now have a queue size of 128, not 1024 like we used to.\n\n```\nBenchmark                                                                 (nextRuns)  (size)            1.x                   No Pool          2PhaseArrayQueue    branch rxqueue-spsc \nr.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A     100     288851.474  |    464395.527  161% ++  |    288585.686  100%    |    128859.372 45% --\nr.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A   10000       1053.102  |      1122.418  107%     |       988.942  94%     |      1033.768 98%\nr.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A     100     130035.705  |    219530.470  169% ++  |    129688.488  100%    |    122350.438 94%\nr.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A   10000        394.109  |       408.761  104%     |       372.060  94%     |       382.935 97%\nr.internal.RxRingBufferPerf.spmcCreateUseAndDestroy1                             N/A     N/A   26400373.503  |   4011739.109  15% --   |   3904652.414  15% --  |  10354119.555 39% --\nr.internal.RxRingBufferPerf.spmcRingBufferAddRemove1                             N/A     N/A   41947289.772  |  40889056.084  97%      | 167128945.622  398% ++ |  39302492.472 94%\nr.internal.RxRingBufferPerf.spscCreateUseAndDestroy1                             N/A     N/A   26625817.275  |   4041119.853  15% --   |  10543005.986  40% --  |   9844380.252 37% --\nr.internal.RxRingBufferPerf.spscRingBufferAddRemove1                             N/A     N/A   42376557.425  |  39384117.892  93%      |  50678693.611  120% ++ |  40440515.140 95%\nr.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A       1     323419.496  |    314150.913  97%      |    306704.864  95%     |     56413.217 17% --\nr.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A    1000        325.685  |       320.644  98%      |       312.976  96%     |        75.440 23% --\nr.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A 1000000          0.318  |         0.318  100%     |         0.311  98%     |         0.066 21% --\nr.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A       1    5544570.553  |   5634853.059  102%     |   5355739.382  97%     |   1276719.950 23% --\nr.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A    1000      37510.701  |     37428.777  100%     |     37971.972  101%    |      8511.690 23% --\nr.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A 1000000         32.831  |        33.133  101%     |        33.224  101%    |         7.466 23% --\nr.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A       1    4081082.521  |   3988577.555  98%      |   3855453.808  94%     |    892951.263 22% --\nr.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A    1000      26194.758  |     26060.788  99%      |     24783.878  95%     |      5014.843 19% -- \nr.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A 1000000         24.255  |        24.638  102%     |        22.923  95%     |         5.212 21% --\nr.operators.OperatorMapPerf.mapPassThru                                          N/A       1   24413615.697  |  24572501.107  101%     |  24135623.277  99%     |   5882139.319 24% --\nr.operators.OperatorMapPerf.mapPassThru                                          N/A    1000     126022.367  |    126928.122  101%     |    121905.819  97%     |     31068.374 25% --\nr.operators.OperatorMapPerf.mapPassThru                                          N/A 1000000        125.726  |       133.165  106%     |       125.238  100%    |        32.079 26% --\nr.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A       1   26830181.693  |  26855829.721  100%     |  26402665.260  98%     |   6974887.323 26% --\nr.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A    1000     126998.154  |    127883.467  101%     |    124275.543  98%     |     29430.411 23% --\nr.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A 1000000        132.249  |       132.858  100%     |       130.028  98%     |       105.182 80% --\nr.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A       1    5004527.084  |   5096505.217  102%     |   4913306.706  98%     |   4565544.618 91%\nr.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A    1000      52723.842  |     51944.534  99%      |     44783.449  85% --  |     38827.856 74% --\nr.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A 1000000         49.928  |        49.643  99%      |        47.285  95%     |        42.332 85% --\nr.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A       1      99724.243  |     96046.578  96%      |     97233.505  98%     |     98970.453 99%\nr.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A    1000          4.661  |         5.085  109%     |         4.688  101%    |         4.727 101%\nr.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A       1    4543776.401  |   4562256.139  100%     |   4626141.577  102%    |   4550596.577 100%\nr.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A     100     482015.536  |    481347.669  100%     |    477687.006  99%     |    474884.635 99%\nr.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A    1000      52102.762  |     52212.844  100%     |     50536.678  97%     |     55255.898 106%\nr.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A       1    5182887.347  |   4926496.569  95%      |   5160628.853  100%    |   5043255.904 97%\nr.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A    1000         52.055  |        51.914  100%     |        48.084  92%     |        46.567 89% --\nr.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A       1      76604.876  |     74224.276  97%      |     71937.709  94%     |     77366.844 101%\nr.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A    1000       3166.341  |      3130.021  99%      |      3295.517  104%    |      2541.420 80% --\nr.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A       1    5276030.387  |   5048453.291  96%      |   4806177.849  91%     |   4935148.406 94%\nr.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A    1000      37197.231  |     37647.410  101%     |     38406.161  103%    |     36161.836 97%\nr.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A 1000000         34.649  |        34.124  98%      |        34.025  98%     |        32.754 95%\nr.operators.OperatorObserveOnPerf.observeOnComputation                           N/A       1     107207.970  |    100380.298  94%      |    108474.884  101%    |    105535.982 98%\nr.operators.OperatorObserveOnPerf.observeOnComputation                           N/A    1000       6517.902  |      6869.709  105%     |      6371.416  98%     |      6301.948 97%\nr.operators.OperatorObserveOnPerf.observeOnComputation                           N/A 1000000         13.670  |        13.580  99%      |        11.346  83% --  |        11.305 83% --\nr.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A       1   15245087.895  |  14962479.384  98%      |  14997783.368  98%     |  14673057.780 96%\nr.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A    1000     178513.653  |    173023.234  97%      |    170021.413  95%     |    164929.922 92%\nr.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A 1000000        157.016  |       152.469  97%      |       154.095  98%     |       144.408 92%\nr.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A       1      16879.424  |     15716.151  93%      |     15426.649  91%     |     14689.995 87% --\nr.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A    1000       7783.654  |      7765.427  100%     |      6734.649  87%     |      7173.622 92%\nr.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A 1000000         13.153  |        14.191  108%     |        11.650  89%     |        11.275 86% --\nr.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A       1   25332343.625  |  25065988.234  99%      |  24342054.885  96%     |  25262395.598 100%\nr.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A    1000     116819.629  |    116739.463  100%     |    113936.110  98%     |    115857.556 99%\nr.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A 1000000        135.843  |       134.416  99%      |       130.710  96%     |       134.943 99%\nr.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A       1  121325903.567  | 118002649.957  97%      | 112020450.304  92%     | 104636361.664 86% --\nr.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A    1000     186533.260  |    187334.419  100%     |    185695.013  100%    |    179519.340 96%\nr.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A 1000000        166.914  |       169.448  102%     |       160.806  96%     |       158.203 95%\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A       1   18921314.555  |  18257594.271  96%      |  18853324.397  100%    |  18123044.637 96%\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A    1000     269546.032  |    228423.425  85% --   |    266431.946  99%     |    248808.733 92%\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A 1000000        260.990  |       254.223  97%      |       253.943  97%     |       235.045 90% --\nr.operators.OperatorSerializePerf.serializedSingleStream                         N/A       1   10736813.240  |  10037561.783  93%      |   9935098.948  93%     |   9663588.470 90% --\nr.operators.OperatorSerializePerf.serializedSingleStream                         N/A    1000      79767.255  |     67068.394  84% --   |     66532.316  83% --  |     64151.866 80% --\nr.operators.OperatorSerializePerf.serializedSingleStream                         N/A 1000000         70.840  |        75.120  106%     |        73.776  104%    |        72.247 102%\nr.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A       1     111389.498  |    110210.985  99%      |    110774.637  99%     |    106648.746 96%\nr.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A    1000       7575.618  |      7207.681  95%      |      7189.025  95%     |      7175.698 95%\nr.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A 1000000          9.196  |         9.864  107%     |         8.714  95%     |         9.383 102%\nr.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A       1      83396.077  |     78874.484  95%      |     81866.626  98%     |     78901.924 95%\nr.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A    1000      36273.839  |     34303.562  95%      |     35859.978  99%     |     34513.093 95%\nr.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A       1      55607.010  |     53946.317  97%      |     55332.808  100%    |     51419.088 92%\nr.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A    1000      53468.342  |     53613.934  100%     |     53089.878  99%     |     52291.141 98%\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A       1     107083.283  |    106172.060  99%      |    109756.005  102%    |    108969.564 102%\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A      10     103095.692  |    102757.452  100%     |    102707.186  100%    |     99579.238 97%\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A     100      37921.038  |     39183.046  103%     |     34085.675  90%     |     32331.879 85% --\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    1000       6776.178  |      7015.656  104%     |      6289.376  93%     |      6384.900 94%\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    2000       4851.628  |      4828.700  100%     |      4212.292  87%     |      4354.948 90% --\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    3000       3754.394  |      3778.104  101%     |      2961.396  79%     |      3207.050 85% --\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    4000       2994.907  |      2949.000  98%      |      2489.455  83% --  |      2562.348 86% --\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A   10000       1314.721  |      1275.489  97%      |      1113.610  85% --  |      1102.961 84% --\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A  100000        136.838  |       132.305  97%      |       115.854  85% --  |       117.097 86% --\nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A 1000000         13.837  |        12.820  93%      |        11.543  83% --  |        10.903 79% --\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A       1     113032.129  |    112135.558  99%      |    111731.222  99%     |    111749.315 99%\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A      10     109884.718  |    109449.819  100%     |    102844.370  94%     |    109021.256 99%\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A     100      89945.753  |     88015.871  98%      |     85771.952  95%     |     88074.845 98%\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    1000      31680.733  |     31522.878  100%     |     31045.429  98%     |     31413.322 99%\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    2000      18490.513  |     18352.634  99%      |     15774.641  85% --  |     16059.751 87% --\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    3000      11490.479  |     11446.241  100%     |     11197.939  97%     |     12871.202 112% ++\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    4000       8833.117  |     10230.066  116% ++  |      9788.883  111%    |      9889.138 112% ++\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A   10000       3888.874  |      3885.651  100%     |      3919.543  101%    |      3903.835 100%\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A  100000        446.789  |       438.143  98%      |       434.775  97%     |       432.321 97%\nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A 1000000         43.228  |        42.516  98%      |        42.588  99%     |        41.833 97%\nr.schedulers.IOSchedulerPerf.observeOn                                           N/A       1     107443.954  |    103885.976  97%      |    106696.574  99%     |    105420.129 98%\nr.schedulers.IOSchedulerPerf.observeOn                                           N/A    1000       6835.942  |      6934.710  101%     |      6175.613  90%     |      6257.461 92%\nr.schedulers.IOSchedulerPerf.observeOn                                           N/A 1000000         13.804  |        13.076  95%      |        11.489  83% --  |        11.646 84% --\nr.schedulers.IOSchedulerPerf.subscribeOn                                         N/A       1     113589.713  |    112548.761  99%      |    113767.664  100%    |    112749.541 99%\nr.schedulers.IOSchedulerPerf.subscribeOn                                         N/A    1000      31572.535  |     31359.484  99%      |     31566.874  100%    |     28903.326 92%\nr.schedulers.IOSchedulerPerf.subscribeOn                                         N/A 1000000         43.469  |        43.259  100%     |        43.075  99%     |        42.883 99%\nr.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                            1     N/A    4885450.713  |   4663855.111  95%      |   4760593.357  97%     |   4814097.168 99%\nr.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                         1000     N/A      36567.449  |     34794.653  95%      |     30965.582  85% --  |     35307.030 97%\nr.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                      1000000     N/A         46.758  |        44.710  96%      |        45.807  98%     |        45.132 97%\nr.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                         1     N/A    5166859.073  |   4928418.828  95%      |   4975843.203  96%     |   4971964.310 96%\nr.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                      1000     N/A      36677.914  |     35071.647  96%      |     34172.806  93%     |     36402.484 99%\nr.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                   1000000     N/A         45.299  |        43.800  97%      |        44.580  98%     |        44.281 98%\nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                           1     N/A    3602234.043  |   3467543.784  96%      |   3555240.202  99%     |   3590503.433 100%\nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                        1000     N/A      47750.855  |     46718.061  98%      |     46229.640  97%     |     47580.266 100%\nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                     1000000     N/A         42.764  |        47.144  110% ++  |        45.690  107%    |        42.126 99%\nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                        1     N/A    3787851.518  |   3637162.254  96%      |   3527627.269  93%     |   3761304.213 99%\nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                     1000     N/A      43472.144  |     46173.174  106%     |     41008.079  94%     |     46078.493 106%\nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                  1000000     N/A         42.057  |        41.150  98%      |        40.454  96%     |        40.994 97%\n\n```\n",
        "Here is a comparison of no pooling with size at 128 vs 1024:\n\n```\nBenchmark                                                                 (nextRuns)  (size)            1.x              No Pool (128)    No Pool (1024)     \nr.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A     100     288851.474  |    464395.527  161% ++  |    491662.797  170% ++ \nr.internal.IndexedRingBufferPerf.indexedRingBufferAdd                            N/A   10000       1053.102  |      1122.418  107%     |      1201.884  114% ++ \nr.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A     100     130035.705  |    219530.470  169% ++  |    230427.274  177% ++ \nr.internal.IndexedRingBufferPerf.indexedRingBufferAddRemove                      N/A   10000        394.109  |       408.761  104%     |       430.168  109%    \nr.internal.RxRingBufferPerf.spmcCreateUseAndDestroy1                             N/A     N/A   26400373.503  |   4011739.109  15% --   |   2066095.594  8%   -- \nr.internal.RxRingBufferPerf.spmcRingBufferAddRemove1                             N/A     N/A   41947289.772  |  40889056.084  97%      |  42517680.638  101%    \nr.internal.RxRingBufferPerf.spscCreateUseAndDestroy1                             N/A     N/A   26625817.275  |   4041119.853  15% --   |   2065904.299  8%   -- \nr.internal.RxRingBufferPerf.spscRingBufferAddRemove1                             N/A     N/A   42376557.425  |  39384117.892  93%      |  42717826.799  101%    \nr.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A       1     323419.496  |    314150.913  97%      |    286454.266  89%  -- \nr.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A    1000        325.685  |       320.644  98%      |       304.203  93%     \nr.operators.OperatorFlatMapPerf.flatMapIntPassthruAsync                          N/A 1000000          0.318  |         0.318  100%     |         0.305  96%     \nr.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A       1    5544570.553  |   5634853.059  102%     |   5703716.144  103%    \nr.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A    1000      37510.701  |     37428.777  100%     |     37643.924  100%    \nr.operators.OperatorFlatMapPerf.flatMapIntPassthruSync                           N/A 1000000         32.831  |        33.133  101%     |        33.955  103%    \nr.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A       1    4081082.521  |   3988577.555  98%      |   4148571.600  102%    \nr.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A    1000      26194.758  |     26060.788  99%      |     27231.215  104%    \nr.operators.OperatorFlatMapPerf.flatMapTwoNestedSync                             N/A 1000000         24.255  |        24.638  102%     |        26.108  108%    \nr.operators.OperatorMapPerf.mapPassThru                                          N/A       1   24413615.697  |  24572501.107  101%     |  25033228.781  103%    \nr.operators.OperatorMapPerf.mapPassThru                                          N/A    1000     126022.367  |    126928.122  101%     |    131846.869  105%    \nr.operators.OperatorMapPerf.mapPassThru                                          N/A 1000000        125.726  |       133.165  106%     |       129.763  103%    \nr.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A       1   26830181.693  |  26855829.721  100%     |  27593572.229  103%    \nr.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A    1000     126998.154  |    127883.467  101%     |    128981.592  102%    \nr.operators.OperatorMapPerf.mapPassThruViaLift                                   N/A 1000000        132.249  |       132.858  100%     |       130.398  99%     \nr.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A       1    5004527.084  |   5096505.217  102%     |   5198752.240  104%    \nr.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A    1000      52723.842  |     51944.534  99%      |     54578.616  104%    \nr.operators.OperatorMergePerf.merge1SyncStreamOfN                                N/A 1000000         49.928  |        49.643  99%      |        46.496  93%     \nr.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A       1      99724.243  |     96046.578  96%      |     92329.887  93%     \nr.operators.OperatorMergePerf.mergeNAsyncStreamsOfN                              N/A    1000          4.661  |         5.085  109%     |         4.858  104%    \nr.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A       1    4543776.401  |   4562256.139  100%     |   4868734.621  107%    \nr.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A     100     482015.536  |    481347.669  100%     |    474865.976  99%     \nr.operators.OperatorMergePerf.mergeNSyncStreamsOf1                               N/A    1000      52102.762  |     52212.844  100%     |     41445.112  80%  -- \nr.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A       1    5182887.347  |   4926496.569  95%      |   5233708.963  101%    \nr.operators.OperatorMergePerf.mergeNSyncStreamsOfN                               N/A    1000         52.055  |        51.914  100%     |        52.875  102%    \nr.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A       1      76604.876  |     74224.276  97%      |     70830.676  92%     \nr.operators.OperatorMergePerf.mergeTwoAsyncStreamsOfN                            N/A    1000       3166.341  |      3130.021  99%      |      3684.324  116% ++ \nr.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A       1    5276030.387  |   5048453.291  96%      |   4977866.142  94%     \nr.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A    1000      37197.231  |     37647.410  101%     |     39342.369  106%    \nr.operators.OperatorMergePerf.oneStreamOfNthatMergesIn1                          N/A 1000000         34.649  |        34.124  98%      |        34.793  100%    \nr.operators.OperatorObserveOnPerf.observeOnComputation                           N/A       1     107207.970  |    100380.298  94%      |    103951.076  97%     \nr.operators.OperatorObserveOnPerf.observeOnComputation                           N/A    1000       6517.902  |      6869.709  105%     |      4597.071  71%  -- \nr.operators.OperatorObserveOnPerf.observeOnComputation                           N/A 1000000         13.670  |        13.580  99%      |         8.769  64%  -- \nr.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A       1   15245087.895  |  14962479.384  98%      |  15246618.567  100%    \nr.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A    1000     178513.653  |    173023.234  97%      |    175349.312  98%     \nr.operators.OperatorObserveOnPerf.observeOnImmediate                             N/A 1000000        157.016  |       152.469  97%      |       158.773  101%    \nr.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A       1      16879.424  |     15716.151  93%      |     15436.938  91%     \nr.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A    1000       7783.654  |      7765.427  100%     |      4088.303  53%  -- \nr.operators.OperatorObserveOnPerf.observeOnNewThread                             N/A 1000000         13.153  |        14.191  108%     |        14.327  109%    \nr.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A       1   25332343.625  |  25065988.234  99%      |  25389267.172  100%    \nr.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A    1000     116819.629  |    116739.463  100%     |    115639.590  99%     \nr.operators.OperatorRangePerf.rangeWithBackpressureRequest                       N/A 1000000        135.843  |       134.416  99%      |       135.049  99%     \nr.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A       1  121325903.567  | 118002649.957  97%      | 117809961.937  97%     \nr.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A    1000     186533.260  |    187334.419  100%     |    189459.713  102%    \nr.operators.OperatorRangePerf.rangeWithoutBackpressure                           N/A 1000000        166.914  |       169.448  102%     |       167.025  100%    \nr.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A       1   18921314.555  |  18257594.271  96%      |  19336558.885  102%    \nr.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A    1000     269546.032  |    228423.425  85% --   |    272078.328  101%    \nr.operators.OperatorSerializePerf.noSerializationSingleThreaded                  N/A 1000000        260.990  |       254.223  97%      |       263.143  101%    \nr.operators.OperatorSerializePerf.serializedSingleStream                         N/A       1   10736813.240  |  10037561.783  93%      |  10329940.205  96%     \nr.operators.OperatorSerializePerf.serializedSingleStream                         N/A    1000      79767.255  |     67068.394  84% --   |     82774.032  104%    \nr.operators.OperatorSerializePerf.serializedSingleStream                         N/A 1000000         70.840  |        75.120  106%     |        73.439  104%    \nr.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A       1     111389.498  |    110210.985  99%      |    114315.595  103%    \nr.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A    1000       7575.618  |      7207.681  95%      |      6969.878  92%     \nr.operators.OperatorSerializePerf.serializedTwoStreamsHighlyContended            N/A 1000000          9.196  |         9.864  107%     |        10.363  113% ++ \nr.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A       1      83396.077  |     78874.484  95%      |     83311.153  100%    \nr.operators.OperatorSerializePerf.serializedTwoStreamsOneFastOneSlow             N/A    1000      36273.839  |     34303.562  95%      |     35931.364  99%     \nr.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A       1      55607.010  |     53946.317  97%      |     53502.884  96%     \nr.operators.OperatorSerializePerf.serializedTwoStreamsSlightlyContended          N/A    1000      53468.342  |     53613.934  100%     |     52365.494  98%     \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A       1     107083.283  |    106172.060  99%      |    103457.291  97%     \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A      10     103095.692  |    102757.452  100%     |     98744.249  96%     \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A     100      37921.038  |     39183.046  103%     |     38418.723  101%    \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    1000       6776.178  |      7015.656  104%     |      4530.745  67%  -- \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    2000       4851.628  |      4828.700  100%     |      2085.208  43%  -- \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    3000       3754.394  |      3778.104  101%     |      1310.303  35%  -- \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A    4000       2994.907  |      2949.000  98%      |      1008.669  34%  -- \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A   10000       1314.721  |      1275.489  97%      |       399.229  30%  -- \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A  100000        136.838  |       132.305  97%      |        50.999  37%  -- \nr.schedulers.ComputationSchedulerPerf.observeOn                                  N/A 1000000         13.837  |        12.820  93%      |         9.045  65%  -- \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A       1     113032.129  |    112135.558  99%      |    113835.591  101%    \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A      10     109884.718  |    109449.819  100%     |    109171.798  99%     \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A     100      89945.753  |     88015.871  98%      |     89399.541  99%     \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    1000      31680.733  |     31522.878  100%     |     31588.465  100%    \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    2000      18490.513  |     18352.634  99%      |     18429.705  100%    \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    3000      11490.479  |     11446.241  100%     |     11472.235  100%    \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A    4000       8833.117  |     10230.066  116% ++  |      9979.643  113% ++ \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A   10000       3888.874  |      3885.651  100%     |      3517.361  90%     \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A  100000        446.789  |       438.143  98%      |       456.528  102%    \nr.schedulers.ComputationSchedulerPerf.subscribeOn                                N/A 1000000         43.228  |        42.516  98%      |        44.854  104%    \nr.schedulers.IOSchedulerPerf.observeOn                                           N/A       1     107443.954  |    103885.976  97%      |    107011.170  100%    \nr.schedulers.IOSchedulerPerf.observeOn                                           N/A    1000       6835.942  |      6934.710  101%     |      4307.395  63%  -- \nr.schedulers.IOSchedulerPerf.observeOn                                           N/A 1000000         13.804  |        13.076  95%      |        10.003  72%  -- \nr.schedulers.IOSchedulerPerf.subscribeOn                                         N/A       1     113589.713  |    112548.761  99%      |    112666.557  99%     \nr.schedulers.IOSchedulerPerf.subscribeOn                                         N/A    1000      31572.535  |     31359.484  99%      |     31608.746  100%    \nr.schedulers.IOSchedulerPerf.subscribeOn                                         N/A 1000000         43.469  |        43.259  100%     |        43.581  100%    \nr.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                            1     N/A    4885450.713  |   4663855.111  95%      |   4769133.206  98%     \nr.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                         1000     N/A      36567.449  |     34794.653  95%      |     36690.199  100%    \nr.subjects.ReplaySubjectPerf.subscribeAfterEventsCount1                      1000000     N/A         46.758  |        44.710  96%      |        49.111  105%    \nr.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                         1     N/A    5166859.073  |   4928418.828  95%      |   5233752.980  101%    \nr.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                      1000     N/A      36677.914  |     35071.647  96%      |     37576.169  102%    \nr.subjects.ReplaySubjectPerf.subscribeAfterEventsUnbounded                   1000000     N/A         45.299  |        43.800  97%      |        46.962  104%    \nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                           1     N/A    3602234.043  |   3467543.784  96%      |   3700116.809  103%    \nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                        1000     N/A      47750.855  |     46718.061  98%      |     47680.041  100%    \nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsCount1                     1000000     N/A         42.764  |        47.144  110% ++  |        48.698  114% ++ \nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                        1     N/A    3787851.518  |   3637162.254  96%      |   3705592.692  98%     \nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                     1000     N/A      43472.144  |     46173.174  106%     |     46912.710  108%    \nr.subjects.ReplaySubjectPerf.subscribeBeforeEventsUnbounded                  1000000     N/A         42.057  |        41.150  98%      |        46.833  111% ++ \n```\n\nThe drop from 1024 to 128 makes it work okay with no pooling. At 1024 we needed the pooling. \n",
        "Any of you able to check performance and object allocation behavior using https://github.com/ReactiveX/RxJava/pull/1944 so it's not just my judgement on this? Is removing the object pool okay while using SpscArrayQueue as long as we stay at size 128?\n\nCan you get WeakReference pooling to work better than the \"no pooling\" performance?\n",
        "@akarnokd based on the perf numbers above what do you think we should do?\n",
        "Should we move forward with this change in 1.0.x or should it be 1.1? I have not seen any evidence in my testing to suggest that this is a significant change in GC behavior ... which surprised me and is why I'm hesitant and want confirmation. \n",
        "By the way, nothing we're doing here should affect Android since we use a LinkedList without pooling on Android. \n",
        "We use the SpscRingBuffer for non-Android since it uses `sun.misc.Unsafe` and a `synchronized` `LinkedList` for Android. Is a `synchronized` `ArrayDeque` preferred for Android then? The max size for Android is set to 16 instead of 128. With LinkedList nothing is allocated until it is needed. If we use `ArrayDeque` would you want it set to 16 as the initial capacity or something like 2 and let it grow if needed?\n",
        "Here is the size for Android: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L264 and the list impl choice when `Unsafe` is not available: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L324\n\nThe conditional check for `unsafe` happens here: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/util/RxRingBuffer.java#L44\n\nIf you want to make a change for Android would you like to submit a PR?\n",
        "> What versions of Android are supported?\n\nWe code to Java 6 and I believe it is Android API 9+ as per discussions in https://github.com/ReactiveX/RxJava/issues/153 and https://github.com/ReactiveX/RxJava/issues/1004\n",
        "It will never exceed 16 due to how the backpressure approach works, it will throw a `MissingBackpressureException` instead if the origin doesn't respect the requested amount. \n\nOften the buffer is not needed, or it's only needed for a single value (using Observable like a Future) so on Android what is better, allocating a 16 size array and maybe only using 1 spot, or allocating linked nodes only as needed but potentially allocating more in a slow/contended stream of data?\n\nDo you want to submit a PR with the changes done as you'd like them for Android?\n",
        "I have added https://github.com/ReactiveX/RxJava/pull/1969 with Flight Recorder tests showing the impact of removing pooling. It's not catastrophic but it also shows signs of being a potential problem. This is exactly the type of metrics that pushed me to add object pooling. That said, because we've dropped from 1024 to 128 the impact is not anywhere near as bad as it was before. \n",
        "This test is particularly bad: OperatorMergePerf.mergeNAsyncStreamsOfN\n\nThis suggests we can't eliminate pooling and use array queues.\n\nWith Pooling\n\n![screen shot 2014-12-13 at 11 22 24 am](https://cloud.githubusercontent.com/assets/813492/5424991/64bbd122-82ba-11e4-911f-c835a016d1db.png)\n\nWithout\n\n![screen shot 2014-12-13 at 11 22 29 am](https://cloud.githubusercontent.com/assets/813492/5424992/6c478210-82ba-11e4-8484-1f456c9dd18e.png)\n\nWith Pooling\n\n![screen shot 2014-12-13 at 11 22 40 am](https://cloud.githubusercontent.com/assets/813492/5424993/717c5eea-82ba-11e4-9efd-077afd519359.png)\n\nWithout\n\n![screen shot 2014-12-13 at 11 22 45 am](https://cloud.githubusercontent.com/assets/813492/5425008/b0651f2a-82ba-11e4-97d6-90a642594e9f.png)\n",
        "I have submitted another variant in https://github.com/ReactiveX/RxJava/pull/2189\n\nIt makes different tradeoffs to allow for object pooling to work in most use cases, normal GC in edge cases (haven't found a consistent one yet, only theoretical, but I haven't tried hard yet), while maintaining more-or-less the same performance characteristics as the current 1.x code. \n\nI have NOT battle-tested this and intend on sleeping on it then reviewing again, but wanted to post to trigger discussions and get a review on the direction and trade-offs. \n",
        "I tried another implementation, this time with a `WriterReaderPhaser` in #2243. It performs similarly to the RWLock and WIP implementations and worse than #2189. \n",
        "Problem definition:\n- The current approach to removing the object pool occasionally results in concurrency issues because concurrent emission/unsubscribe can result in 2 instances of RxRingBuffer holding a single queue.\n- Retaining a reference to the `queue` to avoid a `NullPointerException` results in the same problem of 2 RxRingBuffer instances holding a single queue. \n- In short, synchronization is needed between emission and unsubscribe in order to safely release the `queue` to the pool.\n\nA refresher on what has been attempted so far while exploring this:\n- All attempts at removing the object pool have resulted in performance degradation via significant increases in object allocation and GC time. This was pursued since removing the pool would eliminate the race condition. \n- Use of WIP, mutex, RW lock, and WriterReaderPhraser make it thread-safe but at significant performance penalty in the normal happy-path (see performance numbers below)\n- Attempts with using WeakReference have failed so far. Every attempt I've made suggests that ReferenceQueue has non-trivial overhead and unfortunately it's the only way to get the \"callback\" via polling that something is released. It doesn't help much that it was written in Java 1.2 and is heavily synchronized. We can't implement our own as this code is special-cased by the JVM since it is involved in GC. \n\nThe behavior we're trying to deal with is:\n- Emissions are all serial from the same thread. Draining may happen on a second thread. It is SPSC in behavior. \n- Unsubscribe generally comes from the same thread, but does not have to, hence the possibly concurrency. This race happens only once, at the end. \n- It is okay if the unsubscribe/emission race is non-deterministic (finish emitting then unsubscribe or unsubscribe immediately and drop data). \n\nHere are performance numbers of the various tests I've done:\n\n```\nBenchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP     WRPhaser\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628  5147447.030\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955    27779.876\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260       27.694\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289   100516.101\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313        4.413\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614  4510099.724\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407   462373.555\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171    41354.668\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417  4986054.668\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212       27.755\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646    78550.912\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948     2310.804\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848  4486879.415\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267    37424.146\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611       32.287\n```\n",
        "I'd like to move forward on something since we do currently have a correctness issue. \n\nUnless there is some performance or functional issue I am not yet aware of, I suggest we move forward with https://github.com/ReactiveX/RxJava/pull/2189 since it seems to work while retaining performance, despite not being the most elegant of approaches. \n\nOnce we've merged and released to fix the correctness issue, other more elegant solutions can continue to be pursued. I'd love for something such as the WriterReaderPhaser to work and retain performance. \n",
        "As a fun aside, and because this is happening over the holidays, here are some pages from a book I just read my girls the other day that totally made me think of this issue and many others like it :-)\n\n![screen shot 2014-12-27 at 10 30 00 pm](https://cloud.githubusercontent.com/assets/813492/5563235/2c1e51fa-8e18-11e4-8865-fca3cd9e77ad.png)\n\n![screen shot 2014-12-27 at 10 30 17 pm](https://cloud.githubusercontent.com/assets/813492/5563236/31728edc-8e18-11e4-84ac-dc8f3d05e942.png)\n\n![screen shot 2014-12-27 at 10 30 27 pm](https://cloud.githubusercontent.com/assets/813492/5563237/35c8133a-8e18-11e4-9bf3-0c3457ca4f8b.png)\n\nBook at http://www.amazon.com/Most-Magnificent-Thing-Ashley-Spires-ebook/dp/B00IZH626G\n\nSpoiler ... she eventually succeeds, though still with a few imperfections :-)\n",
        "It's quite odd Spsc is failing since everything should be serialized, i.e., only 1 thread offering values to the internal queues at a time and only 1 thread collecting from all queues, right? Thread hopping should not affect Spsc. I can only speculate, but when I did some backpressure-related code lately, I often didn't get the consumption phase right at first: the case where upstream produces and downstream requests at the same time, both may end up in the drain loop. This is why I used the emitting flag in onBackpressureBlock or in backpressure-aware ReplaySubject.\n",
        "The problem with pooling is that it can now become the congestion point: multiple threads might want to grab an element from the pool at the same time.\n\nThe alternative is reference counting:\n\n``` java\npublic void onNext(Object o) {\n   Queue<Object> q = queue;\n   if (q != null && q.acquire()) { // i.e., cas 1 -> 2\n      q.offer(o);\n      q.release(); // i.e., decrementAndGet\n   }\n}\npublic void unsubscribe() {\n   Queue<Object> q = queue;\n   if (q != null) {\n        queue = null;\n        q.release();\n   } \n}\n```\n\nCould be achieved via AtomicInteger. When borrowed, the queue starts out in 1. Use toggles this between 1 and 2. If an unsubscription happens, the party that goes from 1 to 0 will put the queue back into the pool. The drawback is that now you have extra bookkeeping which may halve the throughput in RxRingBufferPerf.\n",
        "I think false sharing isn't really an issue by us because how te queus are used: the producer is likely to win the drain race and emit data, or the queue is practically full and only 1 element is put for each 1 element taken (request(1) in merge and observeOn) and the two sides are far away to each other and no false sharing happens. So an unpadded queue of 128 capacity takes up 1024+16+32 bytes nicely fitting in L1. The padded version takes 65k.\n",
        "The no-pool 128 version seems to be the best choice generally. Maybe the low spscCreateUseDestroy1 case can be improved by removing the pad and complex hierarchy from the main class.\n",
        "Quite clever; no CAS, no tombstone and no copying. However, correct me if I'm wrong, but it seems the code on [line 135](https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java#L135) may read beyond the buffer if offset is at the last element. The other thing I see is that the queue should disallow offering Object[] values because it would confuse the poll. Better yet, when a new array needs to be communicated, wrap it into a private holder class so it is not confused with any other type; resize should be infrequent enough to not cause significant overhead.\n",
        "Since the queues are limited to RxRingBuffer.SIZE, it might be worth considering this growable queue doesn't grow in several steps but jumps immediately to its maximum value. In my two-phased version, I also triggered a growth after cerain number of elements have been offered; this helped eliminating the cost of CAS for long running queues. Here, if the poll() can know no more resize can happen, an `instanceof` may be avoided (replaced by a simple boolean flag).\n",
        "The RxRingBuffer has been fixed and the JCTools queues have been upgraded in 1.0.5. Pooling seems to be the only way to increase the performance of single-shot merging of values.\n",
        "Just to let you know I have added an Spsc which might fit the bill here:\nhttps://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java\nSmall footprint, grows to max size if the queue needs to grow (if consumer falls behind), still has some of the false sharing protection. Seems to perform well in my benchmarks, let me know how it works for you.\n",
        "Fixed as per your suggestions in https://github.com/JCTools/JCTools/issues/43\nI think the factor of 2 growth is beneficial, especially since CAS is no longer required. You'll be saving up on intermediate sizing, but suffering in the case of transient spike.\nI considered adding a 'max capacity reached flag', still playing with it. I think the instanceof check is not that costly if you mean to actually use the returned object. \n",
        "@benjchristensen with which params are you running jmh + jfr?\n"
    ],
    "5391": [],
    "4707": [],
    "6881": [],
    "6532": [],
    "714": [],
    "3415": [],
    "1597": [],
    "778": [],
    "1121": [],
    "5795": [],
    "654": [],
    "3118": [],
    "352": [],
    "6616": [],
    "600": [],
    "5208": [],
    "4386": [],
    "1941": [
        "What version did this bug start happening for you?\n",
        "I just tried this while going back in time on version and this has been failing since at least 0.20 so has been a bug for a long time. \n\nDigging into it ... \n",
        "I think I found the issue. It's going to require some thought to figure out a solution that doesn't kill performance but I'm working on it. \n\nSurprising this bug wasn't found sometime in the past couple months as this has existed since 0.20.0.\n",
        "I thought I had it fixed but further stress testing still reveals it ... just less often. It's not going to get fixed tonight as there is something going on that I'm not yet understanding. \n",
        "@myinsiders are you by chance also using `onBackpressureBuffer()` in your code?\n",
        "If I comment out `.onBackpressureBuffer()` I can not replicate the test failure, even if I put the test in a loop and let it run for several minutes. This could explain why my \"fixes\" to `merge` made it less likely to happen by changing the timing of whatever is happening but didn't actually fix it. I'm looking now at `.onBackpressureBuffer()` to see what is wrong there. \n\nOf course ... absence of a failure is not helpful in concurrency bugs so I'm not certain about anything yet. \n\n@myinsiders This is the reason for my previous question. If you are experiencing this without the use of any `onBackpressure*` operators then that means there is something else at fault. \n",
        "> in the breaking cases the producer I created would get a single request for 128 items and no further requests.\n\nDo you have a unit test for this showing what operators were composed together that caused it when you weren't using `onBackpressureBuffer`?\n",
        "Thanks @akarnokd for the tip. I'll try porting that impl to `onBackpressureBuffer` instead of trying to fix what's there. \n",
        "Well ... it won't be a port as looking at the code shows it's solving something different, so I'll seek inspiration from it :-)\n",
        "Thanks for your research and help on this!\n\n> if (emitted > THRESHOLD) \n\nThat's the part of code I too have been playing with. I'm trying to convince myself that it actually fixes it and understand why. \n\nI have re-written the batching 3 different ways in increasingly simpler and slower approaches, and even in implementations I think are indeed thread-safe, I still see the issue (but less often). I don't yet understand what it is about the batching that causes the problem. \n\nI'm close to admitting defeat for right now and releasing 1.0.3 without the batching and accepting the performance hit to achieve correctness. \n\nWhat do you think we should do? Do you have any ideas on how to fix the batching?\n",
        "By the way, both your implementation and that of @akarnokd for `onBackpressureBuffer` doesn't fix this issue so I agree that's not the problem and that it is indeed `merge`.\n",
        "#1961 is a pull request that removes request batching. It seems to make the test case work correctly. I tested it in a loop of thousands of invocations and couldn't get it to fail.\n\nIt does have a performance hit as shown on the pull request but I agree we need to fix the correctness and then continue working on the performance. \n\n> Perhaps those smart cookies @akarnokd and @zsxwing might spot something while you sleep on it. \n\nI sure hope so! :-) It's pretty awesome how collaboration on this project makes it so much better than any one person.\n\n> I'd be interested to know what techniques people are using to debug these concurrency issues \n\nI still use `println` a lot, but on this particular issue I found that some places I'd put a `println` would actually make the issue go away, so I had to instead do \"async logging\" by putting messages in a queue and only printing them out if the issue happened. You can see that code in the modified unit test of the pull request. \n\nI've also been exploring the RxJavaDebug hooks that @abersnaze is continuing to mature. We still need some work on that though as a single failed test run of this generated 20MB of output :-) That made it difficult to find anything of value. \n\nOn this particular issue with the async debugging approach I was able to see when requests were being made from merge on successful runs and not being made on failed runs. I added the `doOnRequest` operator to enable that. \n\n> anyone has had a win with something more sophisticated\n\nThis is still an area we need to improve, but concurrency is still hard and that isn't going away :-)\n\nI'm hopeful on what RxJavaDebug will eventually be able to do for us once we we take the raw output and visualize or summarize it. \n",
        "I have chosen to move forward with #1961 and remove the batching so we get correctness at the cost of some performance in certain use cases. We can continue pursuing more performant solutions in future releases, but we need to fix the correctness and I don't deem the performance hit significant enough to hold off the fix. \n",
        "@davidmoten @myinsiders Can each of you try building a jar from the master branch and running it in your application to determine if we have indeed fixed this issue? If you can do it today that would be ideal as I would like to release 1.0.3 today or tomorrow to get this batch of fixes released. \n",
        "Thanks @davidmoten and thank you @myinsiders for the confirmation. \n",
        "The distinct operator will remember every event it sees so can be a major memory bloat or leak on an infinite stream. \n",
        "Since merge seems to have worked for you are you okay with me releasing 1.0.3 with current fixes?\n",
        "> I'm happy for 1.0.3, thanks.\n\nGreat, I'm releasing what's currently in master and the other items we're working on can get into the next release. \n\n> not very performant\n\nI'm wondering if the chunking of work is too granular and thus the overhead of copying between threads outweighs the benefit of parallel processing. This is a key reason why we removed the `parallel` operator which naively did round-robin across threads. Is it possible this is the performance hit you're seeing? Also I imagine it's just queueing all that work since `merge` does not limit the number of async tasks it allows so it will suck in that file as fast as it can and bloat memory horizontally while each small chunk of work is only 120 lines. \n\nHere are simple examples of using either `buffer` or `window` to batch:\n\n``` java\n    /**\n     * If a single stream needs to be split across multiple CPUs it is generally more efficient to do it in batches.\n     * \n     * The `buffer` operator can be used to batch into chunks that are then each processed on a separate thread.\n     */\n    private static void flatMapBufferedExampleAsync() {\n        Observable.range(0, 5000).buffer(500).flatMap(i -> {\n            return Observable.from(i).subscribeOn(Schedulers.computation()).map(item -> {\n                // simulate computational work\n                    try {\n                        Thread.sleep(1);\n                    } catch (Exception e) {\n                    }\n                    return item + \" processed \" + Thread.currentThread();\n                });\n        }).toBlocking().forEach(System.out::println);\n    }\n\n    /**\n     * Or the `window` operator can be used instead of buffer to process them as a stream instead of buffered list.\n     */\n    private static void flatMapWindowedExampleAsync() {\n        Observable.range(0, 5000).window(500).flatMap(work -> {\n            return work.observeOn(Schedulers.computation()).map(item -> {\n                // simulate computational work\n                    try {\n                        Thread.sleep(1);\n                    } catch (Exception e) {\n                    }\n                    return item + \" processed \" + Thread.currentThread();\n                });\n        }).toBlocking().forEach(System.out::println);\n    }\n```\n\nDo either of those improve things? They won't solve the backpressure requirement though as `merge` allows unbounded horizontal growth of the number of async items being merged. \n",
        "To me, the while loop inside the pollQueue looks suspicious. My code in the backpressure-supporting [ReplaySubject seems to be working](https://github.com/akarnokd/RxJava/blob/SubjectBackpressure/src/main/java/rx/subjects/ReplaySubject.java#L399) there.\n",
        "Not a problem, I just found a bug in it. It has to re-read n after the while loop inside the sinchronized block because it is possible 1 is requested just after the loop but just before entering the sync block. Correctly:\n\n``` java\nsynchronized (observer) {\n    boolean atEnd = idx == index;\n    n = observer.requested();\n    if (n == 0 || atEnd) {\n        observer.index(idx);\n        runFinal = false;\n        observer.emitting = false;\n        break;\n    }\n}\n```\n\nBut perhaps [OnBackpressureBlock.drain()](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java#L96) does a better job.\n\nEdit: no it doesn't. It has a similar race condition.\n\nThe correct behavior would be from L138:\n\n``` java\n// decrement and get\nrequestedCount -= emitted;\nn = requestedCount;\n// if either run out of requests or no new data arrived since last poll, quit\nif (n == 0 || queue.peek() == null) {\n     skipFinal = true;\n     emitting = false;\n     return;\n}\n```\n\n`requestedCount` can't change while we are in this synchronized block. If a queue.put succeeded just after the null test, we will quit anyway and since put is followed by drain call, that drain call is blocked out until our sync-block quits as well. Then that drain may enter, find the emitting false and resume emitting.\n",
        "Merge has been fixed in 1.0.5 so I'm closing this.\n",
        "I'm hitting this bug too, flatMap is requesting 128 items and never requesting the rest.\n",
        "@davidmoten We're temporarily working around it by setting a high value for the rx.ring-buffer.size system property - you may be able to do that and continue using flatMap.\n",
        "We are using onBackpressureBuffer, but I also tried implementing backpressure myself (as otherwise we'd get the odd exception that our Observable didn't support backpressure), and in the breaking cases the producer I created would get a single request for 128 items and no further requests.\n",
        "(however in the case where we didn't have onBackPressureBuffer and we didn't have a producer, we didn't get these particular symptoms)\n",
        "Hi,\n\nI'm already running with a custom build with the two PRs concerned for a couple of days and no issues so far ...\n",
        "updated example with a couple of missing static methods\n",
        "I chucked the PR because I hadn't understood the merge code enough. \n\nWhat is interesting in the test above is that if you take the `pauseForMs(1)` out I don't get failures and if I synchronize the pause then I also don't get failures.  This suggests to me that it's a problem that presents itself when items are queued due to concurrent emission to OperatorMerge in combination with items that are emitted to OperatorMerge non-concurrently. It looks like DRAIN_ACTION does not request enough in those circumstances.\n",
        "This merge problem is a problem for me at the moment as I encounter it 19 out of 20 times when concurrently reading and processing large text files concurrently. The timings seem to hit the merge problem spot nearly every time so I'm forced to use concatMap instead of flatMap and endure much longer run times until this problem gets sorted.\n",
        "@benjchristensen 1.0.2, but haven't been doing this sort of task for three months (and probably was using a pre-backpressure release at the time for the task when it was working) so unfortunately didn't give the release candidates a workout.\n\n@myinsiders I bumped up rx.ring-buffer.size to 131072 and I notice that I stall when I hit >numProcessors\\* ringBufferSize items merged (I flatmap over `Schedulers.computation()`). As I read and merge hundreds of millions of items the workaround won't fly but thanks for the suggestion.\n",
        "Delighted you're making progress. I just discovered another of our applications was eating up our container heap because it used onBackpressureBuffer for a slowish stream (100msgs/second) and the merge had stalled.  \n",
        "I tried replacing the `onBackpressureBuffer()` with a simplified less performant etc version via `.lift(new OnBackpressureBuffer2())` and test still fails.\n\nAnother bit of trivia is that if in L653 in OperatorMerge.java I replace \n\n``` java\nif (emitted > THRESHOLD) \n```\n\nwith \n\n``` java\nif (emitted > 0)\n```\n\nthen test passes. So my uneducated guesses are suggesting the problem is in  `OperatorMerge`.\n\n``` java\npackage rx.internal.operators;\n\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport rx.Observable.Operator;\nimport rx.Producer;\nimport rx.Subscriber;\n\npublic class OperatorOnBackpressureBuffer2<T> implements Operator<T, T> {\n\n    private final NotificationLite<T> on = NotificationLite.instance();\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\n        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();\n        final AtomicLong requested = new AtomicLong();\n\n        child.setProducer(new Producer() {\n\n            @Override\n            public void request(long n) {\n                if (requested.getAndAdd(n) == 0) {\n                    pollQueue(requested, queue, child);\n                }\n            }\n\n        });\n        // don't pass through subscriber as we are async and doing queue\n        // draining\n        // a parent being unsubscribed should not affect the children\n        Subscriber<T> parent = new Subscriber<T>() {\n            @Override\n            public void onStart() {\n                request(Long.MAX_VALUE);\n            }\n\n            @Override\n            public void onCompleted() {\n                queue.offer(on.completed());\n                pollQueue(requested, queue, child);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                queue.offer(on.error(e));\n                pollQueue(requested, queue, child);\n            }\n\n            @Override\n            public void onNext(T t) {\n                queue.offer(on.next(t));\n                pollQueue(requested, queue, child);\n            }\n\n        };\n\n        // if child unsubscribes it should unsubscribe the parent, but not the\n        // other way around\n        child.add(parent);\n\n        return parent;\n    }\n\n    private synchronized void pollQueue(AtomicLong requested, ConcurrentLinkedQueue<Object> queue,\n            Subscriber<? super T> child) {\n        if (requested.get() > 0) {\n            while (true) {\n                Object o = queue.poll();\n                if (o != null) {\n                    if (!on.isCompleted(o) && !on.isError(o)) {\n                        requested.decrementAndGet();\n                        on.accept(child, o);\n                    } else {\n                        queue.clear();\n                        on.accept(child, o);\n                        return;\n                    }\n                } else\n                    return;\n            }\n        }\n    }\n\n}\n```\n",
        "Well, if you release without batching I did a test and it's the same speed roughly as `concatMap`, zero benefit of multiple processors if anyone tries to do stuff in parallel. Correctness is better to have though so probably a good idea to release 1.0.3 as you're suggesting. Perhaps those smart cookies @akarnokd  and @zsxwing might spot something while you sleep on it. Haven't seen anything stymie you guys for long.\n\nI'll see if I can come up with some more trivia to add to our knowledge over the weekend (kids permitting).\n",
        "I'd be interested to know what techniques people are using to debug these concurrency issues (beyond studying the code). My tool of choice is `System.out.println` (and studying the code) and I wonder if anyone has had a win with something more sophisticated (and less tedious).\n",
        "Ben, I can run the test tomorrow morning Tues Australian time. Will let you know.\n",
        "@benjchristensen \n\nRighto I've run my use case and I'm a bit concerned. I'm not getting stalls nor errors but I am getting exponentially slowing performance. Below are log lines from a run with `flatMap` over `Schedulers.computation()` vs `concatMap` also over `Schedulers.computation()` (though it would not give concurrent computation).\n\nLet me describe the use case. Each flatmapped task is to read <120 character lines from gzipped text files with about 11 million lines in each using `StringObservable` and to map those (actually flatmap in case parsing fails) to objects. These streams are then merged and processed a little bit (some simple filtering). I have hundreds of files and because the flatmap is occuring over `Schedulers.computation()` I see six files being processed at a time. Each file should take about 2 mins to process being read from SSD.\n\nSo that's way more detail than you require no doubt but I hope that someone will knock up a test to duplicate this problem. I might be able to move my exact code to github later today with a bit of luck (I clearly don't need to make available all of my input data as the problem is visible after hundreds of thousands of lines rather than millions).\n\n```\nflatMap - exponential slowdown of emissions from the merge\n\n2014-12-16 10:34:34.692  [RxComputationThreadPool-4] - count=200000\n2014-12-16 10:34:43.779  [RxComputationThreadPool-4] - count=300000\n2014-12-16 10:34:59.645  [RxComputationThreadPool-4] - count=400000\n2014-12-16 10:35:11.019  [RxComputationThreadPool-4] - count=500000\n2014-12-16 10:36:10.976  [RxComputationThreadPool-4] - count=600000\n2014-12-16 10:40:23.606  [RxComputationThreadPool-4] - count=700000\n\n\nconcatMap - roughly constant emission rate\n2014-12-16 10:42:08.513  [RxComputationThreadPool-1] - count=100000\n2014-12-16 10:42:15.260  [RxComputationThreadPool-1] - count=200000\n2014-12-16 10:42:19.817  [RxComputationThreadPool-1] - count=300000\n2014-12-16 10:42:26.797  [RxComputationThreadPool-1] - count=400000\n2014-12-16 10:42:31.482  [RxComputationThreadPool-1] - count=500000\n2014-12-16 10:42:38.093  [RxComputationThreadPool-1] - count=600000\n2014-12-16 10:42:43.359  [RxComputationThreadPool-1] - count=700000\n2014-12-16 10:42:49.655  [RxComputationThreadPool-1] - count=800000\n2014-12-16 10:42:55.845  [RxComputationThreadPool-1] - count=900000\n```\n",
        "I think I've confused the issue because the above stats though of concern to me are not properly isolated to merge. Downstream of merge is a distinct and that confuses things. \n\nI've run it again trimmed down and I get good performance from the merge only.\n\nIf rxjava is spinning its wheels madly at the distinct point because of the fast feed from a merge of async sources then I'll  try and make a test and report it separately.\n",
        "yep, not very performant I should add but works. I read 4.36m records in 3:40 using flatmap with 6 processors tapped out and the same in 4:00 with concatmap with 1 processor.  I'm happy for 1.0.3, thanks.\n",
        "Thanks for the detailed info Ben, I'll give it a try.\n"
    ],
    "3642": [],
    "6677": [],
    "5395": [],
    "4530": [],
    "5492": [],
    "3512": [],
    "724": [],
    "843": [],
    "1421": [],
    "2460": [],
    "4528": [],
    "5780": [],
    "1787": [],
    "5719": [],
    "317": [],
    "763": [],
    "6845": [],
    "3592": [],
    "3974": [],
    "2830": [],
    "4317": [],
    "378": [],
    "539": [],
    "4941": [],
    "5389": [],
    "6798": [],
    "977": [],
    "1746": [],
    "3050": [],
    "5546": [],
    "1598": [],
    "1462": [],
    "196": [],
    "6674": [],
    "5662": [],
    "2777": [],
    "6143": [],
    "949": [],
    "5114": [],
    "642": [],
    "5942": [],
    "923": [],
    "1886": [],
    "3033": [],
    "3306": [],
    "1102": [],
    "1739": [],
    "916": [],
    "3491": [],
    "474": [],
    "5982": [],
    "1613": [],
    "510": [],
    "669": [],
    "1191": [],
    "237": [],
    "832": [],
    "704": [],
    "1032": [],
    "1883": [],
    "5749": [],
    "3864": [],
    "4166": [],
    "2470": [],
    "4740": [],
    "5792": [],
    "1646": [],
    "5925": [],
    "648": [],
    "3151": [],
    "5251": [],
    "162": [],
    "1242": [],
    "285": [],
    "347": [],
    "4435": [],
    "3712": [],
    "3069": [],
    "707": [],
    "633": [],
    "6023": [],
    "842": [],
    "3060": [],
    "6787": [],
    "4542": [],
    "4738": [],
    "4266": [],
    "1043": [],
    "6386": [],
    "1793": [],
    "4460": [],
    "5467": [],
    "5257": [],
    "4994": [],
    "257": [],
    "5286": [],
    "6295": [],
    "1457": [],
    "2997": [],
    "3410": [],
    "3082": [],
    "4076": [],
    "5049": [],
    "5302": [],
    "3309": [],
    "2901": [],
    "4229": [],
    "904": [],
    "2191": [
        "I've been looking at this problem as well - I found it in both OnSubscribeCache and OperatorMulticast so far.  I fixed it by adding unsubscribe logic to the Subscribers.from/create factories, and using .from on the Subject in OperatorMulticast instead of the anonymous inner class (which then corrects the OnSubscribeCache case as well). 7c45286 is the right commit - the previous one was missing an import statement.\n",
        "@zsxwing, fair enough, I've submitted PR: https://github.com/ReactiveX/RxJava/pull/2455\nOh, and I don't the travis build failure is related to the PR itself\n",
        "A bug in `cache`. See #2238\n",
        "@michelbetancourt sure, you can test pr #2238 by yourself. I think it will be fixed in the next release once @benjchristensen merges it.\n",
        "@duncani To fix `OperatorMulticast`, you can simply change the line https://github.com/ReactiveX/RxJava/blob/3cecb9037aaf11c131451fef962d749487420798/src/main/java/rx/internal/operators/OperatorMulticast.java#L146 to `source.subscribe(subscription);`\n\nCould you also write a test and send a PR?\n",
        "You seem to create 100 caches and wait for it asynchronously in a tight loop and the observable elements wait on blocking gets. This delays their actions and the IO scheduler has less opportunity to reuse its pools. Schedulers.from is a weaker construct and allows thread hopping so it is more likely an idle worker can pick up more work.\n\n@zsxwing can you check if we leak workers because of Async?\n",
        "Schedulers.computation() uses a fixed set of worker threads in a round-robin fashion. I saw you commented out a sleep in the main loop. Could you place it after the thread.start call with 10ms to give that thread some chance?\n",
        "Hi @akarnokd .. I appreciate the quick response.  I can certainly agree that this example is a bit contrived.  I've been trying to reproduce an issue I found with real code in a much simpler form and this is the best I can do in short notice.  It would certainly be great to hear back on the potential leak.\n\nBtw, in case it helps, it seems like the issue is exclusive to Schedulers.io()\n\nFor example, if I use Schedulers.computational() I get thread re-use, sample result of program (last few entries like before):\nThread[RxComputationThreadPool-7,5,main]\nThread[RxComputationThreadPool-2,5,main]\nThread[RxComputationThreadPool-1,5,main]\nThread[RxComputationThreadPool-7,5,main]\nThread[RxComputationThreadPool-5,5,main]\nThread[RxComputationThreadPool-3,5,main]\nThread[RxComputationThreadPool-1,5,main]\nThread[RxComputationThreadPool-3,5,main]\nThread[RxComputationThreadPool-1,5,main]\nThread[RxComputationThreadPool-5,5,main]\nThread[RxComputationThreadPool-7,5,main]\n",
        "I attempted to use the computational scheduler to test out the theory that perhaps a leak at a higher level would cause the program to block.  The program worked as expected though, and had a similar outcome to the Cached-Thread Executor Scheduler -- showing signs of obvious thread re-use.\n\nI tried doing the sleep with the Schedulers.io() setup, but I get the same result as before -- no obvious signs of thread re-use.  I tried increasing from 10ms to 100-1000ms and still no luck.  Very similar outcome as before:\n...\nThread[RxCachedThreadScheduler-189,5,main]\nThread[RxCachedThreadScheduler-192,5,main]\nThread[RxCachedThreadScheduler-191,5,main]\nThread[RxCachedThreadScheduler-194,5,main]\nThread[RxCachedThreadScheduler-193,5,main]\nThread[RxCachedThreadScheduler-196,5,main]\nThread[RxCachedThreadScheduler-195,5,main]\nThread[RxCachedThreadScheduler-198,5,main]\nThread[RxCachedThreadScheduler-197,5,main]\nThread[RxCachedThreadScheduler-200,5,main]\nThread[RxCachedThreadScheduler-199,5,main]\ndone\n",
        "Hi @zsxwing , is the fix ready for testing?\n",
        "@zsxwing, I have confirmed that your fix addresses the original issue -- use of cache operator with Schedulers.io leaking threads.\n"
    ],
    "2330": [],
    "5890": [],
    "4039": [],
    "5936": [],
    "745": [],
    "1276": [],
    "2898": [],
    "376": [],
    "6453": [],
    "4976": [],
    "6087": [],
    "4038": [],
    "6235": [],
    "4173": [],
    "1211": [],
    "4160": [],
    "4351": [],
    "6045": [],
    "5872": [],
    "1738": [],
    "2655": [],
    "6167": [],
    "5915": [],
    "4182": [],
    "3260": [],
    "696": [],
    "1324": [],
    "749": [],
    "4962": [],
    "147": [],
    "4427": [],
    "3225": [],
    "5140": [],
    "1437": [],
    "324": [],
    "135": [],
    "777": [],
    "1190": [],
    "424": [],
    "2335": [],
    "6815": [],
    "1198": [],
    "3658": [],
    "887": [],
    "2297": [
        "I very much would like something like this, too.\n\nI do something similar to what you have but as a JUnit rule so it can be used as:\n\n``` java\n@Rule public final RxJavaPluginsResetRule pluginsReset = new RxJavaPluginsResetRule();\n```\n\nand it calls `.reset()` automatically both before and after each test.\n",
        "FYI RxAndroid shipped with a `@Beta reset()` method public on its `RxAndroidPlugins` class.\n",
        "I'm open to making it public. Do you want to submit the PR to make the change?\n\nThere are 2 reasons it is not public: \n\n1) I avoid making things public until they need to be as once public it must be supported for a very long time. \n2) The drawback ... resetting the plugins is not safe during application runtime and also bad code could invoke it in the middle of an application life-cycle and really break things. For example, a 3rd party transitive library that abusively calls `reset()` in order to always register its plugin automatically in place of anything else already registered. \n\nOf course, if someone wants to do that bad thing we can't prevent it anyways, since all someone has to do is put a class inside the same package and invoke `reset` from there. So the \"security drawback\" isn't a strong enough reason to avoid it. And the non-safe issue is one developers will just have to understand and use it wisely. In other words, `reset` should never be called during normal application operation. \n\n/cc @akarnokd @mattrjacobs @abersnaze for your thoughts on this\n",
        "As a work around for this what I have done by now is defining a RxJavaTestPlugins class on src/test/java/rx/plugins\n\n```\npublic class RxJavaTestPlugins extends RxJavaPlugins {\n    RxJavaTestPlugins() {\n        super();\n    }\n\n    public static void resetPlugins(){\n        getInstance().reset();\n    }\n}\n```\n\nAnd then invoke `resetPlugins()`  on the ~~tear down~~ setup of my units test before `registerSchedulersHook`\n\nIf your run it on the `tearDown` there can be another test that uses RxJava then, hence default hook is already loaded and you can't load your custom hook.\n",
        "Why don't you use operators which let you parametrize the scheduler and not rely on the defaults?\n\nFor the other hooks, you could set up a level of indirection, i.e., you register your own hook which then does allow setting/removing further hooks at will. You can even create it such a way that multiple hooks can work at the same time, but you have to implement a separate Observable-Observer and make careful decisions when these hooks return some value instead of just consuming.\n",
        "I don't use the plugin API so can't tell if its worth it or what consequences it holds. PR welcome.\n",
        "Closing via #3820\n",
        "I also think making `reset()` public would be very useful for unit testing. At the moment, there isn't a way of calling `registerSchedulersHook` during local unit tests that doesn't end up throwing `java.lang.IllegalStateException: Another strategy was already registered` \n\nThe closes I got was from the constructor of a custom test Runner but this only works for the first test case, the rest would throw the exception above. So the two option I have is catch the `IllegalStateException` so once my hook is registered it will live for the rest of the tests or use reflection to call reset. I'm using reflection for now but there should be a better way of achieving this.\n",
        "I ran into this exact problem and it was frustrating. I ended up creating the following TestWatcher, which is specific to verifying that there are no leaking subscriptions, but I suppose could be used more generally. \n\n```\n/**\n * This Verifier will assert that any subscriptions created during a test are unsubscribed after the\n * test has finished.<br>\n * \n * NOTE: It is very important that the call {@link #initialize()} is done before any\n * {@link Observable} is created. Failing to do so, means that the {@link SusbcriptionCollector}\n * would fail to collect any subscriptions.\n */\npublic class RxTestCaseSubscriptionsVerifier extends TestWatcher\n{\n    @Override\n    protected void starting( Description description )\n    {\n        SusbcriptionCollector subSusbcriptionCollector = SusbcriptionCollector.getInstance();\n\n        checkState( ! subSusbcriptionCollector.isCollecting(),\n                    \"Cannot start collecting subscriptions while another SusbcriptionCollector is \" +\n                    \"already collecting.\" );\n\n        subSusbcriptionCollector.startCollecting();\n    }\n\n    @Override\n    protected void succeeded( Description description )\n    {\n        SusbcriptionCollector subSusbcriptionCollector = SusbcriptionCollector.getInstance();\n\n        checkState( subSusbcriptionCollector.isCollecting(), \n                    \"Cannot assert all subscriptions are unsubscribed if the SusbcriptionCollector \" +\n                    \"was not collecting subscriptions\" );\n\n        subSusbcriptionCollector.assertAllSubscriptionsAreUnsubscribed();\n    }\n\n    @Override\n    protected void finished( Description description )\n    {\n        SusbcriptionCollector subSusbcriptionCollector = SusbcriptionCollector.getInstance();\n\n        subSusbcriptionCollector.reset();\n\n        checkState( ! subSusbcriptionCollector.isCollecting(), \n                    \"The SusbcriptionCollector should not be collecting once reset\" );\n    }\n\n    /**\n     * See NOTE in the class documentation.\n     */\n    public static void initialize()\n    {\n        SusbcriptionCollector.getInstance();\n    }\n\n    private static class SusbcriptionCollector\n    {\n        private static SusbcriptionCollector INSTANCE = null;\n\n        private final Map<Subscription, String> mSubscriptions =  Collections.synchronizedMap( Maps.newHashMap() );\n        private volatile boolean mShouldCollect = false;\n\n        private SusbcriptionCollector()\n        {\n            RxJavaPlugins.getInstance().registerObservableExecutionHook( createSubscriptionCollector() );\n        }\n\n        static synchronized SusbcriptionCollector getInstance()\n        {\n            if ( INSTANCE == null )\n                INSTANCE = new SusbcriptionCollector();\n\n            return INSTANCE;\n        }\n\n        void startCollecting()\n        {\n            mShouldCollect = true;\n        }\n\n        public void assertAllSubscriptionsAreUnsubscribed()\n        {\n            synchronized( mSubscriptions )\n            {\n                for ( Map.Entry<Subscription, String> entry : mSubscriptions.entrySet() )\n                {\n                    if ( ! entry.getKey().isUnsubscribed() )\n                    {\n                        fail( \"There was an non-unsubscribed subscription detected \" +\n                              \"which was created at the following place:\\n\" +\n                              \"<-------------------- start unsubscribed stack -------------------->\\n\" + \n                              entry.getValue() +\n                              \"<--------------------- end unsubscribed stack --------------------->\" );\n                    }\n                }\n            }\n        }\n\n        private void reset()\n        {\n            synchronized( mSubscriptions )\n            {                \n                mSubscriptions.clear();\n                mShouldCollect = false;\n            }\n        }\n\n        private boolean isCollecting()\n        {\n            return mShouldCollect;\n        }\n\n        private RxJavaObservableExecutionHook createSubscriptionCollector()\n        {\n            return new RxJavaObservableExecutionHook()\n            {\n                @Override\n                public <T extends Object> Subscription onSubscribeReturn( Subscription subscription )\n                {\n                    if ( ! mShouldCollect )\n                        return subscription;\n\n                    String stackTrace = Debug.getStackTrace( new Exception( \"Subscription not unsubscribed.\" ) );\n                    mSubscriptions.put( subscription, stackTrace );\n                    return subscription;\n                };\n            };\n        }\n    }\n}\n```\n\nthen in the test you need to add the following:\n\n```\n@Rule public final TestRule mSubscriptionsVerifier = new RxTestCaseSubscriptionsVerifier();\n```\n\nor in a Test Suite class you could do this if you want  to use the rule on all tests.\n\n```\n    @BeforeClass\n    public static void initializeRxVerifier()\n    {\n        RxTestCaseSubscriptionsVerifier.initialize();\n    }\n```\n",
        "@ivacf Not sure if you are referring to my previous comment, but it's very important that you add:\n\n```\n    @BeforeClass\n    public static void initializeRxVerifier()\n    {\n        RxTestCaseSubscriptionsVerifier.initialize();\n    }\n```\n\nto whatever class groups all you're tests. If you don't have a suite that groups tests, then it's possible this might have to be done before each test. Anyway, this was tricky and frustrating for the reasons you already mentioned.\n",
        "@JakeWharton Is there really a point of doing .reset() in your Rule? To me it doesn't seem to have the expected effect. Any subsequent call to Schedulers.\\* will still return the same original Scheduler even after calling .reset(). Since the hooks are only called once when the Schedulers instance is created.\n\nI can't seem to find a valid use case for using RxJavaPlugins to register test schedulers in unit tests really. Maybe it was never intended for that anyway.\n",
        "Here's an example of how you can accidently misuse TestScheduler to break unrelated tests.\nhttps://github.com/pakerfeldt/rxjava-the-schedulers-pitfall\n",
        "Actually, using a singleton TestScheduler wrapper we can more easily identify when we accidently initialize Schedulers before our hook is called (instead of just getting weird behavior in the test):\nhttps://gist.github.com/pakerfeldt/db297764918e7d464884#file-testschedulerproxy-java\n\nHowever, that would require all unit tests that happen to execute any code that would initialize Schedulers to first initialize our TestSchedulerProxy (which registers the hook). And possibly also advance / trigger the test scheduler I guess.\n",
        ":+1: \nI was trying to contribute back to `spring-cloud-sleuth` to have distributed tracing capabilities across RxJava threadpools as well (https://github.com/spring-cloud/spring-cloud-sleuth/issues/235). I am following their current `Hystrix` implementation strategy : https://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/hystrix/SleuthHystrixConcurrencyStrategy.java#L66\nYou could reset HystrixPlugins but the same cannot be done right now with RxjavaPlugins. I have to create a wrapper (as mentioned above) in the same `rx.plugins` folder as a workaround (testing as we speak if it's working or not). \nIt'd be good to not have to do this workaround. \n",
        "Hi! @benjchristensen @akarnokd @mattrjacobs @abersnaze  - any news on this? It doesn't seem like a big change and would certainly be helpful in Spring Cloud Sleuth's intergration with RxJava.\n",
        "Some good points. I definitely agree with \"as private as possible\" by default. \n\nAfter looking into it some more, I see that my use case would not precisely be served by this -- even if I could re-register a different hook, the `Scheduler` class will have already assigned its instance fields for `io`, `computation`, etc. \n\nFor now I am solving my testing issue by injecting a `Scheduler` with Guice which is annotated with `@Named(\"io\")`, and in the test substituting `Schedulers.test()` for that scheduler. I'm not sure I love that approach as the scheduler doesn't feel like a \"real\" dependency, and it's another thing which must be configured in the DI container... Another approach might be to sidestep the public API and swap out schedulers using something like PowerMock.\n\nSo, rambling aside -- making `reset()` public still would not let me tweak the default schedulers on a per-test basis. If I think of an alternative approach which doesn't seem to compromise the safety of the rest of the API I'll submit a PR.\n",
        "Not sure if its related to this issue, but just wanted to say that RxJava2 changed a few things about how to override schedulers. I found another way outlined here: http://stackoverflow.com/a/43320828/3870025",
        "I'm getting problem when I use:\n`@ClassRule public static final RxJavaPluginsResetRule pluginsReset = new RxJavaPluginsResetRule();`\ninstead of:\n`@Rule public final RxJavaPluginsResetRule pluginsReset = new RxJavaPluginsResetRule();`\n\n`@ClassRule` causes `(singleExecutionHook.get() == null)` to be `true` in `RxJavaPlugins.getSingleExecutionHook()` which leads to default hook for `RxJavaPlugins`.\n\nHow can it be possible?\nThanks!\n"
    ],
    "1396": [],
    "1048": [],
    "4651": [],
    "974": [],
    "4308": [],
    "4103": [],
    "1647": [],
    "1733": [],
    "3497": [],
    "1967": [],
    "784": [],
    "6154": [],
    "5153": [],
    "2909": [],
    "586": [],
    "5917": [],
    "5952": [],
    "2628": [],
    "497": [],
    "108": [],
    "1652": [],
    "5281": [],
    "3383": [],
    "2576": [],
    "1297": [],
    "502": [],
    "3719": [],
    "6498": [],
    "6750": [],
    "4599": [],
    "807": [],
    "4718": [],
    "2985": [],
    "1106": [],
    "3979": [],
    "3909": [],
    "4949": [],
    "4474": [],
    "4086": [],
    "5326": [],
    "5209": [],
    "619": [],
    "4936": [],
    "6846": [],
    "4345": [],
    "3277": [],
    "4915": [],
    "732": [],
    "856": [],
    "1137": [],
    "1355": [],
    "3971": [],
    "3351": [],
    "890": [],
    "1124": [],
    "4222": [],
    "918": [],
    "5495": [],
    "3403": [],
    "3565": [],
    "5724": [],
    "6103": [],
    "124": [],
    "3325": [],
    "1866": [],
    "5582": [],
    "892": [],
    "214": [],
    "6681": [],
    "1287": [],
    "1953": [],
    "3190": [],
    "4561": [],
    "3009": [],
    "2590": [],
    "4343": [],
    "1042": [],
    "6314": [],
    "3906": [],
    "3348": [],
    "2983": [],
    "4663": [],
    "1432": [],
    "4069": [],
    "5696": [],
    "6033": [],
    "636": [],
    "3358": [],
    "4337": [],
    "3969": [],
    "4020": [],
    "2493": [],
    "3149": [],
    "3395": [],
    "4803": [],
    "3579": [],
    "4930": [],
    "4860": [],
    "4066": [],
    "4330": [],
    "3308": [],
    "284": [],
    "5649": [],
    "4589": [],
    "3109": [],
    "880": [],
    "3741": [],
    "3821": [],
    "1729": [],
    "2549": [
        "Those are part of the public API and will break a project build if we change them. We can't break public APIs. \n",
        "What did my comment have to do with breaking changes?\n",
        "That's in the gray area as it is a semantic change, not an API change. So whether that's acceptable or not depends on if it is fixing a bug or not. If it's not and it is changing behavior then that's something we should not do.\n\nIt seems to me it was not a bug, and the javadoc clearly states what it was doing (wait until timeout or completion). So, I think that change should be reverted. \n",
        "I reverted the change in https://github.com/ReactiveX/RxJava/pull/2594\n\nIf we need this new behavior then we need to discuss it more and determine if it really is a bug and should have always been throwing an exception, or if there are times when returning without an error on timeout is legit behavior and thus we need two different methods. Go ahead and open a new issue to discuss this. \n",
        "@benjchristensen as per your comment in https://github.com/ReactiveX/RxJava/issues/2555#issuecomment-72726415\nI think you agree that we can break these Test APIs if necessary?\n",
        "I had comments in #2555 but you didn't reply:\n\n> I hope we can have some conclusion for #2549 before releasing 1.0.5, because I think awaitTerminalEvent(long timeout, TimeUnit unit) has been broken in #2332: before that it's quiet if timeout, but now it will throw a RuntimeException.\n> \n> I think the current behavior is more reasonable. I just wonder the policy about changing the behavior of a method in TestObserver/TestSubscriber/TestScheduler. For the changing of awaitTerminalEvent(long timeout, TimeUnit unit), should it be classified as a bug fix or a breaking change?\n\nSo I thought you agreed the breaking change.\n",
        "Here is the breaking change: https://github.com/ReactiveX/RxJava/pull/2332/files#diff-fbed6a16f49022fd2b10f45fd6dd015bR230\n"
    ],
    "3535": [],
    "864": [],
    "3867": [],
    "4011": [],
    "158": [],
    "1648": [],
    "1098": [],
    "6719": [],
    "2189": [],
    "5478": [],
    "2585": [],
    "1290": [],
    "4793": [],
    "1338": [],
    "5905": [],
    "6786": [],
    "1099": [],
    "5841": [],
    "5377": [],
    "2599": [
        "An `instanceof` test shoud do the trick.\n",
        "Closing as the requested change was merged via #2630.\n",
        "That sums it up nicely. :-)\n"
    ],
    "3584": [],
    "4252": [],
    "5415": [],
    "194": [],
    "1561": [],
    "3085": [],
    "5183": [],
    "1244": [],
    "4752": [],
    "3959": [],
    "3313": [],
    "4176": [],
    "2552": [],
    "357": [],
    "3246": [],
    "5231": [],
    "5058": [],
    "4736": [],
    "3820": [],
    "4792": [],
    "1803": [],
    "5907": [],
    "4071": [],
    "4810": [],
    "2656": [
        "sure.\n",
        "Thanks for the report. \n",
        "@abersnaze Since this probably affects work you're doing as well, can you take a look at what we need to fix here? It will be anything using the internal ScalarSynchronousObservable optimization I think. \n",
        "Closing via #3958\n",
        "What is the status of this issue? I've lost track of the proposed changes to `ScalarSynchronousObservable`.\n",
        "See #3958.\n"
    ],
    "1659": [],
    "3242": [],
    "546": [],
    "4364": [],
    "1040": [],
    "238": [],
    "1583": [],
    "3879": [],
    "5182": [],
    "4342": [],
    "4723": [],
    "1609": [],
    "1203": [],
    "3334": [],
    "397": [],
    "5432": [],
    "4486": [],
    "356": [],
    "5947": [],
    "3566": [],
    "805": [],
    "825": [],
    "4661": [],
    "4681": [],
    "790": [],
    "400": [],
    "3091": [],
    "300": [],
    "3353": [],
    "6085": [],
    "3147": [],
    "225": [],
    "6621": [],
    "3763": [],
    "4910": [],
    "4195": [],
    "1304": [],
    "565": [],
    "4326": [],
    "1469": [],
    "5241": [],
    "6595": [],
    "4357": [],
    "136": [],
    "988": [],
    "578": [],
    "5748": [],
    "3396": [],
    "3623": [],
    "1394": [],
    "3280": [],
    "27": [],
    "3386": [],
    "6442": [],
    "1275": [],
    "4359": [],
    "6133": [],
    "5668": [],
    "6496": [],
    "4249": [],
    "351": [],
    "4100": [],
    "663": [],
    "1020": [],
    "1560": [],
    "6392": [],
    "2862": [],
    "4113": [],
    "6375": [],
    "4687": [],
    "2988": [],
    "4135": [],
    "3268": [],
    "6835": [],
    "4686": [],
    "631": [],
    "1192": [],
    "6380": [],
    "5560": [],
    "5421": [],
    "4244": [],
    "3010": [],
    "2912": [],
    "3862": [],
    "915": [],
    "1036": [],
    "6216": [],
    "1931": [],
    "787": [],
    "1308": [],
    "3975": [],
    "1731": [],
    "5886": [],
    "2875": [],
    "705": [],
    "512": [],
    "582": [],
    "4677": [],
    "1061": [],
    "2476": [],
    "3111": [],
    "6730": [],
    "3092": [],
    "6545": [],
    "3948": [],
    "4614": [],
    "4387": [],
    "346": [],
    "1357": [],
    "5529": [],
    "6789": [],
    "6628": [],
    "4604": [],
    "6653": [],
    "1418": [],
    "2896": [
        "Thanks y'all!\n"
    ],
    "3185": [],
    "5664": [],
    "1305": [],
    "4658": [],
    "5644": [],
    "3188": [],
    "6838": [],
    "142": [],
    "446": [],
    "6607": [],
    "849": [],
    "3524": [],
    "755": [],
    "780": [],
    "1073": [],
    "5048": [],
    "5844": [],
    "5409": [],
    "1664": [],
    "3898": [],
    "576": [],
    "1835": [],
    "5324": [],
    "4178": [],
    "3319": [],
    "260": [],
    "4621": [],
    "4953": [],
    "6814": [],
    "4747": [],
    "4297": [],
    "5992": [],
    "1082": [],
    "2859": [],
    "806": [],
    "3294": [],
    "4292": [],
    "4921": [],
    "5867": [],
    "371": [],
    "6086": [],
    "526": [],
    "4353": [],
    "146": [],
    "3798": [],
    "1471": [],
    "3006": [
        "How about checking `isUnsubscribed` before `hasNext`, such as:\n\n```\n                        while (!o.isUnsubscribed() && it.hasNext() && --numToEmit >= 0) {\n                            o.onNext(it.next());\n                        }\n                        if (o.isUnsubscribed()) {\n                            return;\n                        }\n```\n",
        "Thanks for reporting. Fix released in 1.0.12.\n",
        "The problem arised when using an `Iterable` which produces iterators with a blocking `hasNext`.\nImagine the case where the `hasNext` call would block after retrieving 10 elements (so, in the eleventh call). Chaining a `take`/`limit` of 10 would still block, even after emiting 10 elements.\n\nWe did a quick patch:\n\n```\nwhile (it.hasNext() && --numToEmit >= 0) {\n                            if (o.isUnsubscribed()) {\n                                return;\n                            }\n                            o.onNext(it.next());\n                            if (o.isUnsubscribed()) {\n                                return;\n                            }\n\n                        }\n```\n",
        "Sorry, can't see the issue with `take`, can you elaborate? If the child has unsubscribed during the `onNext` then the next loop will check for unsubscription and exit. \n\nThe iterator `next` method could take enough time for unsubscription to have happened in the meantime so we could insert another check for unsubscription before emitting. I'll see what the others think of this as I imagine it would compromise performance a bit for common use cases like using java Collections as sources because each emission would require two volatile reads of `unsubscribed`.\n\n``` java\nif (o.isUnsubscribed())\n    return;\nT val = it.next();\nif (o.isUnsubscribed()) \n    return;\no.onNext(val);\n```\n\nIs this what you were meaning?\n",
        "@pelecomepibe yep that does look something to avoid\n@zsxwing LGTM\n"
    ],
    "3008": [
        "/cc @davidmoten\n",
        "This seems to be fixed in the latest 1.x\n",
        "Yep, I'll have a look at it in the next couple of days. @stealthcode I'll check it with #2997 which is looking to address a few `retry` issues.\n",
        "I've tested these with #2997 and they both pass.\n\nThe emissions are for retry with always true predicate:\n\n```\nmap 1\n1\nmap 2\nmap 3\nmap 1\n1\nmap 2\n2\nmap 3\n3\n```\n\nand for infinite retry:\n\n```\nmap 1\n1\nmap 2\nmap 1\n1\nmap 2\n2\nmap 3\n3\n```\n\nThe emissions are the same and are expected. I'm unsure why the extra line `map 3` occurs in the logging of retry with predicate but might be worth checking.\n\nI'll commit the two new unit tests (in `OperatorRetryWithPredicateTest`) to the #2997 PR. \n"
    ],
    "5444": [],
    "5465": [],
    "4546": [],
    "4711": [],
    "4695": [],
    "1316": [],
    "1019": [],
    "796": [],
    "4390": [],
    "2871": [],
    "3037": [
        "I took a crack at changing RxNetty to use `Observable<?>` but ran into generics problems when it came to its usage of `onErrorResumeNext(Func1)`.  Now that we have `doOnError(Action1)` that doesn't have to return `Observable<?>` it might work.\n",
        "> >  I took a crack at changing RxNetty to use `Observable<?>`\n> \n> Can you elaborate more i.e. were you trying to make RxNetty's `Connection.write()` return `Observable<?>` ?\n\nThe observer of the return value from `Connection.write()` only cares about the terminal state/time of that Observable and therefore shouldn't put any restrictions on the type of data that it is ultimately going to ignore.  If there are no restriction on the type then there wouldn't be any need for casting it to `Observable<Void>`.\n",
        "You wouldn't use concat because it doesn't make sense. Concat is concatenating the data you don't care about the data you are only using concat because enforces an order and propagation of errors.  Here is code that does what you want.\n\n```\nObservable<?> source = Observable.just(\"Hi\");\nsource.lift(new Operator<Integer, Object>() {\n    @Override\n    public Subscriber<? super Object> call(Subscriber<? super Integer> child) {\n        return new Subscriber<Object>(child) {\n            @Override\n            public void onCompleted() {\n                Observable.just(1).subscribe(child);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                child.onError(e);\n            }\n\n            @Override\n            public void onNext(Object t) {\n                // ignore data\n            }\n        };\n    }\n});\n```\n",
        "I'm okay with that restriction because if someone wanted to use the `continueWith` (I like `switchEmpty` more) but wanted to ensure the error doesn't happen then they can compose it with `ignoreElements`.\n",
        "@tonypiazza, I believe @roman-mazur is right.  By adding the concatEmptyWith and mergeEmptyWith to Observable we'll give the operators that RxNetty needs to allow @tonypiazza to return `Observable<JsonDocument>`.\n",
        "More like `return asyncBucket.remove(doc).ignoreElements();`\n",
        "I don't think `VoidObservable` will work very well due to how generics behave. I can't see how it would make `concatWith` behave any better.\n\nI think something like `continueWith` would work better, which by contract is saying that it ignores the generics of the previous stream and continues with the next stream onCompletion of the previous.\n\n``` java\nObservable<Void> someStream ...\nObservable<T> otherStream ...\nObservable<T> combined = someStream.continueWith(otherStream);\n```\n\nThis achieves the goal of ignoring output (a 'Void' or `ignoreElements()`), ignoring the type (such as via `cast(Class.class)`, and concatting when `onComplete` emits while also emitting `onError`.\n",
        "Yes, it would behave like `single()` which emits an error if it emits an `onNext`.\n",
        "Based on hallway discussions about this, we considered renaming for clarity to `concatEmptyWith` and `mergeEmptyWith` so we clearly describe the `concat` and `merge` cases. \n\nDo you still prefer `continueWith` and `mergeError`?\n",
        "@akarnokd @abersnaze Thanks for your comments, let me answer them one at a time.\n\n> > > I see two problems:\n\nYou are absolutely correct in identifying these issues & I should have clarified my intent better. What I was intending to is to introduce a class like:\n\n``` java\npublic class VoidObservable extends Observable<Void> {\n\n    protected VoidObservable(OnSubscribe<Void> f) {\n        super(f);\n    }\n\n    public <T> Observable<T> continueWith(Observable<T> next) {\n        final Observable<T> cast = unsafeCast();\n        return cast.concatWith(next);\n    }\n\n    public <T> Observable<T> mergeErrorWith(Observable<T> next) {\n        final Observable<T> cast = unsafeCast();\n        return cast.mergeWith(next);\n    }\n\n    private <T> Observable<T> unsafeCast() {\n        @SuppressWarnings(\"rawtypes\")\n        final Observable rawSource = this;\n        @SuppressWarnings(\"unchecked\")\n        final Observable<T> cast = rawSource;\n        return cast;\n    }\n}\n```\n\nand add any other methods specific to `VoidObservable`. This is basically clarifying the intent of the operation better than `.cast().XWith()`.\n\nDo you see this working or making sense?\n\n> > > I took a crack at changing RxNetty to use Observable<?> \n\nCan you elaborate more i.e. were you trying to make RxNetty's `Connection.write()` return `Observable<?>` ?\n",
        "@abersnaze I agree with you on why `<?>` _could_ be better in terms of indicating that the subscriber should not care about the type, although in this context, wouldn't it have the same problem? If you keep aside the RxNetty connection and look at this simple case,\n\n``` java\n        Observable<?> source = Observable.just(\"Hi\");\n        source.concatWith(Observable.just(1));\n```\n\nThe above isn't valid as `Observable<?>` can not be concatenated with `Observable<Integer>` in this case. So, you will have to do:\n\n``` java\n        Observable<?> source = Observable.just(\"Hi\");\n        source.cast(Integer.class).concatWith(Observable.just(1));\n```\n\nwhich is the same thing as `Observable<Void>`, correct?\n",
        "Sure, I think the point here is whether using `<?>` is any better than `<Void>`, I do not really see a difference in terms of applying any higher order functions on the `Observable`, which is the context for this discussion.\n\nNow, if I take out `<?>` argument, I think the problem still is similar i.e. how to make the use case of `continueWith` and `mergeErrorWith`, I outlined above, more palatable to the users. Whether the actual implementation of `continueWith` is `.cast().concatWith()` or a specific operator like @abersnaze mentioned can be discussed later.\n",
        "I see, so what you are saying is add `.continueWith` and possible `mergeError` in `Observable` instead of creating an extension like `VoidObservable`. \n\nThe only ambiguity will be, what if, someone uses it with a non-void `Observable`? We can possibly do something like: raising an error if the first stream emits any element.\n\nI am fine with either approaches, if and when we have a consensus here, I can submit a PR for this change!\n",
        "I updated the code In the PR to have the methods as concatEmptyWith and mergeEmptyWith but did not update the title of the PR. \n",
        "> > So am I correct that the introduction of concatEmptyWith and mergeEmptyWith would allow me to do the following instead?\n\nThese new operators are intended to be used on an empty `Observable` i.e. the one that never emits an item. Typically such an `Observable` is `Observable<Void>`. However, in your case, you are trying to apply these operators on an `Observable<JsonDocument>`, which will result in an error emitted by these operators. \n\nIf you want to change the type of an existing `Observable` that is **not** empty, the available `*map()` functions are the way to go as pointed by @roman-mazur \n",
        "As mentioned [in the PR](https://github.com/ReactiveX/RxJava/pull/3430#issuecomment-148786095), IMO, `Completable` is the correct abstraction for this.\n",
        "What do you think about this names? (I prefer not to force emptiness as commented here https://github.com/ReactiveX/RxJava/pull/3430)\n\n**then** similar to promises 'then', second merged after first completed\n\n``` java\nconnection.write(0x1234).cast(String.class).concatWith(connection.getInput())\nconnection.write(0x1234).then(connection.getInput())\n<V> Observable<V> then(Observable<V>> v1) { return ((Observable<V>) ignoreElements()).concatWith(v1); }\n```\n\n**flat** as flatMap but ignore elements, so nothing to map.\n\n``` java\nconnection.write(0x1234).cast(String.class).mergeWith(connection.getInput())\nconnection.write(0x1234).flat(connection.getInput())\n<V> Observable<V> flat(Observable<V> v1) { return ((Observable<V>) ignoreElements()).mergeWith(v1); }\n```\n\n**none** [as single but assert emptiness](https://github.com/ReactiveX/RxJava/pull/3430#issuecomment-148778876)\n\n~~*note: I think that concatWith is not working as expected in this talk because it subscribe to the first two elements (means, v1 is immediately subscribed), so you need to wrap the v1 into a defer().~~ I was wrong.\n",
        "After wrestling with the issue of how to convert `Observable<T>` into `Observable<Void>`, I settled on using the **compose** method. While not ideal in terms of communicating intent, it does solve the problem in a simple way:\n\n``` java\nreturn asyncBucket\n  .remove(doc)   // emits Observable<JsonDocument>\n  .compose(new Transformer<JsonDocument, Void>() {\n    @Override\n    public Observable<Void> call(Observable<JsonDocument> removed) {\n      return Observable.empty();\n    }\n});\n```\n",
        "@roman-mazur and @abersnaze Thanks for your replies. I stand corrected. I tested my earlier solution and discovered that the document was not actually getting removed. By changing the code to use **concatMap** as suggested by @roman-mazur, it now works as expected. Here is the updated code that works:\n\n``` java\nreturn asyncBucket\n  .remove(doc)   // emits Observable<JsonDocument>\n  .concatMap(new Func1<JsonDocument, Void>() {\n    @Override\n    public Observable<Void> call(Observable<JsonDocument> removed) {\n      return Observable.empty();\n    }\n});\n```\n\nSo am I correct that the introduction of **concatEmptyWith** and **mergeEmptyWith** would allow me to do the following instead?\n\n``` java\nreturn asyncBucket\n  .remove(doc)\n  .concatEmptyWith(Observable.<Void>empty());\n```\n\nLet me know if my understanding is incorrect.\n\nThanks to everyone for a very helpful discussion.\n",
        "@abersnaze The problem with **ignoreElements()** is that it doesn't change the return type. I want to return `Observable<Void>`. \n",
        "I see two problems:\n\n## Type inference limitations\n\nThe lack of cast-down type-inference in the Java language. For example: if I have an `Observable<Double> a` and an `Observable<Integer> b`, I can't use `mergeWith()` because it expects the parameter to extend the type of the source, which Double and Integer doesn't do to each other. You'd expect `c = a.mergeWith(b)` have a common supertype of `Observable<Number>` which type conversion can't be expressed in Java:\n\n``` java\ninterface IObservable<T> {\n    <U, R super T & U> IObservable<R> mergeWith(IObservable<U> other);\n}\n```\n\nHere, super is not allowed and gives a compiler error.\n\nIf I try to cheat this out via `extends` I have to add a second type parameter to the observable:\n\n``` java\ninterface IObservable<T extends R, R> {\n    void subscribe(Subscriber<R> child);\n    default <U extends R> IObservable<R, R> mergeWith(IObservable<U, R> other) {\n        return null;\n    }\n}\n```\n\nThis requires me to specify some common basetype so the merge can fall back onto it, however, it has limitations too:\n\n``` java\nIObservable<Double, Number> io1 = s -> {};\nIObservable<Integer, Number> io2 = s -> {};\nIObservable<Integer, Object> io3 = s -> {};\n\nio1.mergeWith(io2);\nio2.mergeWith(io1);\nio1.mergeWith(io3); // won't compile, incompatible types.\n```\n\nThe only thing that works is the static `merge`:\n\n``` java\nObservable<? extends Number> merge = Observable.merge(o1, o2);\n```\n\nBut still, it forces the user to have `? extends Number` carried everywhere. Rx.NET falls into this category so it seems to be a no-issue there and due to declaration-site variance, you don't have `super` and `extends` everywhere.\n\n## Operator methods are final\n\nEven if you have your own, fixed type observable, the following won't compile because our operator methods are final:\n\n``` java\npublic static final class VoidObservable extends Observable<Void> {\n\n    protected VoidObservable(OnSubscribe<Void> onSubscribe) {\n        super(onSubscribe);\n    }\n\n    public <T> Observable<T> mergeWith(Observable<T> other) {\n        return null;\n    }\n}\n```\n\nThe compiler will most likely complain about same-erasure non-overriding methods or just simply about override attempt of a final method. You'd have to name this method something else and remember to use it instead of the standard.\n",
        "> *note: I think that concatWith is not working as expected in this talk because it subscribe to the first two elements (means, v1 is immediately subscribed), so you need to wrap the v1 into a defer().\n\nNot sure what you mean by that. Concat has an internal buffer for two Observables but only subscribes to one of them. It requests 2 Observables from upstream and once the first completed, it requests another and also subscribes to the second Observable. In theory, this should establish a pipeline of Observables where there is one ready as soon as the previous one completes.\n",
        "Well, @tonypiazza, it seems to me that if your `asyncBucket.remove(doc)` is a cold observable, your operation will never be performed since nobody subscribes to this observable. Do I miss something?\nI used `concatMap { Observable.<Void>empty(); }` when I wanted to convert Observable<T> to Observable<Void>.\n"
    ],
    "3038": [
        "Yes we will want something to convert, such as `Single.from(Observable o)` or `Observable.toSingle()`.\n\nThe `toSingle()` method should behave similarly to `single()` except return a `Single`. \n\nAwkward, but all we can do during 1.x.\n\nIt would be great if you want to contribute this and start the design discussion. Note that public APIs contributions can often go through a lot of back and forth as we discuss them since we are stuck with them forever once we let them in.\n"
    ],
    "3263": [],
    "1240": [],
    "3918": [],
    "3428": [],
    "3301": [],
    "3587": [],
    "4434": [],
    "1413": [],
    "6676": [],
    "6488": [],
    "5928": [],
    "6853": [],
    "413": [],
    "3240": [],
    "3645": [],
    "3765": [],
    "3183": [],
    "4696": [],
    "5845": [],
    "3419": [],
    "4133": [],
    "6781": [],
    "5640": [],
    "3559": [],
    "703": [],
    "2990": [],
    "5940": [],
    "5997": [],
    "6780": [],
    "2567": [],
    "151": [],
    "531": [],
    "3243": [],
    "1345": [],
    "1504": [],
    "479": [],
    "1183": [],
    "6638": [],
    "416": [],
    "3124": [
        "DoOnTerminate won't be called if the observable is unsubscribed before the onCompleted/onError. Use doOnUnsubscribe if you need to always get a call back.\n",
        "@vleushin Is your issue resolved ? I am facing same issue . What is the drawback of using `merge` ? \n",
        "I just encountered this same thing. I want to zip together two `Observables` and do some simple logging on each when complete. You don't even need the `delay` to make this happen.\n\n```\n        Observable<Integer> nums = Observable.just(1, 2, 3, 4)\n                .doOnCompleted(() -> System.out.println(\"done with nums\"));\n        Observable<String> letters = Observable.just(\"a\", \"b\", \"c\", \"d\")\n                .doOnCompleted(() -> System.out.println(\"done with letters\")); // this won't appear\n\n        nums.zipWith(letters, (n, l) -> \"got \" + n + \" and \" + l)\n                .toBlocking()\n                .forEach(System.out::println);\n```\n\nI found this behavior to be very surprising. Could zip be changed to allow the source `Observables` to fully complete in the case where they are the same length?\n",
        "I felt back to merge:\n\n``` java\n        Observable.merge(\n                Observable.just(\"1\")\n                        .doOnTerminate(() -> System.out.println(\"TERMINATE 1\")),\n                Observable.just(\"2\")\n                        .delay(1, TimeUnit.SECONDS)\n                        .doOnTerminate(() -> System.out.println(\"TERMINATE 2\")))\n                .doOnTerminate(() ->\n                        System.out.println(\"TERMINATE\"))\n                .ignoreElements()\n                .singleOrDefault(null)\n                .toBlocking()\n                .single();\n```\n\n```\nTERMINATE 1\nTERMINATE 2\nTERMINATE\n```\n\nThis code looks strange to me. Please, advice how to properly run some observables in parallel and wait for them to finish. I can go with merge for now because I do not need observable results.\n",
        "I use merge. Drawback of merge is that it's hard to combine results, if you need them. If you don't need them (like in my case), you can be good with merge\n",
        "It is clear to me now. Thank you all for clarifications. I think we can close this issue.\n",
        "You can use `lastOrDefault` to shorten your codes, e.g., `o1.mergeWith(o2).toBlocking().lastOrDefault(null)`.\n",
        "Once the second delayed value runs the zip, it detects that the first source has terminated, completes and unsubscribes the second source. At this time, there is an onCompleted scheduled by the second source which due to the unsubscription won't be executed and you don't see the doOnTerminate called.\n",
        "I'd add `doOnUnsubscribe` so you can execute the cleanup action or simply use `using` that will execute the cleanup if the source completes normally or is cancelled.\n",
        "With collections over time, you can't know you are just before completion. The `zip` operator behaves correctly and you need a different operator, `doOnTerminate`+`doOnUnsubscribe` or `using`, to handle completion and unsubscription case together.\n",
        "See the proposed documentation changes in #3981.\n",
        "Why is this closed? I think the current zip behavior is incorrect.\nMy point is, if inner observables of zip emit the same number of items, then onCompleted (doOnCompleted, doOnTerminate etc.) should be called on each of them.\n",
        "That is what I'm talking about.\nWhy unsubscribe just before completion? An event is lost without a reason.\nAlso there is an obvious inconsistency: you have two identical inner observables, the first completes, then unsubscribes, the second one unsubscribes before completion, even though it was about to do so.\n",
        "@abersnaze doOnUnsubscribe can be an acceptable workaround, but what if I don't want it to trigger on error?\n\n@akarnokd Formally, `zip` behaves correctly, since it is not documented whether onCompletes (and so on) should be called on inner observables.\nThe fact is the behavior is unspecified and unpredictable. The problem is, I want to know exactly what does my code do.\n"
    ],
    "1085": [],
    "3333": [],
    "6057": [],
    "3224": [],
    "1371": [],
    "6866": [],
    "5932": [],
    "3790": [],
    "350": [],
    "2592": [],
    "337": [],
    "5441": [],
    "562": [],
    "3651": [],
    "109": [],
    "138": [],
    "222": [],
    "6": [],
    "617": [],
    "893": [],
    "180": [],
    "3582": [],
    "3255": [],
    "252": [],
    "1237": [],
    "4094": [],
    "5991": [],
    "6506": [],
    "4526": [],
    "2939": [],
    "396": [],
    "1493": [],
    "1456": [],
    "3384": [],
    "5729": [],
    "247": [],
    "6066": [],
    "232": [],
    "3233": [
        "I've got this almost ready, I need some polishing but will be pushing a PR today/tomorrow the latest.\n",
        "+1 Also have an Action0 option to be informed when dropping is occuring.\n"
    ],
    "6864": [],
    "6879": [],
    "3890": [],
    "1498": [],
    "3331": [],
    "5147": [],
    "4461": [],
    "463": [],
    "3264": [],
    "3254": [],
    "4745": [],
    "3230": [],
    "160": [],
    "4899": [],
    "1586": [],
    "343": [],
    "1495": [],
    "5156": [],
    "4251": [],
    "1284": [],
    "1712": [],
    "884": [],
    "4678": [],
    "3883": [],
    "1119": [],
    "6806": [],
    "4716": [],
    "4063": [],
    "1210": [],
    "6516": [],
    "3174": [],
    "909": [],
    "1062": [],
    "6077": [],
    "4395": [],
    "363": [],
    "3841": [],
    "1947": [],
    "2641": [],
    "6620": [],
    "5117": [],
    "4181": [],
    "3172": [],
    "4099": [],
    "3346": [
        "Thanks for the response! I think alternatively you could do:\n\n``` java\nif (!isUnsubscribed() && (count++ < limit)) {\n    boolean stop = count >= limit;\n    child.onNext(i);\n    if (stop && !completed) {\n        completed = true;\n        try {\n            child.onCompleted();\n        } finally {\n            unsubscribe();\n        }\n    }\n}\n```\n\nWhich only changes the outer conditional and the computation of `stop`. LMK if that sounds good and I'll prepare a PR?\n",
        "Hi and thanks for discovering this. The behavior is not intentional. We are generally not prepared for synchronous reentry such as this. Solving it is a bit tricky because a delicate behavior needs to be ensured right at the limit. Here is how I'd fix this:\n- I'd introduce a `boolean stop` variable on the parent Subscriber\n- I'd change the onNext to have the reentrancy protection:\n\n``` java\n@Override\npublic void onNext(T i) {\n    if (!isUnsubscribed()) {\n        boolean stop = ++count >= limit;\n        if (stop) {\n            if (this.stop) {\n                return;\n            }\n            this.stop = true;\n        }\n        child.onNext(i);\n        if (stop && !completed) {\n            completed = true;\n            try {\n                child.onCompleted();\n            } finally {\n                unsubscribe();\n            }\n        }\n    }\n}\n```\n\nThis will prevent a recursive onNext call to be delivered after the limit.\n",
        "Looks even better, go ahead with the PR.\n",
        "@mgp Are you going to post a PR against 1.x?\n",
        "Closing via #3384.\n"
    ],
    "4184": [],
    "3783": [],
    "3271": [],
    "5713": [],
    "945": [],
    "470": [],
    "1200": [],
    "1064": [],
    "6254": [],
    "966": [],
    "322": [],
    "6241": [],
    "3868": [],
    "3493": [],
    "4309": [],
    "3550": [],
    "5075": [],
    "1545": [],
    "3458": [],
    "4988": [],
    "1093": [],
    "3938": [],
    "6031": [],
    "1388": [],
    "1261": [],
    "5262": [],
    "382": [],
    "4508": [],
    "1080": [],
    "1518": [],
    "3437": [],
    "3707": [],
    "1075": [],
    "447": [],
    "4990": [],
    "2475": [],
    "6548": [],
    "4877": [],
    "6586": [],
    "1722": [],
    "1552": [],
    "557": [],
    "3198": [],
    "1716": [],
    "3459": [
        "I too have seen this issue occurring randomly. In my case it was happening while using `HystrixCollapser` inside map/flatMap operator. On debugging I found that `onCompleted` was being called on the observable before `onNext`. I was not able to isolate if it was due to rx operator or Hystrix.\n\n@yyfrankyy What is scenario in your use-case? Can you share your flow of composition ?\n",
        "Hi, \nthere is still a reference to `AtomicIntegerFieldUpdater` here:\n\nhttps://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/schedulers/CachedThreadScheduler.java#L180\n\nAny chance to have it fixed in the 1.x branch?\n\nThanks,\nRocco\n",
        "@akarnokd I can definitely give it a try.\n\nI forked the project and imported into Eclipse, but I have some troubles with the unit tests, because there are some failures and I'm not so confident in doing changes without the help of a robust existing test suites. I use RxJava since a while but I'm definitely not into the internals.\n\nNot sure if it's something misconfigured on my side (I followed the instructions in the \"How to contribute\" wiki page), but I can send you the JUnit xml output if needed. Can you please verify if the 1.x branch tests are working on your side?\n",
        "ProGuard detects and keeps fields used by `AtomicFieldUpdater` since v4.6 (release happened 4 years ago), maybe @yyfrankyy uses another code obfuscator?\n",
        "IDK, but I see 2 possible reasons:\n1. Samsung: probably, they've patched the Runtime (they like to change everything in Android) and it tries to minify fields names for less memory usage (though I don't think that they're really doing such things, but, who knows).\n2. ProGuard rules problem or ProGuard bug or Android Gradle Plugin bug when you're doing non-clean builds (though it'll break app on other devices too).\n\n@yyfrankyy can you please wrap the `subscribe()` call into `try-catch` and then collect info about the fields of the `BooleanSubscription` class, it'll help us detect the problem.\n\n``` java\ntry {\n  obs.subscribe(...);\n} catch (NoSuchFieldException e) {\n  // collect info about fields of the BooleanSubscription class\n  BooleanSubscription.class.getDeclaredFields(); // include it into the crash report\n}\n```\n\nAlso, recently I've shipped ProGuard rules for RxJava as aar https://github.com/artem-zinnatullin/RxJavaProGuardRules, you can try to use them instead of yours.\n",
        "It's definitely not pro-guard, since the decompiled class code looks correct.  I can also try to capture the fields in the class (thank you for the suggestion), but since I haven't reproduced the issue myself it'll take a week before I have that data.  In the mean time, I think I'll just replace Atomic_FieldUpdater with Atomic_ objects, since I confirmed that it works.\n",
        "Hi. Do you use ProGuard by any chance? I'm not an expert on it but you might need to change the field retention policy.\n",
        "Fix delivered, all AtomicXFieldUpdater changed to AtomicX classes.\n",
        "@roccozanni Would you be interested in fixing it?\n",
        "We have CI associated with the project and all the current tests pass both locally and on Travis. After you imported the project, go to the Eclipse preferences, look for Compiler warnings and set the restricted access to ignore. You should also install the Gradle IDE plugin to make sure all test dependencies are wired up properly.\n",
        "So those Android devices have `Unsafe`?\n\nI wonder if the `addressOf` might be triggering the bug in the runtime by hiding the `getDeclaredField` call.\n",
        "If you could play with a manual build, inlining the `addressOf` in `rx.internal.util.unsafe.SpmcArrayQueueProducerField` and `rx.internal.util.unsafe.SpmcArrayQueueConsumerField` could rule out that sort of bug.\n\nIn the meantime, I'll try to have a System property driven way of disabling `Unsafe` use in a PR.\n",
        "See #3979.\n",
        "@akarnokd @artem-zinnatullin we do use proguard, but keep all the staff that rx needs by `-keep class rx.** { * ; }`\n\n@amitcse It crashed at the very beginning since the `Application#onCreate()`, code is here:\n\nhttps://github.com/WeTeX/Watchers/blob/master/src/main/java/com/github/QQMail/Watchers.java#L244\n\nAnd here are some use cases, it works quite well at most of the time.\n\nhttps://github.com/WeTeX/Watchers/blob/master/src/test/java/com/github/QQMail/WatchersTest.java\n\nI grep all the crashes related to `NoSuchFieldException: unsubscribed`, all the crashes came from \n- **SM-G900I;Android 5.0,level 21**\n- **SM-G9006V;Android 5.0,level 21**\n\nSome of the crashes look like this, from these two devices. they look so similar..\n- **GT-I9507V;Android 5.0.1,level 21**\n- **GT-I9500;Android 5.0.1,level 21**\n\n```\njava.lang.NoSuchFieldException: requested\njava.lang.Class.getDeclaredField(Class.java:929)\njava.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.<init>(AtomicLongFieldUpdater.java:251)\njava.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java:50)\nrx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.<clinit>(SourceFile:86)\nrx.internal.operators.OperatorObserveOn.rx.Subscriber call(rx.Subscriber)(SourceFile:64)\nrx.internal.operators.OperatorObserveOn.java.lang.Object call(java.lang.Object)(SourceFile:44)\n```\n",
        "@artem-zinnatullin Sure, we can do this on our next release next month, will come back later.\n",
        "1000+ crashes past few days in New York Times app.  Hoping for @markrietveld fix to be merged soon.  We are reaching out to Samsung as well to find out exactly what happened on their end.\n\n```\nPackage: com.nytimes.android\nVersion Code: 9486\nVersion Name: 5.9.2\nAndroid: 5.0.2\nManufacturer: samsung\nModel: SM-T805Y\nDate: Mon Oct 26 06:31:34 AEDT 2015\n\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\n    at rx.internal.schedulers.ScheduledAction.run(SourceFile:62)\n    at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(SourceFile:98)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:818)\nCaused by: java.lang.ExceptionInInitializerError\n    at rx.internal.operators.OperatorZip.call(SourceFile:113)\n    at rx.internal.operators.OperatorZip.call(SourceFile:58)\n    at rx.Observable$2.call(SourceFile:158)\n    at rx.Observable$2.call(SourceFile:154)\n    at rx.Observable.subscribe(SourceFile:7804)\n    at rx.Observable.subscribe(SourceFile:7772)\n    at com.nytimes.android.notification.DailyRichNotificationHelper.displayDailyRichNotification(SourceFile:108)\n    at com.nytimes.android.notification.DailyRichNotificationHelper.displayDailyRichNotification(SourceFile:99)\n    at com.nytimes.android.notification.DailyRichNotificationHelper$1.call(SourceFile:86)\n    at com.nytimes.android.notification.DailyRichNotificationHelper$1.call(SourceFile:83)\n    at rx.Observable$28.onNext(SourceFile:7588)\n    at rx.observers.SafeSubscriber.onNext(SourceFile:130)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(SourceFile:364)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(SourceFile:326)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(SourceFile:802)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(SourceFile:84)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SourceFile:224)\n    at rx.internal.operators.NotificationLite.accept(SourceFile:150)\n    at rx.subjects.ReplaySubject$UnboundedReplayState.accept(SourceFile:466)\n    at rx.subjects.ReplaySubject$UnboundedReplayState.replayObserverFromIndex(SourceFile:515)\n    at rx.subjects.ReplaySubject$UnboundedReplayState.replayObserver(SourceFile:503)\n    at rx.subjects.ReplaySubject.caughtUp(SourceFile:423)\n    at rx.subjects.ReplaySubject.onNext(SourceFile:369)\n    at rx.Observable$30.onNext(SourceFile:7681)\n    at rx.observers.SafeSubscriber.onNext(SourceFile:130)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(SourceFile:84)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(SourceFile:364)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(SourceFile:326)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(SourceFile:802)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.emitScalar(SourceFile:364)\n    at rx.internal.operators.OperatorMerge$MergeSubscriber.tryEmit(SourceFile:326)\n    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(SourceFile:802)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SourceFile:224)\n    at rx.subjects.AsyncSubject.onCompleted(SourceFile:101)\n    at rx.util.async.Async$1$1.call(SourceFile:533)\n    at rx.internal.schedulers.ScheduledAction.run(SourceFile:55)\n    ... 4 more\nCaused by: java.lang.RuntimeException: java.lang.NoSuchFieldException: counter\n    at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.<init>(AtomicLongFieldUpdater.java:269)\n    at java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java:50)\n    at rx.internal.operators.OperatorZip$Zip.<clinit>(SourceFile:187)\n    ... 40 more\nCaused by: java.lang.NoSuchFieldException: counter\n    at java.lang.Class.getDeclaredField(Class.java:929)\n    at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.<init>(AtomicLongFieldUpdater.java:251)\n    ... 42 more\n```\n",
        "I'm still having this following issue\n\n```\njava.lang.IllegalArgumentException: Must be integer type\n\nat java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.<init>(AtomicIntegerFieldUpdater.java:275)\nat java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java:49)\nat rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker\n\n```\n\nShould we replace the AtomicIntegerFieldUpdater on the class CachedThreadScheduler as well ?\n",
        "Same android samsung 5.0.X appeared for us with the latest 1.1.2\n\n> Caused by java.lang.NoSuchFieldException: producerIndex\n>        at java.lang.Class.getDeclaredField(Class.java:929)\n>        at rx.internal.util.unsafe.UnsafeAccess.addressOf(UnsafeAccess.java:100)\n>        at rx.internal.util.unsafe.SpmcArrayQueueProducerField.<clinit>(SpmcArrayQueue.java:31)\n>        at rx.internal.util.RxRingBuffer$2.createObject(RxRingBuffer.java:294)\n>        at rx.internal.util.RxRingBuffer$2.createObject(RxRingBuffer.java:290)\n>        at rx.internal.util.ObjectPool.borrowObject(ObjectPool.java:74)\n>        at rx.internal.util.RxRingBuffer.<init>(RxRingBuffer.java:307)\n>        at rx.internal.util.RxRingBuffer.getSpmcInstance(RxRingBuffer.java:45)\n>        at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.<init>(OperatorZip.java:305)\n>        at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:205)\n>        at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)\n>        at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)\n>        ...\n",
        "I was thinking that too but I've checked and the implementation has not changed recently and we started seeing the errors just with the latest version. Pretty weird stuff...\n",
        "Hi,\nI have the same issues. All only on Samsung devices with Android 5\n\n1:\n....\nCaused by java.lang.NoSuchFieldException: producerIndex\n       at java.lang.Class.getDeclaredField(Class.java)\n       at rx.internal.util.unsafe.UnsafeAccess.addressOf(SourceFile)\n       at rx.internal.util.unsafe.SpmcArrayQueueProducerField.(SourceFile)\n       at rx.internal.util.RxRingBuffer$2.createObject(SourceFile)\n       at rx.internal.util.ObjectPool.borrowObject(SourceFile)\n       at rx.internal.util.RxRingBuffer.(SourceFile)\n       at rx.internal.util.RxRingBuffer.getSpmcInstance(SourceFile)\n       at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.(SourceFile)\n       at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile)\n       at rx.Observable.unsafeSubscribe(SourceFile)\n       at rx.internal.operators.OperatorSubscribeOn$1$1.call(SourceFile)\n       at rx.internal.schedulers.ScheduledAction.run(SourceFile)\n       at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(SourceFile)\n       ...\n\n2:\n...\nCaused by java.lang.NoSuchFieldException: do\n       at java.lang.Class.getDeclaredField(Class.java)\n       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.(AtomicIntegerFieldUpdater.java)\n       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java)\n       at rx.subscriptions.BooleanSubscription.(SourceFile)\n       at rx.subscriptions.Subscriptions.create(SourceFile)\n       at rx.subjects.SubjectSubscriptionManager.addUnsubscriber(SourceFile)\n       at rx.Observable.subscribe(SourceFile)\n       at rx.Observable.subscribe(SourceFile)\n       ...\n\n3:\n...\nCaused by java.lang.NoSuchFieldException: this\n       at java.lang.Class.getDeclaredField(Class.java)\n       at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.(AtomicLongFieldUpdater.java)\n       at java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java)\n       at rx.internal.operators.OnSubscribeCombineLatest$MultiSourceProducer.(SourceFile)\n       at rx.internal.operators.OnSubscribeCombineLatest.call(SourceFile)\n       at rx.Observable.unsafeSubscribe(SourceFile)\n       at rx.internal.operators.OperatorSubscribeOn$1$1.call(SourceFile)\n       at rx.internal.schedulers.ScheduledAction.run(SourceFile)\n       at rx.schedulers.ExecutorScheduler$ExecutorSchedulerWorker.run(SourceFile)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java)\n       at java.lang.Thread.run(Thread.java)\n\n4:\n...\nCaused by java.lang.NoSuchFieldException: do\n       at java.lang.Class.getDeclaredField(Class.java)\n       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.(AtomicIntegerFieldUpdater.java)\n       at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java)\n       at rx.schedulers.CachedThreadScheduler$EventLoopWorker.(SourceFile)\n       at rx.schedulers.CachedThreadScheduler.createWorker(SourceFile)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.(SourceFile)\n       at rx.internal.operators.OperatorObserveOn.call(SourceFile)\n       at rx.Observable$2.call(SourceFile)\n       at rx.Observable.subscribe(SourceFile)\n       at rx.Observable.subscribe(SourceFile)\n       ...\n\n5:\n...\nCaused by java.lang.NoSuchFieldException: case\n       at java.lang.Class.getDeclaredField(Class.java)\n       at java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater.(AtomicLongFieldUpdater.java)\n       at java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater(AtomicLongFieldUpdater.java)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.(SourceFile)\n       at rx.internal.operators.OperatorObserveOn.call(SourceFile)\n       at rx.Observable$2.call(SourceFile)\n       at rx.Observable.subscribe(SourceFile)\n       at rx.Observable.subscribe(SourceFile)\n       ....\n\nLooks like Samsung introduce some specific problem on Android 5.\n\nDo you plan to apply a workaround for that? \n"
    ],
    "1307": [],
    "2559": [],
    "5910": [],
    "4904": [],
    "6631": [],
    "1778": [],
    "3202": [],
    "1796": [],
    "1269": [],
    "2779": [],
    "3011": [],
    "833": [],
    "4957": [],
    "6812": [],
    "6215": [],
    "3492": [
        "Hello and thanks for the in-depth analysis. What happens is that the child is caputed by `ZipSubscriber` and when it receives its `Producer` from `toList`, that also gets forwarded to child which overwrites the `ZipProducer` and thus no further requests get accounted. The fix is posted in #3493\n\nOrdered merging comes up from time to time on StackOverflow; you can post a PR for it but frankly, if Netflix doesn't need one urgently, it can take a long time to get it approved.\n",
        "Yes. I've fixed like dozens of such bugs before; it is a design shortcoming of `Subscriber`.\n",
        "I [have one](https://gist.github.com/akarnokd/c86a89738199bbb37348) that supports backpressure but without unit tests.\n",
        "No plans, go ahead.\n",
        "Fix delivered with 1.0.16. The discussion about sorted merge can continue in a different thread if you wish.\n",
        "Thanks. That's pretty much what I suspected.\n\nSo if I understand correctly, your solution was to disconnect the child from the backpressure chain, but add the `ZipSubscriber` to its subscription list so it'll know whether the downstream is subscribed.\n",
        "@davidmoten I looked at your implementation before going forward with my own. There were a few details in the implementation that I couldn't figure out, plus the lack of backpressure support was a complete deal breaker in my case. That's why I modified the Zip operator to fit my needs. Its functionality is almost identical.\n\nSo now I have one of those operators too, and the only test that failed for it (erm... so far) was a test that failed for the original Zip as well (hence this issue). I might put it on github sometime later.\n",
        "@MaltAlex re your sorted merge operator. You can find one at [rxjava-extras](https://github.com/davidmoten/rxjava-extras) as well (`Transformers.orderedMergeWith`) with almost complete test coverage (for what that's worth). Even if you don't use it the testing strategy might be useful to you:\n- test ordered merge of all pairs of sorted sets taken from a Power Set of numbers from 1..n, perform for n=0 to 10\n- do the above synchronously and asynchronously\n\nThe operator I made requires backpressure supporting sources but does not support backpressure itself and would be combined with `.onBackpressureXXX`.\n\nI think @akarnokd has one of these floating around as well but I don't know if it has unit tests.\n",
        "I'll have a look at your SortedMerge @akarnokd and beef up unit tests\n(there were some with your gist)\n\nOn 5 November 2015 at 18:59, David Karnok notifications@github.com wrote:\n\n> I have one https://gist.github.com/akarnokd/c86a89738199bbb37348 that\n> supports backpressure but without unit tests.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/ReactiveX/RxJava/issues/3492#issuecomment-153981952.\n",
        "would be good to see your implementation @MaltAlex. Operators are complex and are hard to test due to async possibilities but I'll chuck the best candidate in a _rxjava-extras_ release. The candidate from @akarnokd will have a good chance of winning out because he knows this domain so well!\n",
        "The implementation from @akarnokd passes my power set tests. Do you have any plans for it @akarnokd? Do you mind if I throw it in to _rxjava-extras_ (I'd make clear your authorship in the source)?\n"
    ],
    "1333": [],
    "841": [],
    "1575": [],
    "1711": [],
    "5677": [],
    "6706": [],
    "6775": [],
    "6549": [],
    "1950": [],
    "2759": [],
    "6762": [],
    "1637": [],
    "3369": [],
    "6421": [],
    "3693": [],
    "736": [],
    "6113": [],
    "5802": [],
    "6220": [],
    "3523": [
        "Fix in #3524 merged.\n"
    ],
    "958": [],
    "5422": [],
    "1397": [],
    "4597": [],
    "1767": [],
    "4304": [],
    "690": [],
    "1639": [],
    "2482": [],
    "407": [],
    "1705": [],
    "1182": [],
    "3305": [],
    "6084": [],
    "2923": [],
    "6884": [],
    "3555": [
        "Hi. This is an oversight on our part. Fix in #3556.\n",
        "Wow, that was quick. :+1: \n\nThanks very much.\n"
    ],
    "1786": [],
    "6601": [],
    "1021": [],
    "2763": [],
    "1924": [],
    "587": [],
    "6598": [],
    "3576": [
        "PRs are welcome!\n",
        "See #3974 \n",
        "If I have understood things correctly, I'd be happy to submit a PR clarifying the JavaDoc.\n"
    ],
    "480": [],
    "593": [],
    "264": [],
    "4122": [],
    "5378": [],
    "4383": [],
    "3030": [],
    "4146": [],
    "3430": [],
    "4901": [],
    "3273": [],
    "5271": [],
    "6760": [],
    "874": [],
    "2995": [],
    "1332": [],
    "4955": [],
    "730": [],
    "3575": [],
    "4767": [],
    "3618": [
        "Closing via #3623\n"
    ],
    "3433": [],
    "4023": [],
    "4142": [],
    "3048": [],
    "5020": [],
    "478": [],
    "4761": [],
    "3012": [],
    "4706": [],
    "4253": [],
    "4302": [],
    "925": [],
    "2823": [],
    "4436": [],
    "4592": [],
    "6128": [],
    "6797": [],
    "5080": [],
    "3478": [],
    "3504": [],
    "4873": [],
    "4425": [],
    "1197": [],
    "1612": [],
    "3669": [
        "Fixed and merged\n"
    ],
    "1752": [],
    "1468": [],
    "1358": [],
    "6096": [],
    "6662": [],
    "6612": [],
    "2892": [],
    "3913": [],
    "3679": [
        "Closing via #3977\n",
        "I see this issue too. When I see logs via crashlytics the stacktrace just shows the composite exception but not the details of the actual crash in `onError()`. I see there's a bug in `CompositeException.java`. Fixing in a new PR\n",
        "You shoudn't throw from `Observer.onError` or `Subscriber.onError` but there are safeguards which have to wrap exceptions and deliver it somewhere upstream.\n",
        "> You shoudn't throw from Observer.onError or Subscriber.onError but there are safeguards which have to wrap exceptions and deliver it somewhere upstream.\n\nThis is just an example to illustrate the problem, my point was not that there shouldn't be exception, my point is that the cause exception that `OnErrorFailedException` wraps is the wrong exception and not the cause.\n\nInstead the log is of an exception which is already handled. This is confusing and can take a lot of time to understand and to find the actual cause.\n\nFor example, in my app there is a rare bug somewhere inside my `onError` handler, which causes an exception, but I don't know which line inside my handler throws or what exception it throws because I do not see the actual stack trace. Instead I see the error that caused the `onError` to be invoked.\n\nIf you run the same example above with the `retryWhen` removed, you get the correct exception (note **IllegalStateException** is at the bottom of the stack trace, while in the first stack trace above the already-handled **UnsupportedOperationException** is at the bottom of the stack trace):\n\n```\nrx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71)\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.subscribe(Observable.java:8191)\n    at rx.Observable.subscribe(Observable.java:8158)\n    at com.example.mydemoapp.MainActivity.testRetryError(MainActivity.java:65)\n    at com.example.mydemoapp.MainActivity.onOptionsItemSelected(MainActivity.java:53)\n    at android.app.Activity.onMenuItemSelected(Activity.java:2908)\n    at android.support.v4.app.FragmentActivity.onMenuItemSelected(FragmentActivity.java:361)\n    at android.support.v7.app.AppCompatActivity.onMenuItemSelected(AppCompatActivity.java:147)\n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)\n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)\n    at android.support.v7.app.ToolbarActionBar$2.onMenuItemClick(ToolbarActionBar.java:68)\n    at android.support.v7.widget.Toolbar$1.onMenuItemClick(Toolbar.java:172)\n    at android.support.v7.widget.ActionMenuView$MenuBuilderCallback.onMenuItemSelected(ActionMenuView.java:760)\n    at android.support.v7.view.menu.MenuBuilder.dispatchMenuItemSelected(MenuBuilder.java:811)\n    at android.support.v7.view.menu.MenuItemImpl.invoke(MenuItemImpl.java:152)\n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:958)\n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:948)\n    at android.support.v7.view.menu.MenuPopupHelper.onItemClick(MenuPopupHelper.java:191)\n    at android.widget.AdapterView.performItemClick(AdapterView.java:310)\n    at android.widget.AbsListView.performItemClick(AbsListView.java:1145)\n    at android.widget.AbsListView$PerformClick.run(AbsListView.java:3042)\n    at android.widget.AbsListView$3.run(AbsListView.java:3879)\n    at android.os.Handler.handleCallback(Handler.java:739)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:148)\n    at android.app.ActivityThread.main(ActivityThread.java:5417)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. \n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:194)\u00a0\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)\u00a0\n    at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:71)\u00a0\n    at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:187)\u00a0\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:82)\u00a0\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\u00a0\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\u00a0\n    at rx.Observable$2.call(Observable.java:162)\u00a0\n    at rx.Observable$2.call(Observable.java:154)\u00a0\n    at rx.Observable.subscribe(Observable.java:8191)\u00a0\n    at rx.Observable.subscribe(Observable.java:8158)\u00a0\n    at com.example.mydemoapp.MainActivity.testRetryError(MainActivity.java:65)\u00a0\n    at com.example.mydemoapp.MainActivity.onOptionsItemSelected(MainActivity.java:53)\u00a0\n    at android.app.Activity.onMenuItemSelected(Activity.java:2908)\u00a0\n    at android.support.v4.app.FragmentActivity.onMenuItemSelected(FragmentActivity.java:361)\u00a0\n    at android.support.v7.app.AppCompatActivity.onMenuItemSelected(AppCompatActivity.java:147)\u00a0\n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)\u00a0\n    at android.support.v7.view.WindowCallbackWrapper.onMenuItemSelected(WindowCallbackWrapper.java:100)\u00a0\n    at android.support.v7.app.ToolbarActionBar$2.onMenuItemClick(ToolbarActionBar.java:68)\u00a0\n    at android.support.v7.widget.Toolbar$1.onMenuItemClick(Toolbar.java:172)\u00a0\n    at android.support.v7.widget.ActionMenuView$MenuBuilderCallback.onMenuItemSelected(ActionMenuView.java:760)\u00a0\n    at android.support.v7.view.menu.MenuBuilder.dispatchMenuItemSelected(MenuBuilder.java:811)\u00a0\n    at android.support.v7.view.menu.MenuItemImpl.invoke(MenuItemImpl.java:152)\u00a0\n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:958)\u00a0\n    at android.support.v7.view.menu.MenuBuilder.performItemAction(MenuBuilder.java:948)\u00a0\n    at android.support.v7.view.menu.MenuPopupHelper.onItemClick(MenuPopupHelper.java:191)\u00a0\n    at android.widget.AdapterView.performItemClick(AdapterView.java:310)\u00a0\n    at android.widget.AbsListView.performItemClick(AbsListView.java:1145)\u00a0\n    at android.widget.AbsListView$PerformClick.run(AbsListView.java:3042)\u00a0\n    at android.widget.AbsListView$3.run(AbsListView.java:3879)\u00a0\n    at android.os.Handler.handleCallback(Handler.java:739)\u00a0\n    at android.os.Handler.dispatchMessage(Handler.java:95)\u00a0\n    at android.os.Looper.loop(Looper.java:148)\u00a0\n    at android.app.ActivityThread.main(ActivityThread.java:5417)\u00a0\n    at java.lang.reflect.Method.invoke(Native Method)\u00a0\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\u00a0\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\u00a0\n Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>\n    at android.util.Log.getStackTraceString(Log.java:338)\n    at com.android.internal.os.RuntimeInit.Clog_e(RuntimeInit.java:61)\n    at com.android.internal.os.RuntimeInit.-wrap0(RuntimeInit.java)\n    at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:86)\n    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)\n    at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)\n Caused by: java.lang.IllegalStateException: doOnNextException\n    at com.example.mydemoapp.MainActivity$3.call(MainActivity.java:63)\n    at com.example.mydemoapp.MainActivity$3.call(MainActivity.java:61)\n    at rx.Observable$11.onNext(Observable.java:4445)\n    at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:80)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n at rx.Observable$2.call\n```\n",
        "Simpler way to reproduce is to just throw within a `doOnError()` - the exception that is thrown is swallowed and is not part of the causal chain.\n\n```\n    Observable.just(1).doOnNext(new Action1<Integer>() {\n        @Override public void call(Integer val) {\n            throw new IllegalStateException(\"doOnNextException\");\n        }\n    }).doOnError(new Action1<Throwable>() {\n                @Override public void call(Throwable throwable) {\n                    throw new UnsupportedOperationException(\"onError exception\");\n                }\n    }).subscribe(new Subscriber<Integer>() {\n        @Override public void onCompleted() {\n            Log.v(\"EX\", \"onCompleted\");\n        }\n\n        @Override public void onError(Throwable e) {\n            Log.v(\"EX\", \"onError\");\n            throw new IllegalThreadStateException();\n        }\n\n        @Override public void onNext(Integer integer) {\n            Log.v(\"EX\", \"onNext\");\n        }\n    });\n```\n"
    ],
    "4945": [],
    "761": [],
    "6370": [],
    "3568": [],
    "3079": [],
    "6570": [],
    "411": [],
    "4043": [],
    "1569": [],
    "2052": [],
    "3698": [
        "I've pushed a Failing test case on a fork of the 1.0.17 release, along with a simple fix for it that passes the test cases on that branch, should there ever be a 1.0.18 release.\nI've also cherry-picked the tests onto 1.x (where they all pass) as a regression test; I'm not sure if cherry-picking is an acceptable practice on the ReactiveX repos - let me know if you'd rather I merge it or something.\n",
        "The test has been merged in #3699. I don't think versions of the pattern 1.0.x will be updated any further. We will only support 1.x and 2.x together.\n"
    ],
    "3110": [],
    "3700": [
        "Sure.\n"
    ],
    "4939": [],
    "3509": [],
    "6263": [],
    "5967": [],
    "4972": [],
    "5786": [],
    "4437": [],
    "3108": [],
    "385": [],
    "4007": [],
    "2991": [],
    "3726": [
        "I do not want to wrap the `subscribe()` call in try-catch. Problem is that when I do not specify `onError` callback in `Completable.subscribe()` I do not expect the `Completable` to emit and error. But when the `Completable` emits an unexpected error, that is an programming error and shall be processed as such. The `OnErrorNotImplementedException` is then expected to e.g. crash the application.\n\nSimilar to https://github.com/ReactiveX/RxJava/issues/198 but for `Completable`\n\nThis should be the respective test for `Observable`:\nhttps://github.com/ReactiveX/RxJava/blob/1.x/src/test/java/rx/ObservableTests.java#L711\n",
        "Throwing like `Observable` relies on the expectation that the execution won't switch to other thread. This `OnErrorNotImplemented` is remnant of the imperative style of programming. Using try-catch around a sequence doesn't make sense and throwing upward has no guarantees either.\n",
        "PRs are welcome.\n",
        "You can replace/precede them with `Exceptions.throwIfFatal`.\n",
        "@akarnokd Throwing upward does have a crucial guarantee-- reaching the thread's uncaught exception handler.  \n\nDelivering to the plugin is effectively swallowing the exception, since it receives all exceptions and cannot safely propagate any of them anywhere.\n\nFailing to propagate exceptions was a huge problem (#1682) in scheduled actions before 1.0.\n",
        ":+1: Working on one now. Just going to deliver to the uncaught exception handler after the plugin, wherever it seems to make sense.\n",
        "@akarnokd Can you explain the usage of `toNpe()` in Completable, e.g. here?: https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Completable.java#L1946\n"
    ],
    "3455": [],
    "4048": [],
    "1751": [],
    "791": [],
    "845": [],
    "5250": [],
    "6483": [],
    "3751": [
        "I've hit this a number of times and generally ended up turning most .observeOn() into .onBackpressureBuffer().observeOn(), I guess the ability to control the 128 size buffer as an optional parameter to observeOn would be a nice addition.\n",
        "It seems your source doesn't emit enough values thus the default buffer of 128 elements in `observeOn` can hold all of it without backpressure. The `onBackpressureBuffer(int)` behavior is expected and is there to give room to bursty sources but fail on sustained backpressure to prompt the developer to reevaluate the flow.\n\nThere is a [PR](https://github.com/ReactiveX/RxJava/pull/3487) in limbo that tries to address this buffer behavior by allowing dropping, but if you want to queue on disk, you have to write a custom operator.\n",
        "@srvaroa PR welcome.\n",
        "I see.\n\nThe challenge with the PR above is that currently the overflow function does not supply the item(s) which caused the overflow. It is just a void action (`Action0`). Changing that to e.g. `Action1` would probably break the semantics of the original `onBackPressureBuffer()` API so I guess the naming would need to be reconsidered for a new API if it would accept a `Action1` type function.\n\nBased on @akarnokd's comment, we should not use the buffer backpressure but ideally it seems that the current implementation of `onBackpressureDrop(Action1<? super T> onDrop)` is close what I'm after here but I would need to be able to control the size of the default internal buffer (128 now). We can write a custom operator of course but I was just wondering would this be something other may benefit if part of the `Observable` API? When using the current implementation of drop you have very little control when the dropping starts to happen and in our case we can calculate a value for the buffer based on the characteristics and configuration of the application.\n\nThe term \"buffer\" fooled me a bit in the API docs and I assumed that the capacity controls the size after which the source observable starts to overflow. Would it make sense to clarify that documentation at least and mention that there is an internal buffer which can hold actually more items than what you specify as your overflow buffer? \n\nThanks for the quick reply!\n",
        "I've bumped into the queueing on disk use case a few times but haven't implemented anything. I'll have a look (probably in a couple of weeks).\n"
    ],
    "2934": [],
    "2600": [],
    "4692": [],
    "6079": [],
    "4077": [],
    "487": [],
    "3392": [],
    "3495": [],
    "4749": [],
    "283": [],
    "6704": [],
    "2881": [],
    "1382": [],
    "6150": [],
    "4490": [],
    "110": [],
    "1031": [],
    "1645": [],
    "5900": [],
    "1489": [],
    "6504": [],
    "4689": [],
    "6894": [],
    "5793": [],
    "4322": [],
    "2589": [],
    "5177": [],
    "1208": [],
    "3282": [],
    "6805": [],
    "2607": [],
    "1635": [],
    "6511": [],
    "644": [],
    "1216": [],
    "3639": [],
    "1755": [],
    "4300": [],
    "1003": [],
    "6774": [],
    "4289": [],
    "5174": [],
    "3823": [],
    "3303": [],
    "2867": [],
    "290": [],
    "4026": [],
    "4118": [],
    "580": [],
    "1497": [],
    "535": [],
    "3892": [
        "Close via #3905\n",
        "Looks like `OnSubscribeToObservableFuture` was not refitted with backpressure support and it fires the future's value unconditionally. I'll post a fix for this. Thanks for reporting!\n",
        "See #3893.\n\nWorkaround for now: apply `onBackpressureBuffer()` after the `from(Future)` you are using.\n",
        "Do you have a default value on your single() operator?\n",
        "Thanks, found the issue in OperatorSingle, when the default path is taken, the value is emitted without checking for backpressure. I'll post a fix soon.\n",
        "See #3905.\n",
        "Great, thanks!\n",
        "I think there might be other operators that need to be retrofitted? \n\n``` java\nNon-fatal Exception: java.lang.IllegalStateException: more items arrived than were requested\n       at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:206)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:129)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:107)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:268)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:47)\n       at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable$2.call(Observable.java:233)\n       at rx.Observable$2.call(Observable.java:225)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n       at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:125)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.emit(OperatorTakeLastOne.java:159)\n       at rx.internal.operators.OperatorTakeLastOne$ParentSubscriber.onCompleted(OperatorTakeLastOne.java:125)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:635)\n       at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:547)\n       at rx.internal.operators.OperatorMerge$InnerSubscriber.onCompleted(OperatorMerge.java:836)\n       at rx.internal.operators.OperatorMap$1.onCompleted(OperatorMap.java:43)\n       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.complete(OperatorOnBackpressureBuffer.java:169)\n       at rx.internal.util.BackpressureDrainManager.drain(BackpressureDrainManager.java:187)\n       at rx.internal.util.BackpressureDrainManager.terminateAndDrain(BackpressureDrainManager.java:114)\n       at rx.internal.operators.OperatorOnBackpressureBuffer$BufferSubscriber.onCompleted(OperatorOnBackpressureBuffer.java:140)\n       at rx.internal.operators.OperatorSubscribeOn$1$1.onCompleted(OperatorSubscribeOn.java:68)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:76)\n       at rx.internal.operators.OnSubscribeToObservableFuture$ToObservableFuture.call(OnSubscribeToObservableFuture.java:43)\n       at rx.Observable.unsafeSubscribe(Observable.java:8741)\n       at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n",
        "We call `lastOrDefault` which calls `new OperatorSingle<T>(defaultValue)`.\n",
        "Thanks!\n"
    ],
    "4134": [],
    "3142": [],
    "5307": [],
    "420": [],
    "4095": [],
    "5306": [],
    "6359": [],
    "1817": [],
    "4666": [],
    "4382": [],
    "2845": [],
    "812": [],
    "2580": [],
    "1179": [],
    "1327": [],
    "2818": [],
    "1537": [],
    "3940": [
        "Thanks for reporting. Indeed, this is a bug in `Single.flatMap`. Fix PR in #3941 .\n"
    ],
    "3192": [],
    "3947": [
        "Closing via #3948\n",
        "There is the `endWith` operator for this purpose, but you can post a PR renaming it.\n",
        "You can deprecate that as well.\n",
        "No need for squashing on your end.\n",
        "@akarnokd thanks for the quick reply. Posted a PR for that. Just a quick question what about `endWith(Observable<T> next)` should that stay or should there also be `andThen` used?\n",
        "Alright thanks. I updated the PR let me know whether I should squash commits and change commit message to match the new updated title or whether you'll use the GitHub squash and merge functionality.\n"
    ],
    "4450": [],
    "4480": [],
    "1761": [],
    "6469": [],
    "6734": [],
    "4890": [],
    "3960": [
        "Zip uses a prefetch of 128 elements by default. Since both sources are synchronous, the second case takes all 4 from the first source, including completion, then moves onto `o2` which first emits 1, then its completion completes the whole sequence. Thus, you see both doOnCompleted executed.\n\nThe first case, `o1` signals 1 and completion, then once `o2` signals its 1, it is known `o2` won't ever signal more values, thus `o2` gets unsubscribed and never allowed to run to completion.\n\nBoth are the expected behavior. If you need resource cleanup associated with a sequence, you can't rely on doOnCompleted as sequences may get unsubscribed before that.\n",
        "It is the explanation for what you experienced. The `zip` javadoc has this clause:\n\n> The resulting `Observable<R>` returned from `zip` will invoke `Observer#onNext`\n> as many times as the number of `onNext` invocations of the source Observable that emits the fewest\n> items.\n\nSince `zip`'s behavior seems to be confusing, maybe we could add a clause that `zip` completes eagerly if one of the sources emits fewer elements than the others and unsubscribes the rest.\n",
        "See the proposed documentation changes in #3981.\n",
        "I see, but isn't this implementation details?\n",
        "I agree that docs should be updated. Although the new clause you suggested needs to be more accurate:\n1. Examples in this issue contradict it\n2. If source observables emit equal number of elements (and not fewer), some (which? this one really bothers me) are still going to be unsubscribed.\n",
        "Thanks, now I know what to expect from `zip`. The current implementation still feels unpolished to me, though.\n"
    ],
    "5734": [],
    "191": [],
    "2594": [],
    "735": [],
    "188": [],
    "114": [],
    "827": [],
    "1254": [],
    "1111": [],
    "1435": [],
    "4780": [],
    "894": [],
    "262": [],
    "605": [],
    "3985": [
        "\ud83d\udc4d In the long term, I would like to see that `RxJavaPlugins.reset()` can reset static fields related to plugins.\n",
        "@hzsweers That's what I meant :)\n",
        "Actually it wouldn't just be nulling out those fields. It would have to replace the singleton `INSTANCE` of Schedulers to re-trigger its constructor and evaluation of those scheduler instances. For just tests though, I still think this is a reasonable tradeoff since it's opt-in and doesn't change existing behavior by default.\n",
        "Opened a PR in #3986 for further review\n"
    ],
    "1440": [],
    "3031": [],
    "6182": [],
    "1526": [],
    "4497": [],
    "1516": [],
    "315": [],
    "6313": [],
    "1114": [],
    "4232": [],
    "537": [],
    "5914": [],
    "846": [],
    "1954": [],
    "3692": [],
    "1973": [],
    "3356": [],
    "4841": [],
    "1829": [],
    "733": [],
    "5976": [],
    "4552": [],
    "5902": [],
    "4111": [],
    "1501": [],
    "367": [],
    "4504": [],
    "1": [],
    "4044": [
        "Just to be clear before I start thinking about this more, `Publisher` and `Subscriber` are the only RS types here, right? And `Single` and `Completable` are always backpressure-aware types?\n",
        "I wouldn't mind renaming `Observable` since it's a description of the pattern to which all these types conform. It's the least descriptive of the bunch, and you wouldn't chose it today given the others.\n\nI used to like `Flowable`, and I still do, but now that we have a non-BP vs. BP distinction perhaps we should consider making BP-aware variants of all 3 types and using `Flowable` as an adjective instead of a noun? The problem is that gets verbose.\n",
        "Hmm what about the `request(0)` case though? Where work isn't triggered upon subscription but deferred until explicitly requested.\n",
        "Sorry I mean the case where an operation cannot respect `request(0)`. I'm struggling to come up with an example, but I know I've ran into potential cases before but I never wrote them down (because we never had `Flowable` either).\n",
        "There's also the `Subject` and `FlowProcessor` types in the mix here.\n",
        "I made a chart of the current naming:\n\n<img width=\"639\" alt=\"screen shot 2016-08-07 at 2 11 01 am\" src=\"https://cloud.githubusercontent.com/assets/66577/17460862/f27cd036-5c45-11e6-8b26-bfb5ae099d9e.png\">\n\nAnd here's my proposal for normalization:\n\n<img width=\"639\" alt=\"screen shot 2016-08-07 at 2 22 10 am\" src=\"https://cloud.githubusercontent.com/assets/66577/17460866/00c2c01a-5c46-11e6-854d-6cecfdf4c5a9.png\">\n\nThe changes from current `master` are highlighted.\n",
        "Can we please keep names for `Observable`, `Single` and `Completable` since they're not part of [RS](https://github.com/reactive-streams/reactive-streams-jvm)? They're short and well known. \n\nI'd just rename `Observer` to `ObservableSubscriber` to have same pattern as `SingleSubscriber` and `CompletableSubscriber` and not interfere with `Publisher -> Subscriber`.\n",
        "> Publisher and Subscriber are the only RS types \n\nYes.\n\n> Single and Completable are always backpressure-aware types?\n\nThe other base types (including Observable) don't have a notion for backpressure.\n",
        "`Single` and `Completable` don't need backpressure because they emit 1 or 0 items respectively.\n\nThe non-backpressured `Observable` was requested to allow pure GUI event handling where the sources are hot and can't be backpressured.\n",
        "The current rule of thumb is that if an operator can't respect the request amount, it will signal a `MissingBackpressureException` instead of overflowing the downstream. This behavior still requires request tracking. The reason for signalling is due to the confusion about the situation in 1.x where exception is signalled in the operator that suffered the buffer overflow attempt and no indication whose fault it was really.\n",
        ":+1:\n",
        "Renames and refactorings happened.\n",
        "I'll give the Single changes a try.\n",
        "Will continue with Completable once the other 2 PRs are merged to avoid merge conflicts.\n",
        "The proposed new names have been applied and I guess this issue can be closed then if there is no further input.\n"
    ],
    "5938": [],
    "5112": [],
    "3350": [],
    "1463": [],
    "1602": [],
    "3836": [],
    "459": [],
    "1448": [],
    "4051": [],
    "1576": [],
    "3248": [],
    "5875": [],
    "3135": [],
    "4827": [],
    "1496": [],
    "4907": [],
    "1808": [],
    "3229": [],
    "639": [],
    "1188": [],
    "5651": [],
    "3112": [],
    "145": [],
    "3714": [],
    "5188": [],
    "3986": [],
    "5440": [],
    "3845": [],
    "6531": [],
    "4027": [],
    "5783": [],
    "1108": [],
    "4127": [],
    "1224": [],
    "319": [],
    "2053": [],
    "3701": [],
    "6748": [],
    "1128": [],
    "449": [],
    "2935": [],
    "6257": [],
    "241": [],
    "5189": [],
    "248": [],
    "3322": [],
    "4509": [],
    "2854": [],
    "5197": [],
    "522": [],
    "4760": [],
    "646": [],
    "2872": [],
    "907": [],
    "5923": [],
    "3994": [],
    "1631": [],
    "3904": [],
    "996": [],
    "857": [],
    "273": [],
    "5386": [],
    "2852": [],
    "4507": [],
    "4570": [],
    "1906": [],
    "5924": [],
    "4230": [
        "Could you give an example of such non-interruptible blocking tasks?\n",
        "I see. I'd consider the fix in #4231 as a temporary workaround because such tasks will keep blocking out threads (and leak resources). Generally, this is what `newThread()` is handy for: you get a new thread that can be blocked without the fear of reuse. Send such untrustwothy tasks to newThread() and the rest to io().\n",
        "I happened to face this bug today, was using RxJava 1.1.2. After half an hour of debugging went to check for newer version, and guess what - first bug fix in release notes is exactly the one I was fighting. Pulled latest, everything works like a charm. Thank you guys!\n",
        "@akarnokd A concrete example is in the test case that I added in #4231, but in general any task that is carelessly written (swallows `InterruptedException`, or busy looping, etc.) will trigger this issue. \n\nExample:\n\n```\nint numClients = 0;\nfor (Server s : servers) {\n    try {\n        numClients += s.queryNumClients();\n    } catch (Exception e) {\n        // Assume 0 clients\n    }\n}\nreturn numClients;\n```\n\nThe `InterruptedException` caused by `unsubscribe()` is swallowed and if the next `s.queryNumClients()` blocks for minutes, then this will block the thread for minutes.\n\nWhat's worse is that this may even come from 3rd party code that also uses `Schedulers.io()` and cause extremely hard to debug problems.\n",
        "Absolutely, #4231 only prevents other tasks from being blocked by the misbehaving task, it does't prevent the thread (and potentially other resource) leaks.\n\nI believe the thread leak would be present with `newThread()` as well and there is not much we can do about this. There is `Thread.stop()` but it introduces more problems than it solves. Hopefully the misbehaving task will complete eventually and at that point the resources will be freed up. If it never completes then it's a lost thread and the resources are leaked permanently.\n"
    ],
    "4413": [],
    "1584": [],
    "3203": [],
    "433": [],
    "901": [],
    "6867": [],
    "5968": [],
    "5297": [],
    "3241": [],
    "155": [],
    "563": [],
    "5726": [],
    "472": [],
    "6714": [],
    "4059": [],
    "2963": [],
    "4744": [],
    "5471": [],
    "3761": [],
    "5860": [],
    "5236": [],
    "3451": [],
    "2937": [],
    "2882": [],
    "3539": [],
    "3510": [],
    "4971": [],
    "2622": [],
    "1015": [],
    "2905": [],
    "4556": [],
    "1172": [],
    "6205": [],
    "3101": [],
    "3782": [],
    "3245": [],
    "1103": [],
    "4106": [],
    "5993": [],
    "6708": [],
    "6155": [],
    "2595": [],
    "466": [],
    "1129": [],
    "1453": [],
    "3655": [],
    "3720": [],
    "6765": [],
    "6873": [],
    "3562": [],
    "3682": [],
    "3561": [],
    "2821": [],
    "4301": [],
    "1236": [],
    "6165": [],
    "1568": [],
    "288": [],
    "2561": [],
    "5295": [],
    "5850": [],
    "5447": [],
    "6275": [],
    "4602": [],
    "516": [],
    "527": [],
    "4632": [],
    "5230": [],
    "5602": [],
    "6675": [],
    "6800": [],
    "370": [],
    "3991": [],
    "1038": [],
    "4493": [],
    "2978": [],
    "4529": [],
    "6117": [],
    "6222": [],
    "5702": [],
    "801": [],
    "3227": [],
    "6720": [],
    "4742": [],
    "6301": [],
    "1399": [],
    "3829": [],
    "5887": [],
    "1937": [],
    "6135": [],
    "2760": [],
    "3789": [],
    "6733": [],
    "596": [],
    "598": [],
    "3846": [],
    "6234": [],
    "3298": [],
    "1074": [],
    "167": [],
    "5066": [],
    "3399": [],
    "3256": [],
    "4209": [],
    "4145": [],
    "3699": [],
    "3042": [],
    "1228": [],
    "3417": [],
    "6099": [],
    "3586": [],
    "3479": [],
    "4685": [],
    "3528": [],
    "3756": [],
    "303": [],
    "3144": [],
    "3619": [],
    "4498": [
        "Not sure what you mean or how you imagine it, but PR is welcome.\n",
        "Closing via #4586.\n"
    ],
    "5462": [],
    "5752": [],
    "5972": [],
    "5531": [],
    "3321": [],
    "6559": [],
    "6685": [],
    "211": [],
    "182": [],
    "1587": [],
    "5413": [],
    "2927": [],
    "1634": [],
    "5091": [],
    "6348": [],
    "818": [],
    "255": [],
    "4973": [],
    "4535": [
        "Might be possible to write a check for this but currently the source file is not parsed but only string-contains checked.\n",
        "@MiSikora IntelliJ/Kotlin users are mostly affected by their lack, or sometimes their presence so I can't give you a definite answer from a Eclipse/Java perspective.",
        "I noticed in #4589 that sometimes there's an error where the javadoc starts with `/** Returns an Observable` however the return type of the method is no longer an Observable. (e.g. https://github.com/ReactiveX/RxJava/pull/4589/files#diff-dce8212f1f82c8f48cae503990587755R7707)\n",
        "I see that only `static` methods are annotated with `@NonNull`. Is there a reason behind it or can it be extended to member functions like `map()` in a PR?"
    ],
    "740": [],
    "963": [],
    "3413": [],
    "1248": [],
    "3585": [],
    "4384": [],
    "4021": [],
    "398": [],
    "835": [],
    "940": [],
    "6114": [],
    "1053": [],
    "3438": [],
    "5184": [],
    "853": [],
    "6808": [],
    "6665": [],
    "863": [],
    "3418": [],
    "4344": [],
    "6351": [],
    "4316": [],
    "779": [],
    "5735": [],
    "2540": [],
    "308": [],
    "5828": [],
    "786": [],
    "4537": [],
    "3754": [],
    "4885": [],
    "4114": [],
    "187": [],
    "6311": [],
    "3529": [],
    "5675": [],
    "3839": [],
    "670": [],
    "4769": [],
    "525": [],
    "2465": [],
    "3826": [],
    "3597": [],
    "4650": [
        "We have those kind of transformers but they are not wired up to `compose` for some reason  (forgotten?). PR welcome.\n",
        "Closing via #4651\n",
        "Totally missed that they already existed. Done! - https://github.com/ReactiveX/RxJava/pull/4651\n"
    ],
    "4653": [
        "Java 8 changed the return type of `keySet` and it trips AnimalSniffer as well. In theory, by compiling with javac 7, there should be no binding to Java 8's type there.\n",
        "Let's see if http://stackoverflow.com/a/32955708/61158 works for us as well.\n",
        "While you are at this, could you post a PR with the fix above?\n",
        "Closing via #4654.\n",
        "Interestingly, if I breakpoint this line, the rest of the app appears to run just fine and isn't blocked. As soon as I let it pass though, it crashes.\n",
        "doesn't that come at the expense of being able to target Java 8 entirely though?\n",
        "Looks like that fixed it when I test locally, will upload a PR in a sec\n"
    ],
    "762": [],
    "3330": [],
    "1056": [],
    "1115": [],
    "6746": [],
    "4346": [],
    "3150": [],
    "6736": [],
    "4053": [],
    "391": [],
    "545": [],
    "249": [],
    "3637": [],
    "312": [],
    "212": [],
    "137": [],
    "2565": [],
    "6890": [],
    "5669": [],
    "6802": [],
    "1938": [],
    "4447": [],
    "3423": [],
    "4737": [
        "Or... well, this is going to be funky, but I guess we could also recreate an entirely new exception that has exactly the same stacktrace but an unset cause.\n",
        "on it.\n",
        "I don't see any other way than catcing ISE and signalling to the hooks. Care to submit a PR?\n",
        "Closing via #4740.\n"
    ],
    "5199": [],
    "3141": [],
    "6642": [],
    "4980": [],
    "739": [],
    "6550": [],
    "5617": [],
    "5493": [],
    "3371": [],
    "2806": [],
    "6544": [],
    "4725": [],
    "399": [],
    "4762": [
        "Would you like to submit a PR?\n",
        "I don't have the capacity to investigate this right now. Indeed there is a null check missing in `Observable.switchIfEmpty()`.\n",
        "The fix is trivial, yes. Figuring out why the NPE never popped out from the internals is another story.\n",
        "Closing via #4791\n",
        "@akarnokd so what would this entail? Does it just need a null check and throw an NPE?\n",
        "I'm not ready to provide a PR - probably just a simple null verification on the switchIfEmpty creation.\nI think its worth a deeper investigation by someone from the core team.\n"
    ],
    "2949": [],
    "4851": [],
    "4397": [],
    "3718": [],
    "6584": [],
    "1527": [],
    "3143": [],
    "895": [],
    "6405": [],
    "1734": [],
    "1091": [],
    "3081": [],
    "4180": [],
    "1247": [],
    "152": [],
    "6429": [],
    "4041": [],
    "1934": [],
    "668": [],
    "4842": [],
    "6837": [],
    "5379": [],
    "3903": [],
    "1802": [],
    "5527": [],
    "609": [],
    "1321": [],
    "3000": [],
    "6888": [],
    "1740": [],
    "1347": [],
    "4238": [],
    "616": [],
    "2762": [],
    "3274": [],
    "4858": [],
    "1406": [],
    "4371": [],
    "898": [],
    "3958": [],
    "5661": [],
    "6745": [],
    "3408": [],
    "368": [],
    "221": [],
    "6343": [],
    "3422": [],
    "1336": [],
    "1302": [],
    "507": [],
    "860": [],
    "1728": [],
    "3866": [],
    "1588": [],
    "4355": [],
    "4878": [
        "What's the rationale behind forcing handling of a `Disposable` return value? In most of the cases I've encountered I've preferred a setup where my subscription runs indefinitely. Is it unsafe to ignore the return here? If so, why?",
        "I'm on 2.0.5 and the source for subscribe looks like this:\r\n\r\n```java\r\n    @CheckReturnValue\r\n    @SchedulerSupport(SchedulerSupport.NONE)\r\n    public final Disposable subscribe(Consumer<? super T> onNext) {\r\n        return subscribe(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION, Functions.emptyConsumer());\r\n    }\r\n```\r\n\r\n",
        "Can't link to the source since GH is truncating at ~10k lines, but it looks like on master the code is the same.",
        "#5244",
        "Per above, I'm subscribing a consumer with intent to subscribe to every subsequent event. In that case, why should I handle the Disposable?",
        "Nope, intent is to subscribe for the remaining lifetime of my program. ",
        "Cool, I guess I'm asking when one _should_ check `Disposable`, it's not clear from this thread under what conditions it's safe to ignore. If it's always safe to ignore, it seems like this annotation is erroneous, if not, I'd like to know when, and why, so that I can write my code sanely.",
        "I'd add that the current code explicitly excepts methods with signature `Disposable subscribe()`, so would be good to understand why those `Disposable`s are always safe to ignore but the others are not.",
        "I like to think of it as a forced documentation opportunity to indicate that you really don't care about the `Disposable`. You either _always_ care about it and thus use the return value or you explicitly don't care and should suppress and comment as why it's being ignored.",
        "The no-arg `subscribe()` seems, in general, an anti-pattern to use. It indicates you want the side-effects of subscription to happen but do not actually care about the results, success, or failure which is a recipe for a bad user experience when such side-effect actually does fail or emit something unexpected which goes entirely unhandled.",
        "Views have a lifecycle you should be using to unsubscribe. For singletons, you can suppress with a comment to document the rare nature of that object and its exception to the rule.",
        "I frequently fire up `subscribe(Consumer)` and don't care about cancellation so it would just bother me. Also `@CheckReturnValue` sounds like part of some extra dependency and we don't want that. The only dependency is the Reactive-Streams API.",
        "I think `subscribeWith` is a reasonable target here as its purpose is to give you back what you gave to it so you can continue with that value. Also methods returning `Flowable` etc. shouldn't be ignored. If you can make it without external dependencies, I'm fine with the extra annotations.",
        "@markelliot It was decided anything that returns `Disposable` should not have `@CheckReturnValue`. Did you find method(s) that do?",
        "Both having and not having this annotation makes sense. Can't you just ignore warnings at that location that can legally ignore the return value?",
        "I'd like to kick the tires on this discussion again\r\n\r\n> In 99% of the cases you want to handle it.\r\n\r\nI don't think I agree with that. For cases like @digitalbuddha mentioned with singletons or places where the scope of the execution is implicitly bound to the object (such as subscribing to an Android View's click events from within the View). To me, `@CheckReturnValue` should only apply in cases where it is **100% programmer error to not** capture it, such as a factory method. This to me is not such a case.\r\n\r\nThoughts?",
        "> Views have a lifecycle you should be using to unsubscribe\r\n\r\nIf you need to dispose at some point before the View is up for GC, sure. That's not the case 100% of the time though. I could be listening for detach events too, for instance, or tracking through multiple attach/detaches. There's no other lifecycle event to hook into beyond detach, but I'm happy to let the subscription die with the View once they're all leafs for GC if the subscription is only internal to the View.\r\n\r\nAnother example would be synchronous cases like `just` or `fromIterable`.\r\n\r\nI just don't think this case is as rare as is being described. On top of that, conditions for cases like lifecycle management vary depending on the codebase, and often doesn't involve directly dealing with the `Disposable` itself. In RxLifecycle, a completion event is sent from upstream. In AutoDispose, it's handled internally (though there we just omit these annotations from the returned subscribe proxy interfaces). Some codebases might use Kotlin with their own extensions, or `CompositeDisposable`s in some fancy way, or even pass in a `Consumer<Disposable>` directly to the full-arg `subscribe()` overload, yet still will have this imposed on them by static analysis tools. I think enforcement for this case is much better left to consumers to implement what fits their codebase best. Perhaps a community EP/lint check that recreates this behavior would be useful for those that want to keep it, without requiring it for all.",
        "I see little point in using `Disposable` of `Single`/`Completable`/`Maybe`. Sure, you might want to explicitly cancel them at some point, but that's definitely not something that you'll always need.\r\n\r\nPlus `@CheckReturnValue` is incompatible with [RxLifecycle](https://github.com/trello/RxLifecycle) for regular `Observable`.\r\n\r\nProject-wide or even class-wide `@SuppressLint(\"CheckResult\")` is a very bad idea so I'm forced to use \r\n```\r\n.subscribe(() -> {\r\n\t...\r\n})\r\n.isDisposed();\r\n```\r\n\r\nLooks ugly.",
        "@vanniktech we have quite a few subscriptions within our android app that are done from one Singleton to another and do not require disposing.  One example is a memory cache observing a disk cache. ",
        "You most certainly can the minor inconvenience we see is having to suppress the warning when using static analyzers/lint inspectors. For example Error Prone failed our build without `    @SuppressWarnings(\"CheckReturnValue\")`",
        "I love the `@CheckReturnValue`, but in some projects with [RxLifecycle](https://github.com/trello/RxLifecycle) we do not actually need to care about this return value. In this case, we have to use `suppress` everywhere, \ud83e\udd14...\r\n\r\nP.S. I finally found  a perfect solution: https://github.com/uber/AutoDispose",
        "Ugh. After updating to RxJava 2.1.12, I have awful yellow warning highlighting everywhere. My two cents -- I hate `@CheckReturnValue`. I do the following, which works well for my project:\r\n```\r\n.doOnSubscribe(subscriptions::add) // subscriptions is a CompositeDisposable\r\n```\r\nI find this much more readable than\r\n```\r\nDisposable disposable = somethingService.get().subscribe(...);\r\ncomposititeDisposable.add(disposable);\r\n```\r\n\r\nI don't want to suppress that warning _everywhere_, so now I have to litter my code with local suppressions.",
        "Yes either get the annotation from JSR 305 or I believe that creating our own annotation with the same name would also work.",
        "Alright will give it a try soon.",
        "Closing via #4881",
        "Why would you want to not handle the returned Disposable?",
        "Since you may need to `dispose()` it later?",
        "I see it differently but it might be just because I'm on Android and you're forced to dispose() when you hit a certain lifecycle method (e.g. Activity gets destroyed)",
        "I am with @autonomousapps on this one.\r\n\r\nI also have a convenience method to be used with `.compose()`\r\n\r\n```\r\nprotected <T> ObservableTransformer<T, T> asDisposable() {\r\n        return upstream ->\r\n                upstream.doOnSubscribe(disposable -> mDisposables.add(disposable));\r\n    }\r\n```\r\n\r\nAnd I needed to add `@SuppressWarnings(\"CheckReturnValue\")` in order to pass on Error Prone, while  in fact I am using the disposable on `doOnSubscribe`."
    ],
    "6377": [],
    "3405": [],
    "727": [],
    "165": [],
    "902": [],
    "1470": [],
    "3907": [],
    "4264": [],
    "6180": [],
    "1928": [],
    "6434": [],
    "1945": [],
    "6140": [],
    "6083": [],
    "5689": [],
    "4583": [],
    "3901": [],
    "5098": [],
    "5133": [],
    "4914": [],
    "6741": [],
    "5594": [],
    "3262": [],
    "380": [],
    "1089": [],
    "4585": [],
    "3300": [],
    "2868": [],
    "4296": [],
    "1491": [],
    "186": [],
    "1281": [],
    "6232": [],
    "1809": [],
    "426": [],
    "373": [],
    "6840": [],
    "4950": [
        "Do you have an example that doesn't compile for you without `? super`? We have to be careful with such variance changes because it may break current users.",
        "Okay, please verify that with the variance changes it compiles with Java 6, 7 and 8 targets.",
        "Whoops just saw your response. I'll put together a sample later tonight",
        "So here's an example where an observable emits `A` instances down the stream and transforms them into `B` instances.\r\n\r\n```java\r\ninterface A<T, R> {}\r\ninterface B<T> {}\r\n\r\n// RxJava 1\r\nstatic <T> rx.Observable.Transformer<A<T, ?>, B<T>> oldStyle() {\r\n    return new rx.Observable.Transformer<A<T, ?>, B<T>>() {\r\n        @Override\r\n        public rx.Observable<B<T>> call(rx.Observable<A<T, ?>> a) {\r\n            return rx.Observable.empty();\r\n        }\r\n    };\r\n}\r\n\r\n// RxJava 2\r\nstatic <T> ObservableTransformer<A<T, ?>, B<T>> newStyle() {\r\n    return new ObservableTransformer<A<T, ?>, B<T>>() {\r\n        @Override\r\n        public ObservableSource<B<T>> apply(Observable<A<T, ?>> a) {\r\n            return Observable.empty();\r\n        }\r\n    };\r\n}\r\n\r\nvoid test() {\r\n    \r\n    A<String, Integer> a = new A<String, Integer>() { };\r\n\r\n    // RxJava 1\r\n    rx.Observable.just(a)\r\n            .compose(TransformersTest.<String>oldStyle())  // Yay, because Integer is irrelevant here\r\n            .subscribe(new Action1<B<String>>() {\r\n                @Override\r\n                public void call(B<String> stringB) {\r\n\r\n                }\r\n            });\r\n\r\n    // RxJava 2\r\n    Observable.just(a)\r\n            .compose(TransformersTest.<String>newStyle())   // This doesn't compile\r\n            .subscribe(new Consumer<B<String>>() {\r\n                @Override\r\n                public void accept(B<String> tB) throws Exception {\r\n\r\n                }\r\n            });\r\n}\r\n```\r\n\r\nIn the RxJava 2 example, the `compose()` line there doesn't compile because of generics issues.\r\n\r\n<img width=\"1341\" alt=\"screen shot 2017-01-07 at 11 55 01 pm\" src=\"https://cloud.githubusercontent.com/assets/1361086/21748246/f0879672-d534-11e6-9f53-48c5b776ba89.png\">\r\n\r\nIn order to make it compile, the transformer signature needs to be changed to be like the following:\r\n\r\n```java\r\nstatic <T, R> ObservableTransformer<A<T, R>, B<T>> newStyle() {\r\n    return new ObservableTransformer<A<T, R>, B<T>>() {\r\n        @Override\r\n        public ObservableSource<B<T>> apply(Observable<A<T, R>> a) {\r\n            return Observable.empty();\r\n        }\r\n    };\r\n}\r\n```\r\n\r\nAnd imposes some boilerplate on the consumer in that they now have to specify the second type even though it's irrelevant.\r\n\r\n```java\r\nObservable.just(a)\r\n        .compose(TransformersTest.<String, Integer>newStyle())  // :(\r\n        .subscribe(new Consumer<B<String>>() {\r\n            @Override\r\n            public void accept(B<String> tB) throws Exception {\r\n\r\n            }\r\n        });\r\n```"
    ],
    "5552": [],
    "5876": [],
    "3672": [],
    "6752": [],
    "1713": [],
    "4500": [],
    "511": [],
    "3753": [],
    "5068": [],
    "4978": [
        "LGTM\r\n",
        "Alright, based on the thumbs up ... should I submit a PR? cc @akarnokd in particular for answering whether you want me to submit this, or you do the change?",
        "For RxAndroid we use \"The RxAndroid authors\", but I'm happy to normalize that to whatever is chosen here.",
        "@benjchristensen Sure.",
        "All updated. Thanks.",
        "@benjchristensen Maybe you forget to change README.md?"
    ],
    "3364": [],
    "885": [],
    "3332": [],
    "4993": [
        "They're internal in 1.x too. The only remnants are public for binary\ncompatibility that no one should be using anyway. Are you referring to the\nfactory methods? Those could easily be replicated on 2.x.\n\nOn Fri, Jan 13, 2017, 4:22 AM Zac Sweers <notifications@github.com> wrote:\n\n> I missed that they were internal now. That's disappointing to see, and\n> seems like a bit of a step backward compared to RxJava 1. We'll just copy\n> then :|\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ReactiveX/RxJava/issues/4993#issuecomment-272431211>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAEEERdKOOoaZajpQio5Pgsyac0sCa0Lks5rR2x0gaJpZM4LiyuF>\n> .\n>\n",
        "Which scheduler? Computation? It was intentional. You can now configure the priority of each scheduler so there was little benefit from a customizing the factory. Use the [ParallelScheduler](https://github.com/akarnokd/RxJava2Extensions#parallelscheduler) from extensions which allows more [customization](https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/schedulers/ParallelScheduler.java#L87).\r\n\r\n",
        "Since scheduler implementations are internal, it is not recommended anyway to use them directly.\r\n\r\nParallelScheduler is an individual scheduler with a specified number of threads that doesn't change over time. So unlike io(), ParallelScheduler won't stop its threads when they become idle for too long.",
        "Anything in the `io.reactivex.internal.*` is considered private and not part of any binary or API compatibility contracts.",
        "So either use `Schedulers.from(Executor)` with your own pool or copy the internal code and change it locally.",
        "They will be still internal classes. However, we could expose them, for example, `Schedulers.newComputation()`, `Schedulers.newIO()` etc where extra parameters can be passed in, similar to how Project Reactor's schedulers were exposed.",
        "Sure.",
        "We used it for the IO scheduler as well. It was useful for tracking our own thread naming and setting their priority to android-specific priorities. We'd like to use it for that and SingleScheduler. Can ParallelScheduler be used as a substitute for non-computation schedulers too?",
        "> Since scheduler implementations are internal, it is not recommended anyway to use them directly.\r\n\r\nI'm not sure I follow. As in we shouldn't create a new IoScheduler instance?",
        "Prior discussions/work for reference - #3724 #3879",
        "I missed that they were internal now. That's disappointing to see, and seems like a bit of a step backward compared to RxJava 1. We'll just copy then :|",
        "Yeah I was referring to the factory methods. Basically wanted to do the same thing you added in the linked PR above",
        "> Those could easily be replicated on 2.x.\r\n\r\n@akarnokd any thoughts on this? This is what I was thinking of in opening this issue, in case I wasn't clear before",
        "That sounds reasonable to me.[ The APIs they expose cover pretty much everything we'd want](https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/scheduler/Schedulers.java), would be happy to make a PR matching those if you're up for it."
    ],
    "944": [],
    "5146": [],
    "1765": [],
    "1672": [],
    "3160": [],
    "381": [],
    "1776": [],
    "1051": [],
    "1264": [],
    "1474": [],
    "1944": [],
    "973": [],
    "4154": [],
    "117": [],
    "5996": [],
    "667": [],
    "6869": [],
    "1177": [],
    "1120": [],
    "4261": [],
    "1337": [],
    "4008": [],
    "5045": [
        "I gave it a shot: https://github.com/ReactiveX/RxJava/pull/5058\r\nWidening the generics seems to work so far\r\n\r\nBut of course I don't know about any side effects, possible problems.",
        "setErrorHandler: yes, others would bring trouble I think."
    ],
    "5633": [],
    "4609": [],
    "5053": [
        "Yes, that is the line. Ok, is a false positive.\r\nI will add some annotations to SimpleQueue to avoid confusion.",
        "https://github.com/ReactiveX/RxJava/pull/5054",
        "SimpleQueue may return null indicating an empty queue.\r\n\r\n> If SimpleQueue#poll might return null, at least io.reactivex.internal.operators.flowable.FlowableGroupJoin.GroupJoinSubscription#drain needs to be fixed.\r\n\r\nYou mean L238? Due to the bi-offer, if the first call to poll is not null the second one is guaranteed to be non null. You have a false positive there."
    ],
    "1964": [],
    "2970": [],
    "3620": [],
    "4058": [],
    "4979": [],
    "5453": [],
    "1414": [],
    "1836": [],
    "3171": [],
    "6626": [],
    "5773": [],
    "404": [],
    "924": [],
    "4179": [],
    "2477": [],
    "1790": [],
    "4281": [],
    "5616": [],
    "4503": [],
    "5081": [
        "@akarnokd , but why do we need to write this\r\n`Completable.timer(1, TimeUnit.SECONDS).andThen(deleteDb()).subscribe();`\r\ninstead of just doing this:\r\n`deleteDb().delaySubscription(1, TimeUnit.SECONDS).subscribe();`?\r\n\r\nAlso, we do not always have access to the beginning of Completable, we might want to alter its subscription time afterwards, isn't it?",
        "Could you be more specific?",
        "Delaying subscription to a `Completable` \"b\" by a `Completable` \"a\" is `a.andThen(b)`. The other types can be transformed into Completable to participate in this pattern.\r\n\r\nIf you want, go ahead with a PR.",
        "@soshial I offered the option to write a PR for a specific timed `delaySubscription` but the OP chose the readily available workaround.\r\n\r\n> Also, we do not always have access to the beginning of Completable, we might want to alter its subscription time afterwards, isn't it?\r\n\r\nThis makes no sense. You need the `Completable` to be able to delay a subscription to it. Also you can do this:\r\n\r\n```java\r\ndeleteDb.compose(c -> timer(1, SECONDS).andThen(c));\r\n```\r\n\r\nEither way, the `Completable` instance has to exist.",
        "Apoligies for the vague issue.\r\n\r\nI thought Rx 1.x had `delaySubscription` available for Completable and it was missing in 2.x. It looks like that's not the case though, delaySubscription is not available in either 1.x or 2.x.\r\n\r\nWould it be ok to add `delaySubscription` for Completable in 2.x? I'm happy to open a PR, just want to double check if there is any reason it doesn't exist.",
        "Makes sense - the same thing can be achieved with that and it's one less API to maintain.\r\n\r\nI'm going to close this - using `andThen` solves my needs and is much simpler IMO.\r\n\r\nThank you!"
    ],
    "3519": [],
    "3987": [],
    "199": [],
    "3028": [],
    "986": [],
    "4516": [],
    "5288": [],
    "1441": [],
    "1160": [],
    "3912": [],
    "657": [],
    "1918": [],
    "6514": [],
    "1351": [],
    "2847": [],
    "6244": [],
    "3155": [],
    "5205": [],
    "4270": [],
    "3670": [],
    "4567": [],
    "6927": [],
    "3511": [],
    "5244": [],
    "4358": [],
    "4189": [],
    "2091": [],
    "5138": [
        "PR welcome.",
        "Closing via #5146."
    ],
    "602": [],
    "2816": [],
    "5003": [],
    "4967": [],
    "6804": [],
    "1490": [],
    "6729": [],
    "190": [],
    "1104": [],
    "4541": [],
    "6158": [],
    "6281": [],
    "1378": [],
    "931": [],
    "4049": [],
    "1143": [],
    "344": [],
    "4315": [],
    "4248": [],
    "6523": [],
    "5282": [],
    "3630": [],
    "4072": [],
    "6262": [],
    "5647": [],
    "741": [],
    "3231": [],
    "3745": [],
    "1667": [],
    "1376": [],
    "628": [],
    "6738": [],
    "821": [],
    "543": [],
    "5234": [
        "Would be great to have a snippet for such a workaround if any.",
        "@hzsweers thanks! Still feels like a bit of complex solution and hardly portable to e.g. Spek :(",
        "We're using that java agent technique but JVM tests still seem to pass in some cases. At least we get this in test output:\r\n\r\n>Exception: com.example.test.agent.UncaughtException thrown from the UncaughtExceptionHandler in thread \"ModernAsyncTask #3\"",
        "Yeah, this is very serious issue for us as well (sad that we started migration that late\u2026)\r\n\r\n@akarnokd theoretically what if `RxJavaPlugins.onError()` would actually `throw` passed `OnErrorNotImplementedException`? \r\n\r\nFor RS subscriber everything will be ok, since `OnErrorNotImplementedException` is RxJava v2 specific type and `StrictSubscriber` does not throw it (only if user would do this manually), that would allow RxJava v2 keep compatibility with Reactive Streams and pass TCK.\r\n\r\nBasically similar to how it works now with rule 3.9 #5274 and few other cases when if you use RxJava v2 specific types it can break specification, but if you use RS types \u2014 it follows RS.\r\n\r\nThis is kinda breaking change, but not really, since in production ~no one wraps rx chains with try-catch \"Because you can't throw in a push/async environment and expect it to try-catch it.\" and  exceptions without try-catch will achieve thread uncaught handler normally as before while in tests users will actually see problems since test frameworks wrap tests with try-catch and reactive chains in tests are mostly synchronous.\r\n\r\nPlus we could attach RxJavaPlugin sample that imitates previous behavior to the changelog.",
        "Right, but users will have to put `@Rule` in each test class, not everybody use JUnit (we also use two versions of Spek in our projects and mix JUnit4 with JUnit5), I haven't found a way to set global custom JUnit4 test runner [in Gradle](https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html) and by default IntelliJ runs tests on its own using build system only to generate test class files so it'll also require some customization.\r\n\r\n\"In production\" you typically have an entrypoint (Application classes exist in most of both in front- and backend frameworks) which is a convenient place to hook into RxJavaPlugins and set desired behavior. \r\n\r\nWhile tests are usually isolated from each other and each class if not method will require customization for um, detecting errors\u2026 which is basically what each test should do by default\u2026 It just seems wrong to not inverse current behavior.\r\n\r\n@akarnokd what are your concerns about throwing `OnErrorNotImplementedException` for RxJava v2 specific subscribers and not doing so for Reactive Streams subscribers? \r\n\r\nMine is that it can create sort of unexpected behavior if you'll try to mix RxJava v2 with some other RS implementations in compare to how RxJava v2 will work in isolation, but I'm not sure that mixing is common use case. I'm much more afraid that current behavior is ***very*** unexpected for v1 users who are migrating to v2.",
        ">Throwing anything but fatal exceptions is undefined behavior.\r\n\r\nIn RxJava v1 `OnErrorNotImplementedException` was [considered as fatal](https://github.com/ReactiveX/RxJava/blob/2162d6d35a8e162f408e1bfd4083924c0987751b/src/main/java/rx/exceptions/Exceptions.java#L83), what makes it non-fatal for RxJava v2?",
        ">throwing from Reactive-Streams is somewhat of a gamble\r\n\r\nThat's what I want to avoid and throw only if RxJava v2 specific subscriber was used. \r\n\r\n`OnErrorNotImplementedException` can not be thrown in the middle of rx chain. Only by calling v2-specific`subscribe()` without error handler, which reduces possibility of multi-library problems since they will use RS `org.reactivestreams.Publisher.subscribe(org.reactivestreams.Subscriber)`.\r\n\r\nAs said before, v2 violates some RS rules if v2 specific subscriber was used, but respects RS if RS subscriber comes. And I can create problematic multi-library flow because of that, but only if I'd like to.\r\n\r\n---\r\n\r\n>For example, a multi-library flow may not consider it as fatal or swallow it completely anyway\r\n\r\nBtw, this is already happening with RxJava v1 and v2 connected through [interop library](https://github.com/akarnokd/RxJava2Interop), v2 swallows `OnErrorNotImplemented` thrown by v1:\r\n\r\n```kotlin\r\n@Test\r\nfun interopProblem() {\r\n    try {\r\n        Observable2\r\n                .fromCallable { throw RuntimeException(\"Test\") }\r\n                .toObservable1()\r\n                .subscribe()\r\n        fail(\"Should throw rx.exceptions.OnErrorNotImplementedException\")\r\n    } catch (expected: rx.exceptions.OnErrorNotImplementedException) {\r\n        // ok.\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n>most likely you have to mock out schedulers already, making the test synchronous and at the end, you can synchronously check any excess errors with an approach like I showed above.\r\n\r\nGood point, but. \r\n\r\nScheduling is explicit, our code will not compile if we won't pass scheduler (either real or test one). \r\n\r\nWhile current design of error handling is *implicit* and not only allows tests to compile without checks suggested above, but also returns normally and tests pass as false positives.",
        "We normally don't have errors in streams and convert them to values using Kotlin sealed classes, so we don't use `subscribe()` overloads with error handling, rxlint won't help (and it's Android specific).\r\n\r\nBut we need to detect unexpected errors in tests.\r\n\r\n>I believe RxJava already offers the necessary hooking capabilities to detect such errors in tests\r\n\r\nAnd we have 3k+ test cases written with different test frameworks, hooking into each test class is manual and error-prone work. There are hundreds if not thousands other projects migrating from v1 to v2 that'll have to do the same and this number will only grow.",
        "Please correct me if I'm wrong but:\r\n\r\n1. Throwing `OnErrorNotImplementedException` is not undefined behavior since this exception can be thrown in known limited set of cases.\r\n1. Throwing `OnErrorNotImplementedException` does not break compatibility with Reactive Streams since it can be thrown only if RxJava v2 specific `subscribe()` method was called and not if RS `Publisher.subscribe()` was called.\r\n1. Throwing `OnErrorNotImplementedException` is not really a breaking change since if user has no `try/catch` \u2192 it'll be delivered to UncaughtExceptionHandler as before and handling `OENIE`  through custom `RxJavaPlugins.onError()` is typically wrong design and should be done via correct `onError()` or `subscribe()` with error handler on a stream level.\r\n\r\nWhich makes possible to do this change in 2.x and allow users test Rx code as before with 1.x.",
        "Unlike 1.x, `OnErrorNotImplementedException` is not thrown. Also please read on the [error handling](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling) section of the wiki.",
        "2.x `Subscriber`s and `Observer`s must not throw from their `onXXX` methods. Install an error handler before the test and verify there was no undeliverable error. See how we do it in RxJava tests:\r\n\r\nhttps://github.com/ReactiveX/RxJava/blob/3bfc275ca2f8d14a67305bbadb7bbc6315205250/src/test/java/io/reactivex/parallel/ParallelPeekTest.java#L55",
        "Because you can't throw in a push/async environment and expect it to try-catch it.",
        "RxJava 2 only passes fatal exceptions upwards, which end up in the uncaught exception handler. Any other exception goes through `onError` or `RxJavaPlugins.onError`. `RxJavaPlugins.onError()` prints the stacktrace and passes the error to the uncaught exception handler of the current thread. This is due to the Reactive-Streams specification which forbids throwing anything non-fatal from `Subscriber`s and by mirror from `Observer`s as well.\r\n\r\n>RxJava 2 test success, just prints OnErrorNotImplementedException stacktrace not as expected\r\n\r\nWhat stacktrace did you expect?",
        "This is why RxJava's own test often utilize `TestHelper.trackPluginErrors()` and after the run we check for any errors in the `List<Throwable>` returned by that method.",
        "The `RxJavaPlugins` allows you to specify a global handler which you can override temporarily with a `@Rule` and check for excess errors. The [current logic](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/plugins/RxJavaPlugins.java#L375) doesn't throw fatal exceptions upwards either so `OnErrorNotImplemented` wouldn't travel upwards.",
        "Throwing anything but fatal exceptions is undefined behavior.\r\n\r\nI guess you either manually write those unit tests or have some sort of generator. If written manually, you can always compose with extra checks before subscribing to a source. If generated, I assume the generator is written manually since I don't think any testing framework has first class support for RxJava yet. \r\n\r\nAdd the plugin error tracking via `doOnSubscribe()` and remove it via `doFinally`.\r\n\r\n```java\r\npublic static <T> TestObserver<T> createTester(Observable<T> source, Observer<T> mocked) {\r\n\r\n    TestObserver<T> to = mocked != null ? new TestObserver<>(mocked) : new TestObserver<>();\r\n\r\n    List<Throwable> list = Collections.synchronizedList(new ArrayList<>());\r\n    \r\n    return source.doOnSubscribe(s -> {\r\n        RxJavaPlugins.reset();\r\n        RxJavaPlugins.setErrorHandler(e -> list.add(e));\r\n    })\r\n    .doFinally(() -> {\r\n        RxJavaPlugins.reset();\r\n        for (Throwable e : list) {\r\n           to.onError(e);\r\n        }\r\n    })\r\n    .subscribeWith(to);\r\n}\r\n```",
        "It wasn't in the original set of fatal exceptions of 2.x and throwing from Reactive-Streams is somewhat of a gamble. For example, a multi-library flow may not consider it as fatal or swallow it completely anyway (but most will consider an OutOfMemoryError as such btw). The most reliable way for exceptions is down where `RxJavaPlugins.onError` is at the very bottom. \r\n\r\nI believe RxJava already offers the necessary hooking capabilities to detect such errors in tests; most likely you have to mock out schedulers already, making the test synchronous and at the end, you can synchronously check any excess errors with an approach like I showed above.",
        "> .subscribe()\r\n\r\nThere is a lint check for such use cases: https://bitbucket.org/littlerobots/rxlint",
        "Write a custom `Subscriber` that throws from its `onError` method and subscribe with that instead of the empty `subscribe()`.",
        "I'd say this use case has now a workaround with #5590 so closing it.",
        "Okay, let's see the proposed code changes.",
        "I did read that, but it doesn't really explain why it deals directly with the current thread's `UncaughtExceptionHandler` rather than just throwing if there's no `onError` hook set.\r\n\r\n@0kai I'm not trying to figure out how to test errors, rather I'm trying to make sure that uncaught exceptions in tests aren't marked as passing. At least not silently anyway",
        "I think I'm not being clear. I'm not trying to test if `onXXX` methods throw. I'm concerned that errors in the stream with no error handling don't actually fail tests because they're sent directly to the handler rather than just throwing if there's no plugin error handler. Trying to understand why we send directly to the handler.",
        "We just have a junit rule that installs an error hook via rxjava plugins that throws it",
        "This is actually a problem outside of tests too unfortunately. Say I'm on Android and I want to write a custom plugin for decorating observers (such as tracking analytics). I want to give the delegate observer a shot at `onError` and try/catch to react to how it handled it, but if it's the default rxjava execution and hands it over to the current thread's uncaught exception handler via its internal `uncaught()` method, the app will just quite immediately without the `catch` clause getting a chance.\r\n\r\nInstalling a custom error handler via plugins is not an option either, as it is just try/catch'd and pipes the error again through the above `uncaught()` pipeline.\r\n\r\nCould I propose making this configurable via system property? Something like `rx2.uncaughtBehavior` with values `\"default\"` and `\"rethrow\"`?\r\n\r\nEdit: Proposed a strawman impl in #5569",
        "https://github.com/uber/AutoDispose/blob/master/autodispose/src/test/java/com/uber/autodispose/RxErrorsRule.java",
        "^ for tests anyway. For prod, you can basically install an observer subscribe hook and watch for those interfaces",
        "I'd like to re-kick the proposal for a property or hook to configure this. While the workarounds of the errors rule for tests and `LambdaConsumerIntrospection` for runtime avoidance, there is actually a third case I've hit today that neither of them cover:\r\n\r\nSay you have a delegating observer, such as what we have in [AutoDispose](https://github.com/uber/AutoDispose/blob/master/autodispose/src/main/java/com/uber/autodispose/AutoDisposingObserverImpl.java). In an environment where the uncaught exception handler just calls `System.exit()` (i.e. Android), it becomes impossible to try-catch delegate `on____` calls if there is no error handling. Not only can the original exception not be caught, but neither can the `OnErrorNotImplementedException`, and there's nothing that can safely be done about it from the consumer standpoint.\r\n\r\nIn #5569 part of the discussion proposals was something like a `RxJavaPlugins.setOnErrorNotImplementedConsumer(Function<Consumer<Throwable>, Consumer<Throwable>>)`. Would you be open to that? Specifically, I think it's really important to be able to re-route something to ensure it doesn't hit the current `uncaught` path and thus becoming un-try-catchable",
        "PR opened: https://github.com/ReactiveX/RxJava/pull/6378",
        "you may use TestObserver to subscribe the result",
        "https://github.com/vRallev just solved this for us in a pretty clean way at Square: introduced a simple jvmAgent that sets up a default uncaught exception handler, and some gradle tweaking to make sure that our unit tests all depend on the module that puts the agent into effect.\r\n\r\nI plan to steal the technique for https://github.com/square/workflow, will try to remember to ping here when I do so.",
        "Permalink to the current version of `RxErrorsRule` for others: https://github.com/uber/AutoDispose/blob/6e1399512f132bc5052c4b1ba111debb6eb430e1/test-utils/src/main/java/com/uber/autodispose/test/RxErrorsRule.java",
        "We have a very similar issue.\r\n\r\nThe `Thread.UncaughtExceptionHandler` documentation states the following.\r\n\r\n> When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments.\r\n\r\nIf I understand this correctly, the direct `throw` will eventually pass the exception to `UncaughtExceptionHandler` anyway. It seems like the direct pass to `UncaughtExceptionHandler` without `throw` will not terminate the current thread. @akarnokd, was this a motivation for not rethrowing the error and using the direct pass to `UncaughtExceptionHandler`?\r\n\r\nMost likely this is not an issue for real-world environments, but this affects unit tests we run on JVM using JUnit.\r\n\r\n```kotlin\r\nimport org.junit.Test\r\nimport io.reactivex.Observable as RxJava2Observable\r\nimport rx.Observable as RxJava1Observable\r\n\r\nclass RxError {\r\n\r\n    @Test fun `RxJava 1 test failure with OnErrorNotImplementedException as\u00a0expected`() {\r\n        RxJava1Observable.fromCallable { throw RuntimeException() }.subscribe()\r\n    }\r\n\r\n    @Test fun `RxJava 2 test success, just prints OnErrorNotImplementedException stacktrace not as expected`() {\r\n        RxJava2Observable.fromCallable { throw RuntimeException() }.subscribe()\r\n    }\r\n\r\n}\r\n```\r\n\r\nCC @artem-zinnatullin ",
        "> What stacktrace did you expect?\r\n\r\nSorry for the poor wording. I meant that the expected behaviour from my side is to fail a test due to uncaught exception",
        "@hzsweers Just curious \u2014 how did you solve this issue on your side?",
        "Thanks for the Rule, @hzsweers. Not super cool to use something like this, but no choice. It's something."
    ],
    "5237": [
        "I just compared this to the `rx2` implementation. Both `Single` cases (sync/async) crash there. I'd like to know what's the correct behaviour. The documentation states:\r\n\r\n>A Single is something like an Observable, but instead of emitting a series of values \u2014 anywhere from none at all to an infinite number \u2014 it always **either** emits one value or an error notification.\r\n\r\n>A Single will call **only one** of these methods, and will only call it once. Upon calling either method, the Single terminates and the subscription to it ends.\r\n\r\nIs it ok to call `onError` when `onSuccess` was already called but fails? From an user perspective I want `onError` to be triggered but the documentation should be adjusted as well.",
        "When implementing the bugfix I think that a `SafeSingleSubscriber` wrapper would be the best solution. The same problem also happens when using `subscribe(Observer)`.\r\n\r\nCan you give me insights why a `SafeSingleSubscriber` doesn't exists and why `unsubscribe()` has to be called manually by the user as mentioned [here](https://github.com/ReactiveX/RxJava/pull/4716)? My implementation of `SafeSingleSubscriber` automatically calls `unsubscribe()` and fails the `SingleTest#isUnsubscribedAfterSuccess` test.",
        "Looks like the lambda-subscriber on Single.java:1777 needs some catch clauses. Would you like to submit a PR?",
        "No. The protocol states `onSuccess | onError`. If your `onSuccess` fails, it means your stream requires a `doOnSuccess` whose lambda can fail and you get an `onError` in the final consumer.",
        "> Can you give me insights why a `SafeSingleSubscriber` doesn't exists\r\n\r\nBecause nobody has written it.\r\n\r\n> why `unsubscribe()` has to be called manually\r\n\r\n`SingleSubscriber` is an abstract class which preserves its abstractness over `onSuccess` and `onError`. In order to call `unsubscribe` somebody has to hijack these calls either via a wrapper or defining another set of abstract methods as replacements. Neither option was implemented.",
        "Closing this as won't fix. We discussed in #5710 that changing this would have to prevent synchronous exceptions being thrown that could be relied upon by existing code.",
        "@passsy @akarnokd so there's no followup for this yet? It's strange that not all onSuccess/onNext exceptions consistently go to onError.",
        "Ah, I see `onNext ... onComplete | onError` vs `onSuccess | onError`, so `onSucccess` has the semantics of both `onNext` and `onComplete`, leading to tricky scenarios where the two semantics conflict, namely being called exclusively to `onError` or not.",
        "@TWiStErRob \r\n>The protocol states onSuccess | onError. If your onSuccess fails, it means your stream requires a doOnSuccess whose lambda can fail and you get an onError in the final consumer.\r\n\r\nWhich kind of makes sense since onSuccess | onError are terminal events and should be treated equally, otherwise an exception in onSuccess would call onError but one in onError would crash."
    ],
    "3394": [],
    "4600": [],
    "3744": [],
    "2548": [],
    "2583": [],
    "1806": [],
    "6903": [],
    "5103": [],
    "6533": [],
    "4766": [],
    "6141": [],
    "6650": [],
    "1107": [],
    "5590": [],
    "1072": [],
    "4874": [],
    "6735": [],
    "4046": [],
    "4136": [],
    "4151": [],
    "5064": [],
    "4593": [],
    "4595": [],
    "3226": [],
    "422": [],
    "1231": [],
    "4610": [],
    "2929": [],
    "4705": [],
    "6080": [],
    "163": [],
    "1581": [],
    "3635": [],
    "361": [],
    "1564": [],
    "1952": [],
    "1122": [],
    "6581": [],
    "331": [],
    "3931": [],
    "3362": [],
    "3553": [],
    "3934": [],
    "5906": [],
    "4381": [],
    "4060": [],
    "1026": [],
    "5382": [
        "@akarnokd : I've submitted my first PR fixing this -> https://github.com/ReactiveX/RxJava/pull/5409 Kindly review and advice. Thanks.",
        "Indeed there is no option for that in `Single` and `Maybe`. Would you like to submit a PR?",
        "Closing via #5409."
    ],
    "4279": [],
    "3340": [],
    "2880": [],
    "6831": [],
    "6737": [],
    "6238": [],
    "4964": [],
    "3680": [],
    "2472": [],
    "5412": [
        "Wrong expectation. If you know you have zero sources, you are using the wrong operator to trigger actions. You can pick `just`, `map` it and actually ignore the input value. If you don't know you have zero sources, you still have the option to switch to a non-empty source via `switchIfEmpty`.",
        "Yes, something along the line of this:\r\n\r\n> Providing an empty array/Iterable will result in an immediate completion without any calls to the provided combiner function.\r\n\r\nNote that there are several overloads to be considered in both `Flowable` and `Observable`.",
        "@akarnokd Well, OK, makes sense. It took me quite a while to track this one down. Do you think it should be included in the docs? I can document it and make pull request "
    ],
    "4262": [],
    "6029": [],
    "2866": [],
    "6522": [],
    "5429": [
        "Closing via #5430."
    ],
    "3824": [],
    "207": [],
    "6005": [],
    "5442": [
        "Huh, I thought implementing `Consumer` interface manually with correct nullability will help:\r\n\r\n```kotlin\r\nCompletable\r\n        .fromCallable {  }\r\n        .doOnEvent(object : Consumer<Throwable> {\r\n            override fun accept(t: Throwable?) { // Error: 'accept' overrides nothing\r\n                println(\"event: $t\")\r\n            }\r\n        })\r\n        .subscribe()\r\n```\r\n\r\nBut Kotlin compiler (1.1.3-eap34) does not even let such code to compile, so there is probably no clear way to solve this in Kotlin without using Java code.",
        "Removing the annotation from `Consumer` may affect all other places where it is not-null. Can you override the annotation somehow at the call site?\r\n\r\n@sakuna63 [BiConsumer](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/functions/BiConsumer.java#L29) doesn't have the annotations.",
        "Maybe RxKotlin has/could have workarounds for these. /cc @thomasnield",
        "If you can think you can resolve this with minimal changes, PR welcome.",
        "@akarnokd no, the problem cannot be remidied in kotlin which completely prevents the usage of that operator in kotlin. \r\nRemoving the annotation won't make it nullable though, it would just mean that we don't know the nullability status which is the case too. Why is it important to keep it? I see very little harm in removing it and as @svenjacobs said the contract is broken in java too. If I were to null check it in java I would probably get lint warning telling me to remove the null check.\r\nIdeally there should be multiple interfaces like @rharter suggested in the issue for BiFunction",
        "Ah, that explains why I just recently starting having problems.",
        "BiConsumer is also violated when using `Single#subscribe`. Either value or throwable will be null.",
        "Sorry, I read old source code. \r\nThe annotations have already been removed at https://github.com/ReactiveX/RxJava/pull/5257",
        "Is `doOnEvent` the only operator that needs a `Consumer` that accepts Nullable data? If so, why remove `@NonNull` which is fairly useful annotation for most of the other operators? Why not have a different, let's say, `Consumer2` specifically for doOnEvent and such operators?",
        "I just stumbled upon this while using Kotlin, too. However I wonder how a function argument annotated with `@NonNull` can ever be `null`? Even in Java this should be problematic as the contract is broken.",
        "This was introduced with #5023",
        "> Removing the annotation from Consumer may affect all other places where it is not-null. Can you override the annotation somehow at the call site?\r\n\r\n@akarnokd If there's just one call that passes `null` to the function then *imho* the argument must be annotated with `@Nullable` and not `@NonNull`. What's the point of `@NonNull` when it can be `null`?",
        "By the way this issue emerged with the release of Kotlin 1.1.3. Although `@NonNull` has already been added months ago it seems that the compiler/runtime library of Kotlin 1.1.3 became stricter in regards to nullability."
    ],
    "3498": [],
    "1862": [],
    "3214": [],
    "3398": [],
    "1507": [],
    "3120": [],
    "738": [],
    "1263": [],
    "1306": [],
    "765": [],
    "5468": [
        "Actually, it is supposed to be inside the `if (done) { } ` block. Would you like to submit a PR?",
        "Closing via #5470."
    ],
    "903": [],
    "3928": [],
    "5480": [
        "PR welcome.",
        "Closing via #5486."
    ],
    "4128": [],
    "3702": [],
    "4442": [],
    "116": [],
    "4183": [],
    "3814": [],
    "1911": [],
    "3567": [],
    "4299": [],
    "5524": [],
    "3832": [],
    "5705": [],
    "4410": [],
    "369": [],
    "265": [],
    "933": [],
    "3935": [],
    "5191": [],
    "3661": [],
    "1840": [],
    "964": [],
    "2982": [],
    "4338": [],
    "3764": [],
    "5544": [],
    "753": [],
    "6021": [],
    "3570": [],
    "4911": [],
    "6513": [],
    "4612": [],
    "4325": [],
    "6875": [],
    "4080": [],
    "3372": [],
    "2574": [],
    "3871": [],
    "5615": [],
    "4204": [],
    "6627": [],
    "6723": [],
    "3311": [],
    "1669": [],
    "2566": [],
    "726": [],
    "129": [],
    "5268": [],
    "3289": [],
    "5036": [],
    "1916": [],
    "6230": [],
    "5161": [],
    "1792": [],
    "3283": [],
    "4295": [],
    "1559": [],
    "4989": [],
    "6416": [],
    "3643": [],
    "5057": [],
    "1268": [],
    "528": [],
    "574": [],
    "4934": [],
    "536": [],
    "1012": [],
    "4092": [],
    "3638": [],
    "3154": [],
    "3689": [],
    "6002": [],
    "2776": [],
    "5889": [],
    "6541": [],
    "1145": [],
    "5255": [],
    "1519": [],
    "3563": [],
    "952": [],
    "1611": [],
    "2895": [],
    "3766": [],
    "6078": [],
    "723": [],
    "4777": [],
    "6266": [],
    "1126": [],
    "3705": [],
    "6715": [],
    "6771": [],
    "3247": [],
    "354": [],
    "5460": [],
    "3755": [],
    "6211": [],
    "3544": [],
    "6028": [],
    "3130": [],
    "643": [],
    "861": [],
    "1381": [],
    "3460": [],
    "1686": [],
    "4625": [],
    "5742": [
        "Indeed it is inconsistent with the other operators. Would you like to submit a PR? The [`MaybeFromCallable`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromCallable.java) should give a hint about the proper implementation.\r\n\r\nOtherwise, the NPE is due to the line `activity.setEmail(email);` where `activity` is null. Even if `isDisposed` would have been considered, there is a race between completion of the source and stopping the activity, thus you may end up with null `activity` anyway."
    ],
    "3487": [],
    "710": [],
    "4974": [],
    "951": [],
    "1771": [],
    "5609": [],
    "6534": [],
    "995": [],
    "1819": [],
    "5948": [],
    "2849": [],
    "999": [],
    "4298": [],
    "171": [],
    "425": [],
    "1282": [],
    "6901": [],
    "946": [],
    "4908": [],
    "1449": [],
    "2904": [],
    "427": [],
    "5653": [],
    "4549": [],
    "5809": [
        "Fix posted in #5811."
    ],
    "197": [],
    "5758": [],
    "3659": [],
    "4234": [],
    "1311": [],
    "5827": [
        "That's an unfortunate effect of the linked structure in `replay` and the facts that 1) discontinuity is not allowed and 2) observers subscribing concurrently should start somewhere.\r\n\r\nThat's why the `head` references a `Node` instance where the actual value is behind the `next` link. This way, observers can pick the head `Node` and when the time is right for them, start walking the links. Thus, a `replay(1)` will have two nodes with a previous node and one with the cached value. Nulling out the previous node doesn't work as `replay` can't know there isn't a late consumer still walking the links from a much earlier node.\r\n\r\nIf there wasn't any initial empty `Node`, observers would have to keep check somehow when the first item's `Node` gets created. Unfortunately, this potentially concurrent activity may lead to lost initial items for some observers.\r\n\r\nThe third option would be reference counting Nodes, which is very expensive and complicated.\r\n\r\nIf you need to cache the very latest, simply keep using the `BehaviorSubject`.",
        "PR welcome.",
        "There could be a less expensive approach by creating a fresh head node with link to the next cached item. This should allow late observers to capture the head node and follow the next links and the head would no longer reference the previous item:\r\n\r\n```java\r\n        void trim() {\r\n            if (size > maxSize) {\r\n                size--;\r\n                Node<Object> h = head.get();\r\n                Node<Object> n = new Node<Object>(null);\r\n                n.lazySet(h.get());\r\n                head = n;\r\n            }\r\n        }\r\n```\r\n\r\nThe drawback is that there is now two nodes allocated per upstream item.\r\n\r\nNote that there are 2 base type replays, 1 subject, 1 processor and 2 bounded replay modes, a total of 8 algorithms to adjust or document.",
        "Closing via #5828.",
        "Thanks for the explanation. I suspected along those lines.\r\n\r\nIf a fix isn't viable, I think this is worth documenting, as it's counter-intuitive."
    ],
    "4245": [],
    "205": [],
    "3103": [],
    "6364": [],
    "717": [],
    "1615": [],
    "5217": [],
    "4838": [],
    "6860": [],
    "1132": [],
    "1458": [],
    "5868": [
        ">Yeah, too bad it is marked stable in 1.x. Did somebody run into a signature problem?\r\n\r\nNope, I ran into a logic problem (that I created) while reviewing the old code for transfer to the new code. In short the operator uses the map to lookup an evicted GroupedObservable by key but if it has been evicted then you can't get the GroupedObservable to complete. I haven't looked closely at this yet and am not sure how the old tests were working but I'll report back on this.  The new 2.x method uses a map that is contracted to report evictions by value, not key. I imported the new 2.x tests into 1.x and two failed on 1.x till I applied the 2.x technique.\r\n\r\n>Deprecation but it should remain operational. Also I'd call the new method groupByEvictable or something like it, no version in method names.\r\n\r\nDeal. I'll deprecate and make sure the existing method doesn't do anything nasty (possible memory leak by not completing an evicted GroupedObservable) and I lean towards `groupByEvicting` for the new method.",
        "Yeah, too bad it is marked stable in 1.x. Did somebody run into a signature problem?\r\n\r\nDeprecation but it should remain operational. Also I'd call the new method `groupByEvictable` or something like it, no version in method names.",
        "Closing via #5917."
    ],
    "2972": [],
    "6539": [],
    "6632": [],
    "3304": [],
    "4424": [],
    "2981": [],
    "2953": [],
    "870": [],
    "2156": [],
    "1618": [],
    "4433": [],
    "1170": [],
    "3001": [],
    "6287": [],
    "4576": [],
    "5777": [],
    "5966": [],
    "6470": [],
    "852": [],
    "3434": [],
    "2837": [],
    "4852": [],
    "244": [],
    "5933": [
        "Thanks for the report, I'll fix tomorrow",
        "Yes, looks like eviction only happens when an upstream item is coming down. I think the same eviction logic could be run in `cancel()` as well:\r\n\r\n```java\r\n        @Override\r\n        public void cancel() {\r\n            // cancelling the main source means we don't want any more groups\r\n            // but running groups still require new values\r\n            if (cancelled.compareAndSet(false, true)) {\r\n\r\n                if (evictedGroups != null) {\r\n                    GroupedUnicast<K, V> evictedGroup;\r\n                    while ((evictedGroup = evictedGroups.poll()) != null) {\r\n                        evictedGroup.onComplete();\r\n                    }\r\n                }\r\n\r\n                if (groupCount.decrementAndGet() == 0) {\r\n                    s.cancel();\r\n                }\r\n            }\r\n        }\r\n```\r\n\r\n/cc @davidmoten ",
        "Sorry for the delay. I'll try to tackle this in the coming weeks."
    ],
    "4254": [],
    "797": [],
    "6433": [],
    "5944": [
        "Its equivalent is doOnDispose. A copy-paste error. PR welcome.",
        "@RomanWuattier You can start working on this.",
        "Closing via #5948.",
        "Hello,\r\nDoes someone work on this topic? I would like to start contributing, can I do it?"
    ],
    "4770": [],
    "882": [],
    "4839": [],
    "3477": [],
    "394": [],
    "4050": [],
    "3447": [],
    "689": [],
    "731": [],
    "5980": [
        "I don't know If this is still relevant, but I opened a PR for it, let me know if it helps",
        "In this case I'd consider making the fix with version 2.2"
    ],
    "3238": [],
    "3270": [],
    "365": [],
    "4110": [],
    "4732": [],
    "5984": [],
    "4730": [],
    "4130": [],
    "4441": [],
    "5332": [],
    "3177": [],
    "1375": [],
    "4108": [],
    "4226": [],
    "4720": [],
    "6303": [],
    "652": [],
    "6015": [
        "That's brilliant, thanks",
        "A question about fusion. I notice that `timeout(Long, TimeUnit)` doesn't support fusion and I suspect the operator I'm writing is similar. The problem is that a subscription is handed to downstream while the Single emission is being calculated and the resultant mapped Flowable is unknown. Just after the subscription is handed to downstream (via `onSubscribe`) `requestFusion` is called but of course at that point the fusion characteristics of the mapped Flowable is unknown and `QueueFuseable.NONE` is returned. \r\n\r\nShould I chase fusion for this operator? Any suggestions? ",
        "Righto, ta.",
        "Sure.",
        "In case you haven't started yet, you may want to wait for #6017 so the changes can be benchmarked.",
        "Fusion won't work here due to the delayed subscription to the Flowable. Don't bother with it."
    ],
    "2332": [],
    "1010": [],
    "1834": [],
    "230": [],
    "5541": [],
    "3963": [],
    "4375": [],
    "1715": [],
    "993": [],
    "3251": [],
    "5": [],
    "1701": [],
    "3205": [],
    "5577": [],
    "2827": [],
    "3849": [],
    "3278": [],
    "1514": [],
    "6528": [],
    "5466": [],
    "6452": [],
    "6304": [],
    "304": [],
    "1520": [],
    "3121": [],
    "5176": [],
    "6074": [],
    "1657": [],
    "1745": [],
    "5892": [],
    "5046": [],
    "1267": [],
    "3648": [],
    "3662": [],
    "5586": [],
    "3922": [],
    "1293": [],
    "3047": [],
    "1161": [],
    "6668": [],
    "4970": [],
    "6537": [],
    "6324": [],
    "5766": [],
    "5837": [],
    "5680": [],
    "5810": [],
    "5347": [],
    "6353": [],
    "5895": [],
    "1766": [],
    "6132": [
        "@ddunig2 Sure.",
        "Closed issues have a big red button indicating as such:\r\n\r\n![image](https://user-images.githubusercontent.com/1269832/69789744-6ccdac00-11c1-11ea-8eae-d62a01c5b05b.png)\r\n\r\nOtherwise, we don't have any good first issues at the moment. However, you could try and backport #6729 to the RxJava 2.x branch. Please consult a Git/Github tutorial if you don't know how to do things.",
        "You'd have to manually apply the changes in the source code of the 2.x branch as the files and locations do not match for an automatic backport.",
        "What are those errors? Which Eclipse version are you using?",
        "Install a Jdk 8 runtime and have Eclipse use it as a target:\r\n\r\n![image](https://user-images.githubusercontent.com/1269832/69976838-f49d1880-1529-11ea-9a5a-212f12838522.png)\r\n\r\n",
        "No.\r\n1. Check out the 2.x branch\r\n2. Create a new branch of of 2.x named `JavadocCleanup_1203`\r\n3. Open the [changed files](https://github.com/ReactiveX/RxJava/pull/6729/files) of #6729 in a browser \r\n4. For each file, expand the sections until you see the method name. For the first entry, it is `public final Single<Long> count() {`\r\n5. Locate this file and method in your IDE\r\n6. Apply the changes you see on the web page: remove lines or add lines\r\n7. Once done, make sure you have your own fork as remote in the Git repositories view under RxJava\r\n8. Add a commit message and commit the changes, and then push to your fork.\r\n9. Go to the PR page and wait for your branch to pop up to make a PR\r\n10. Make a PR and fill in some explanation about what you've done.",
        "Maybe you can start picking up these tasks to get familiar with making PRs to this repo @ddunig2",
        "@akarnokd  may I help contribute to this project?",
        "@akarnokd im not sure if this issue is closed or not but I am fairly new to GitHub contribution. If this happens to be closed, whats a good first issue on this project?",
        "@akarnokd Im somewhat familiar with GitHub. By backport do you mean committing the fixes in #6729 to the 2.x branch?",
        "@akarnokd I'm having trouble getting the project on my local machine without any errors. I forked and download it and wanted to make the changes on the eclipse IDE.  Any idea why that may be?",
        "@akarnokd Im using Eclipse-java 2019-09, java jdk13. The i just recloned it to check the issue and atm has no issue warning but when I run .\\gradlew build, it fails\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n* Where:\r\nSettings file 'C:\\Users\\lugdu\\Desktop\\GitHubContribution\\RxJava\\settings.gradle'\r\n\r\n* What went wrong:\r\nCould not compile settings file 'C:\\Users\\lugdu\\Desktop\\GitHubContribution\\RxJava\\settings.gradle'.\r\n> startup failed:\r\n  General error during semantic analysis: Unsupported class file major version 57\r\n\r\n  java.lang.IllegalArgumentException: Unsupported class file major version 57\r\n        at groovyjarjarasm.asm.ClassReader.<init>(ClassReader.java:184)\r\n        at groovyjarjarasm.asm.ClassReader.<init>(ClassReader.java:166)\r\n        at groovyjarjarasm.asm.ClassReader.<init>(ClassReader.java:152)\r\n        at groovyjarjarasm.asm.ClassReader.<init>(ClassReader.java:273)\r\n        at org.codehaus.groovy.ast.decompiled.AsmDecompiler.parseClass(AsmDecompiler.java:81)\r\n        at org.codehaus.groovy.control.ClassNodeResolver.findDecompiled(ClassNodeResolver.java:254)\r\n        at org.codehaus.groovy.control.ClassNodeResolver.tryAsLoaderClassOrScript(ClassNodeResolver.java:192)\r\n        at org.codehaus.groovy.control.ClassNodeResolver.findClassNode(ClassNodeResolver.java:172)\r\n        at org.codehaus.groovy.control.ClassNodeResolver.resolveName(ClassNodeResolver.java:128)\r\n        at org.codehaus.groovy.ast.decompiled.AsmReferenceResolver.resolveClassNullable(AsmReferenceResolver.java:59)\r\n        at org.codehaus.groovy.ast.decompiled.AsmReferenceResolver.resolveClass(AsmReferenceResolver.java:46)\r\n        at org.codehaus.groovy.ast.decompiled.AsmReferenceResolver.resolveNonArrayType(AsmReferenceResolver.java:81)\r\n        at org.codehaus.groovy.ast.decompiled.AsmReferenceResolver.resolveType(AsmReferenceResolver.java:72)\r\n        at org.codehaus.groovy.ast.decompiled.MemberSignatureParser.createMethodNode(MemberSignatureParser.java:55)\r\n        at org.codehaus.groovy.ast.decompiled.DecompiledClassNode.lazyInitMembers(DecompiledClassNode.java:195)\r\n        at org.codehaus.groovy.ast.decompiled.DecompiledClassNode.getDeclaredMethods(DecompiledClassNode.java:121)\r\n        at org.codehaus.groovy.ast.ClassNode.getMethods(ClassNode.java:912)\r\n        at org.codehaus.groovy.ast.ClassNode.tryFindPossibleMethod(ClassNode.java:1280)\r\n        at org.codehaus.groovy.control.StaticImportVisitor.transformMethodCallExpression(StaticImportVisitor.java:252)\r\n        at org.codehaus.groovy.control.StaticImportVisitor.transform(StaticImportVisitor.java:112)\r\n        at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitExpressionStatement(ClassCodeExpressionTransformer.java:144)\r\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)\r\n        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:110)\r\n        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:121)\r\n        at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitConstructorOrMethod(ClassCodeExpressionTransformer.java:55)\r\n        at org.codehaus.groovy.control.StaticImportVisitor.visitConstructorOrMethod(StaticImportVisitor.java:88)\r\n        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:128)\r\n        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1099)\r\n        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:54)\r\n        at org.codehaus.groovy.control.StaticImportVisitor.visitClass(StaticImportVisitor.java:82)\r\n        at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:717)\r\n        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1095)\r\n        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:649)\r\n        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:627)\r\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:604)\r\n        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:390)\r\n        at groovy.lang.GroovyClassLoader.access$300(GroovyClassLoader.java:89)\r\n        at groovy.lang.GroovyClassLoader$5.provide(GroovyClassLoader.java:330)\r\n        at groovy.lang.GroovyClassLoader$5.provide(GroovyClassLoader.java:327)\r\n        at org.codehaus.groovy.runtime.memoize.ConcurrentCommonCache.getAndPut(ConcurrentCommonCache.java:147)\r\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:325)\r\n        at org.gradle.groovy.scripts.internal.DefaultScriptCompilationHandler.compileScript(DefaultScriptCompilationHandler.java:133)\r\n",
        "@akarnokd  of great, I don't notice any errors. Now, I am on the 3x branch, Im not too familiar with backporting, would you be able to give me a quick guide as to what happens from here? So you mentioned that i would have to manually change the source code in the 2x branch to match the 3x branch, Can I get a little more detail. Am I changing the whole code or am I looking at a specific package?",
        "@akarnokd thank you that was fairly descriptive. The first change I see is the removal of the @see #count but nothing in the method itself. Is that what you are referring to?\r\n![pic](https://user-images.githubusercontent.com/36016544/70112974-52faf180-1625-11ea-9cf9-626c26528f39.JPG)\r\n",
        "@akarnokd  I made a PR!",
        "@akarnokd \r\nAn invalid link was found in the `Additional-Reading.md` file.\r\nCan I merge request a partial update?"
    ],
    "3169": [],
    "325": [],
    "4479": [],
    "408": [],
    "970": [],
    "4311": [],
    "942": [],
    "2575": [],
    "5344": [],
    "2969": [],
    "4268": [],
    "3360": [],
    "330": [],
    "5354": [],
    "245": [],
    "1957": [],
    "1401": [],
    "4574": [],
    "1069": [],
    "6173": [],
    "6683": [],
    "3250": [],
    "6178": [
        "> Is there any way around that? \r\n\r\nDo not crash into RxJava.\r\n\r\n> But comparing this clunky verbose call to the fromCallable above... uugh!\r\n\r\nAbstract it away into some utility function or class. Otherwise, it is the de-facto way for knowingly ignoring/logging an undeliverable exception gracefully.\r\n\r\n> `fromCallable(Callable)` could be extended to an optional second argument, indicating that `tryOnError` should be used or providing a custom `ExceptionHandler`?\r\n\r\nMaybe there could be an overload with a flag, but such overload would have to be added at least 10 more places. The nice thing about `fromCallable` is that being a static method, you can create your own implementation in some other class and use that.\r\n\r\nA custom `ExceptionHandler` is way unlike RxJava as it provides a second channel into an operator and what would you do other than ignoring or reporting the error, which the plugin handler already let's you do anonymously.\r\n\r\n> to have some possibility to inject a custom \r\n\r\nCan't see how this could work as I don't think this is composable.\r\n\r\n> document the post-disposed-behaviour a little more?\r\n\r\nPR welcome. We have **`Error handling`** sections [in some operators already](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#merge-java.lang.Iterable-). Please remember the other `fromCallable`s, `fromAction`s and `fromRunnable`s.\r\n\r\n> Final Bonus-Question: If I'd create a new library-function for some long-running algorithm..\r\n\r\nIs it affected by the error handling above. If yes, use `create(SingleOnSubscribe)`, otherwise try `Callable` and possibly check for interrupts.",
        "Thank you for your quick response.\r\n\r\nAs the RxJavaPlugins global ErrorHandler uses a Callable as callback, I don't think this would be too bad if it would be allowed locally in the same manner. Maybe I wouldn't do anything else than ignoring, but think the other way round: If I ignore just all undelivered Exceptions, I would miss maybe relevant ones, that I didn't expect. So I think it is important to be able to differentiate here.\r\n\r\nI have written a possible solution and filed a PR for that - but it would be necessary to extend that to other Classes (Observable, ...). Maybe it would be another solution to have an Operator like \"subscribeOn\", which configures the Scheduler - maybe \"handleUndeliverableException(Consumer)\"? But for the effort to do that, my knowledge of the internals isn't sufficient at the moment... But as I said above, this would be a solution to get grip on \"weird\" Exceptions, but to be able to handle them locally. If I just mute everything, I don't win anything. ;-)"
    ],
    "6179": [],
    "6121": [],
    "1452": [],
    "6195": [],
    "6196": [],
    "2989": [],
    "3799": [],
    "4835": [],
    "1400": [],
    "848": [],
    "4157": [],
    "6740": [],
    "1326": [],
    "1640": [],
    "3476": [],
    "4116": [],
    "6699": [],
    "804": [],
    "6609": [],
    "6183": [],
    "1030": [],
    "415": [],
    "4754": [],
    "4169": [],
    "6100": [],
    "2903": [],
    "5092": [],
    "1384": [],
    "5054": [],
    "5101": [],
    "1366": [],
    "5848": [],
    "6012": [],
    "3374": [],
    "5088": [],
    "6125": [],
    "106": [],
    "4220": [],
    "121": [],
    "6276": [
        "@dilantha111 Have you finished working on this?",
        "@dilantha111 Since I have finished some other issue as my first bug, I don't think its fair for me to take this up too. So leaving it open for others to take it.",
        "@akarnokd Sure David. Will take it up tomorrow.",
        "> Could you please give me some heads up ?\r\n\r\nNobody has started working on this yet so go ahead.",
        "@freakomonk Unfortunately, people are not lining up to work on issues right now so I suggest you do as much as you like and not worry about taking away opportunities.",
        "@thiyagu-7 Sure!",
        "Hi @akarnokd  I would like to start working on this. Could you please give me some heads up ? ",
        "@freakomonk  Nope. Just got some other things coming up. If you are willing to do that, please go ahead. At the moment stuck with some other stuffs. ",
        "@akarnokd I would like to work on this"
    ],
    "6279": [],
    "3787": [],
    "3696": [],
    "641": [],
    "3936": [],
    "4581": [],
    "5572": [],
    "515": [],
    "6288": [],
    "5155": [],
    "294": [],
    "1131": [],
    "1599": [],
    "1534": [],
    "855": [],
    "4088": [],
    "5294": [],
    "655": [],
    "4224": [],
    "5879": [],
    "4499": [],
    "6874": [],
    "1600": [],
    "6323": [
        "Indeed, many of the wiki pages remained from the early days where this repo was poliglot. You are welcome to turn them into Java (8) examples.",
        "@hoangnam2261 Sure!",
        "Closing via #6324",
        "Hello hello, can i take care this?"
    ],
    "4699": [],
    "2644": [],
    "1592": [],
    "4421": [],
    "1753": [],
    "1150": [],
    "883": [],
    "2238": [],
    "5087": [],
    "495": [],
    "2894": [],
    "6331": [
        "Hello, I've created a pr about this issue.",
        "java8......"
    ],
    "3388": [],
    "5738": [],
    "3815": [],
    "5824": [],
    "6680": [],
    "934": [],
    "3880": [],
    "490": [],
    "6355": [
        "Do you call `advanceTimeBy` anywhere?",
        "There are plenty of resources on the internet, such as [this](https://github.com/Froussios/Intro-To-RxJava/blob/master/Part%204%20-%20Concurrency/2.%20Testing%20Rx.md) that demonstrate `TestScheduler`. You can find other resources by searching for `RxJava TestScheduler` in your favorite search engine.",
        "Schedulers are orthogonal to flows, so conceptually it doesn't matter if you run a sequential or parallel flow with them.",
        "> even if there's no delay or interval in the code [...] That wouldn't be my first thought\r\n\r\n`TestScheduler` captures tasks scheduled by operators so that side-effects can be performed before the task then gets executed on demand via `advanceTimeBy`, even if they are logically not delayed. In reality, there is always some non-zero time elapsing between the scheduling and execution of such task. `TestScheduler` just makes it deterministic. \r\n\r\n> if you do that here, I'll be happy to send a PR for the docs.\r\n\r\nIf you wish to contribute, you could extend its [JavaDocs](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/schedulers/TestScheduler.java#L29) with the explicit mention of `advanceTimeBy` or even a short example.",
        "Nop, am I supposed to? I'm under the impression that the work only depends on availability of threads, and no delay is involved. Also, AFAIK, `TestScheduler` is single threaded, so all I'm expecting is the messages logged sequentially.",
        "There are exactly zero resources on the internet that demonstrate `TestScheduler` along with `parallel`. I couldn't find other resources for the same in my favorite search engine.",
        "Hmm, so `TestScheduler` doesn't start until the time is advanced, even if there's no delay or interval in the code (nothing that apparently involves \"time\"). That wouldn't be my first thought; perhaps you can add a note to the docs you linked to above to clarify this behavior, and why's it this way? Or, if you do that here, I'll be happy to send a PR for the docs.",
        "@akarnokd https://github.com/ReactiveX/RxJava/pull/6356"
    ],
    "6779": [],
    "4607": [],
    "6383": [],
    "3772": [],
    "4225": [],
    "6398": [],
    "6379": [
        "Okay, PR welcome.",
        "Nobody has started working on this to my knowledge. I suggest you do it either way so you gain experience with doing PRs as well as creating RxJava operators.",
        "@akarnokd, I would like to contribute to this feature, is this issue free to work on? However, even though it seems pretty straightforward, I'm new to this project and it may take some time for me to submit a final PR, is it acceptable? I don't want to block if it's an urgent need and can be done by somebody else in a faster manner. Thanks.",
        "Thanks for the tip. Will do."
    ],
    "1142": [],
    "3284": [],
    "1623": [],
    "1027": [],
    "5673": [],
    "6684": [],
    "168": [],
    "1754": [],
    "6785": [],
    "6097": [],
    "4682": [],
    "3551": [],
    "5141": [],
    "3293": [],
    "6402": [
        "Hello. You could write a small program to find it out and if there is a documentation mistake, you are welcome to post a PR.",
        "@RomanWuattier Nobody seems to work on this so you are welcome if you want.",
        "Closing via #5458.",
        "My test program (below) shows that the `n` argument does NOT include the initial attempt to subscribe, thus `retry( 10 )` gives a total of 11 subscriptions. \r\n\r\nThe easiest doc fix would be to change the large `retry(2)` in the marble diagram to `retry(1)` but I have no facility for doing that. (The Javadoc for `Single` doesn't include a marble diagram, but the text description is correct.) \r\n\r\n```\r\nDisposable retryDisp = Observable.error( new SocketTimeoutException() )\r\n\r\n                .doOnSubscribe( disp -> System.out.println( \"Subscribe count is now \" + ++subCount ) )\r\n\r\n                .doOnError( err -> System.out.println( \"Error count is now \" + ++errCount ) )\r\n\r\n                .retry( 10 )  // gives a total of 11 subscriptions & 11 errors\r\n\r\n                .subscribe(\r\n                        item -> System.out.println( \"We never see this\" ),\r\n                        err -> System.out.println( \"Without this we get a 'missing error handler' crash\" )\r\n                );\r\n```",
        "Does anyone work on this issue?\r\nAlso, the function parameter `times` is described as \"the number of times to repeat\" and could be mixed with the `repeat` operator. I think that's an opportunity to improve the Javadoc of `public final Observable<T> retry(long times, Predicate<? super Throwable> predicate)` at the same time."
    ],
    "5592": [],
    "5210": [],
    "4314": [],
    "1164": [],
    "345": [],
    "4239": [],
    "4087": [],
    "250": [],
    "2960": [],
    "869": [],
    "871": [],
    "1158": [],
    "862": [],
    "1295": [],
    "987": [],
    "2478": [],
    "6460": [
        "Closing via #6461"
    ],
    "3314": [],
    "3390": [],
    "6633": [],
    "5706": [],
    "774": [],
    "256": [],
    "181": [],
    "1969": [],
    "1892": [],
    "6479": [
        "Yes. PR welcome.",
        "Closing via #6480."
    ],
    "5785": [],
    "4019": [],
    "3232": [],
    "6481": [
        "PR welcome."
    ],
    "2936": [],
    "4755": [],
    "6017": [],
    "5240": [],
    "2554": [],
    "3034": [],
    "3573": [],
    "500": [],
    "3683": [],
    "1096": [],
    "4107": [],
    "4892": [],
    "1966": [],
    "5511": [],
    "235": [],
    "6857": [],
    "3777": [],
    "1433": [],
    "1965": [],
    "1644": [],
    "709": [],
    "622": [],
    "3032": [],
    "302": [],
    "5600": [],
    "4590": [],
    "4084": [],
    "6543": [
        "Closing via #6544"
    ],
    "5137": [],
    "2938": [],
    "1760": [],
    "919": [],
    "166": [],
    "3443": [],
    "6551": [
        "Yes, 3.x is a good place fix such ambiguities. My ideas are `onErrorResume(ObservableSource)` or `onErrorResumeWith(ObservableSource)`. PR welcome.",
        "> Do you want to change Maybe.onErrorResumeNext(MaybeSource) as well?\r\n\r\nYes, every class where `onErrorResumeNext` has a source type and a function.\r\n\r\n> To what should Observable.onErrorReturn(Function valueSupplier) be renamed?\r\n\r\nThere is no ambiguity there as the other is called `onErrorReturnItem`\r\n\r\n> Do you want to rename Maybe.onErrorReturn(Function valueSupplier) as well?\r\n\r\nThere is no ambiguity there either.\r\n\r\n> What about Single.onErrorReturn(Function resumeFunction)?\r\n\r\nThere is no ambiguity there either.\r\n\r\n> Is it ok to do all of this in the same PR?\r\n\r\nYou can rename multiple things within the same PR.",
        "Looks like an API mistake. You can change that too (and see if other places need fixing as well).",
        "Those names sound good to me. I believe the onErrorReturn should also be renamd then.",
        "A few questions:\r\n\r\n- Do you want to change `Maybe.onErrorResumeNext(MaybeSource)` as well? \r\n- To what should `Observable.onErrorReturn(Function valueSupplier)` be renamed? \r\n- Do you want to rename `Maybe.onErrorReturn(Function valueSupplier)` as well?\r\n- What about `Single.onErrorReturn(Function resumeFunction)?`\r\n- Is it ok to do all of this in the same PR?\r\n",
        "@akarnokd Thanks for the clarification. \r\n\r\nOut of curiosity, @vanniktech was there a reason besides ambiguity that made you suggest renaming the `onErrorReturn`s?",
        "@akarnokd Is there a reason `Single.onErrorResumeNext(final Single<? extends T> resumeSingleInCaseOfError)` takes a `Single` and not a `SingleSource` like the other methods? \r\n\r\nI've made the change and run all the tests for this method and all of them pass. \r\n\r\nIf there's no reason and it's ok with you I'd be happy to make the change since I'm in the area anyway. "
    ],
    "1608": [],
    "1412": [],
    "3827": [],
    "3349": [],
    "5926": [],
    "6705": [],
    "785": [],
    "4394": [],
    "6569": [
        "Thanks @akarnokd, so I'm suggesting we constrain upstream requests for:\r\n\r\n* `elementAt`\r\n* `elementAtOrError`\r\n* `first` (calls `elementAt`)\r\n* `firstOrError` (calls `elementAt`)\r\n* `take`\r\n* `single(default)`\r\n* `singleOrError`\r\n* `blockingSingle(default)` calls `single(default)`\r\n* `blockingSingle` (calls `singleOrError`)\r\n\r\n`limit` can then be an alias for `take`.\r\n\r\n>What about the lambda subscribe?\r\n\r\nYou've lost me, what are you referring to?\r\n\r\n\r\n",
        ">lambda subscribe requests max value.\r\n\r\nYes, that seems reasonable to me. Why would it be otherwise? ",
        "> There is no reason to have limit separately then.\r\n\r\nok by me",
        ">You were worrying about overrequesting over the network boundary. A straight subscribe would do that too for your case. I'm fine with it as is.\r\n\r\nI'm fine with it also.",
        "Would you like a PR for these changes? You are welcome to do it yourself if you want to, but I can help if useful.",
        "I'm happy to wait for #6589 before starting the PR",
        "Okay, let's make limit the default and change first/single. \r\n\r\nWhat about the lambda subscribe?",
        "There is no reason to have `limit` separately then.\r\n\r\n[lambda subscribe](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/Flowable.java#L14925) requests max value.",
        "You were worrying about overrequesting over the network boundary. A straight `subscribe` would do that too for your case. I'm fine with it as is.",
        "I'm still waiting for #6589 but you can go ahead and create a PR."
    ],
    "3641": [],
    "332": [],
    "6576": [
        "Yes, it should be `v == BlockingObserver.TERMINATED`. PR welcome."
    ],
    "6648": [],
    "509": [],
    "6371": [],
    "994": [],
    "4491": [],
    "1515": [],
    "1582": [],
    "6583": [
        "No problem, default 2-5 minutes should work. Travis kills the build if no standard output is happening for 10 minutes. Announce should create a log print often. Ignore should be reevaluated in place and deleted if no longer needed.",
        "Don't worry about them. Thanks for your diligent work!",
        "Hey, I see the interest having a global timeout in a base class. Please note that in Junit4, the timeout parameter on `@Test` annotation does not override the Timeout Rule. This can be an issue when a test requires a custom timeout.\r\nAlso, I don't understand the `announce` test. Do you expect every ignored test to be transferred in the class `RxJavaTest`?",
        "Thanks, I'll submit a PR.",
        "Hey,\r\nThere are a few remaining things to close the issue.\r\nFirst, I did not delete ignored tests for the fusion operator.\r\nSecond, I don't know what should be done to fix those non-deterministic and thread starvation tests:\r\n* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/observers/SerializedObserverTest.java#L263\r\n* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/observers/SerializedObserverTest.java#L353\r\n* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java#L265\r\n* https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/subscribers/SerializedSubscriberTest.java#L355\r\n\r\nAlso, I did not update Technology Compatibility Kit (TCK) tests."
    ],
    "6283": [],
    "3204": [],
    "6587": [
        "This is an issue with all `concatMap` variants and the fix looks like in #6572."
    ],
    "6357": [],
    "467": [],
    "3768": [],
    "6519": [],
    "1827": [],
    "3199": [],
    "1430": [],
    "6499": [],
    "1436": [],
    "184": [],
    "4167": [],
    "4484": [],
    "3310": [],
    "5052": [],
    "161": [],
    "5517": [],
    "5430": [],
    "2769": [],
    "206": [],
    "1272": [],
    "258": [],
    "150": [],
    "3391": [],
    "5296": [],
    "3677": [],
    "5847": [],
    "1195": [],
    "1769": [],
    "1409": [],
    "134": [],
    "201": [],
    "4091": [],
    "5811": [],
    "6060": [],
    "5842": [],
    "5449": [],
    "1288": [],
    "4846": [],
    "4285": [],
    "2563": [],
    "829": [],
    "5891": [],
    "4481": [],
    "837": [],
    "2649": [],
    "4648": [],
    "6671": [
        "Ah, yes, this happened to another project I'm vaguely involved with. Thankfully it's easily fixed. I should have a PR by the end of the week.",
        "> Tool: Bnd-4.2.0.201903051501\r\n\r\nGradle stopped supporting the OSGi plugin and this is what the suggested replacement, BND, does. I have no idea how to configure it.\r\n\r\nPR welcome.",
        "Closing via #6675"
    ],
    "2761": [],
    "384": [],
    "6042": [],
    "4833": [],
    "5127": [],
    "3426": [],
    "6152": [],
    "5918": [],
    "3285": [],
    "4237": [],
    "3237": [],
    "5007": [],
    "4310": [],
    "3439": [],
    "3937": [],
    "1286": [],
    "4388": [],
    "1912": [],
    "6783": [],
    "6052": [],
    "1529": [],
    "1528": [],
    "323": [],
    "2627": [],
    "231": [],
    "2992": [],
    "4143": [],
    "209": [],
    "3381": [],
    "1443": [],
    "5491": [],
    "6022": [],
    "541": [],
    "6753": [
        "Indeed the initial array for those has the wrong type. Would you like to post a PR?",
        "Sure! I can whip up a PR in a bit."
    ],
    "506": [],
    "896": [],
    "6168": [],
    "5568": [],
    "620": [],
    "2851": [],
    "1232": [],
    "4403": [],
    "4273": [],
    "4217": [],
    "1175": [],
    "4454": [],
    "1523": [],
    "3738": [],
    "471": [],
    "4074": [],
    "4323": [],
    "5670": [],
    "375": [],
    "3191": [],
    "1422": [],
    "6560": [],
    "5959": [],
    "1380": [],
    "4660": [],
    "2942": [],
    "3339": [],
    "3977": [],
    "3888": [],
    "2948": [],
    "561": [],
    "5870": [],
    "826": [],
    "4031": [],
    "5721": [],
    "5125": [],
    "5485": [],
    "930": [],
    "140": [],
    "111": [],
    "520": [],
    "438": [],
    "229": [],
    "4573": [],
    "5857": [],
    "3456": [],
    "4": [],
    "183": [],
    "6485": [],
    "289": [],
    "6618": [],
    "1922": [],
    "1460": [],
    "4305": [],
    "3856": [],
    "1960": [],
    "6335": [],
    "953": [],
    "5715": [],
    "6900": [],
    "2878": [],
    "5115": [],
    "271": [],
    "697": [],
    "5121": [],
    "1467": [],
    "693": [],
    "3822": [],
    "1926": [],
    "4622": [],
    "645": [],
    "4034": [],
    "4617": [],
    "3919": [],
    "3258": [],
    "615": [],
    "215": [],
    "3397": [],
    "5225": [],
    "6566": [],
    "4764": [],
    "3077": [],
    "5159": [],
    "453": [],
    "2902": [],
    "1113": [],
    "5030": [],
    "4895": [],
    "1884": [],
    "1055": [],
    "573": [],
    "2940": [],
    "3982": [],
    "712": [],
    "4849": [],
    "2447": [],
    "6486": [],
    "4659": [],
    "1573": [],
    "4881": [],
    "6572": [],
    "3429": [],
    "1540": [],
    "112": [],
    "1572": [],
    "928": [],
    "3631": [],
    "3468": [],
    "2543": [],
    "3513": [],
    "3462": [],
    "955": [],
    "3414": [],
    "976": [],
    "1830": [],
    "492": [],
    "1229": [],
    "6321": [],
    "3853": [],
    "3359": [],
    "6847": [],
    "1665": [],
    "5090": [],
    "4129": [],
    "2469": [],
    "338": [],
    "6710": [],
    "1605": [],
    "1350": [],
    "3023": [],
    "6577": [],
    "834": [],
    "5904": [],
    "355": [],
    "4951": [],
    "1071": [],
    "5212": [],
    "4676": [],
    "5723": [],
    "5799": [],
    "1736": [],
    "972": [],
    "3286": [],
    "6754": [],
    "960": [],
    "3569": [],
    "1226": [],
    "1101": [],
    "5893": [],
    "3444": [],
    "2546": [],
    "5871": [],
    "5937": [],
    "1133": [],
    "2907": [],
    "1379": [],
    "3797": [],
    "3093": [],
    "1097": [],
    "5979": [],
    "2632": [],
    "5253": [],
    "5033": [],
    "6482": [],
    "6594": [],
    "603": [],
    "5059": [],
    "4307": [],
    "274": [],
    "268": [],
    "6893": [],
    "6258": [],
    "5027": [],
    "5123": [],
    "6505": [],
    "4639": [],
    "3668": [],
    "1473": [],
    "1423": [],
    "3186": [],
    "6278": [],
    "1428": [],
    "3039": [],
    "1117": [],
    "2610": [],
    "1721": [],
    "1494": [],
    "2": [],
    "1086": [],
    "267": [],
    "3752": [],
    "938": [],
    "3208": [],
    "6436": [],
    "5434": [],
    "4126": [],
    "5745": [],
    "1294": [],
    "3089": [],
    "975": [],
    "6346": [],
    "3018": [],
    "4188": [],
    "3215": [],
    "3590": [],
    "2993": [],
    "6174": [],
    "6136": [],
    "6026": [],
    "4641": [],
    "3380": [],
    "3614": [],
    "3905": [],
    "3454": [],
    "3195": [],
    "475": [],
    "5756": [],
    "5816": [],
    "1079": [],
    "1524": [],
    "4293": [],
    "4165": [],
    "1181": [],
    "5196": [],
    "699": [],
    "5571": [],
    "4483": [],
    "715": [],
    "316": [],
    "866": [],
    "2804": [],
    "5353": [],
    "6882": [],
    "4868": [],
    "597": [],
    "3261": [],
    "743": [],
    "2951": [],
    "2572": [],
    "4131": [],
    "2771": [],
    "4303": [],
    "4482": [],
    "362": [],
    "5833": [],
    "6019": [],
    "1367": [],
    "6652": [],
    "4708": [],
    "2886": [],
    "4368": [],
    "5977": [],
    "133": [],
    "3517": [],
    "660": [],
    "4522": [],
    "4667": [],
    "6193": [],
    "3352": [],
    "3474": [],
    "3943": [],
    "2550": [],
    "5226": [],
    "3647": [],
    "3722": [],
    "149": [],
    "6054": [],
    "5858": [],
    "4349": [],
    "6129": [],
    "1165": [],
    "4540": [],
    "6604": [],
    "6538": [],
    "4105": [],
    "6116": [],
    "1530": [],
    "3549": [],
    "6871": [],
    "1720": [],
    "272": [],
    "3809": [],
    "5181": [],
    "3781": [],
    "4478": [],
    "3470": [],
    "638": [],
    "611": [],
    "5407": [],
    "6036": [],
    "3181": [],
    "6497": [],
    "5919": [],
    "281": [],
    "5076": [],
    "4187": [],
    "3279": [],
    "700": [],
    "4932": [],
    "2813": [],
    "5951": [],
    "6105": [],
    "3123": [],
    "1385": [],
    "6682": [],
    "5645": [],
    "2838": [],
    "4554": [],
    "612": [],
    "6761": [],
    "5419": [],
    "3335": [],
    "3194": [],
    "1601": [],
    "983": [],
    "450": [],
    "6104": [],
    "3499": [],
    "3436": [],
    "6556": [],
    "3486": [],
    "936": [],
    "263": [],
    "922": [],
    "6810": [],
    "513": [],
    "984": [],
    "5985": [],
    "3897": [],
    "4527": [],
    "3189": [],
    "6510": [],
    "3355": [],
    "504": [],
    "4966": [],
    "6588": [],
    "6269": [],
    "1068": [],
    "4763": [],
    "2547": [],
    "3065": [],
    "5530": [],
    "3965": [],
    "107": [],
    "3206": [],
    "3449": [],
    "1627": [],
    "5718": [],
    "1750": [],
    "6700": [],
    "4191": [],
    "223": [],
    "760": [],
    "4518": [],
    "4982": [],
    "4231": [],
    "3275": [],
    "5760": [],
    "6640": [],
    "1362": [],
    "6664": [],
    "3941": [],
    "2987": [],
    "1008": [],
    "2921": [],
    "3675": [],
    "240": [],
    "2883": [],
    "269": [],
    "2996": [],
    "4710": [],
    "1283": [],
    "3052": [],
    "1271": [],
    "1442": [],
    "4001": [],
    "4288": [],
    "607": [],
    "5102": [],
    "5885": [],
    "3588": [],
    "3138": [],
    "5310": [],
    "6788": [],
    "476": [],
    "3475": [],
    "1742": [],
    "6378": [],
    "434": [],
    "698": [],
    "3361": [],
    "6899": [],
    "5005": [],
    "1770": [],
    "6134": [],
    "455": [],
    "4672": [],
    "6267": [],
    "1570": [],
    "3292": [],
    "2914": [],
    "6790": [],
    "5136": [],
    "5960": [],
    "3950": [],
    "4418": [],
    "917": [],
    "226": [],
    "651": [],
    "2831": [],
    "3377": [],
    "501": [],
    "6070": [],
    "1239": [],
    "414": [],
    "4496": [],
    "174": [],
    "4636": [],
    "4536": [],
    "341": [],
    "452": [],
    "402": [],
    "4215": [],
    "6010": [],
    "4081": [],
    "5062": [],
    "6260": [],
    "3223": [],
    "1719": [],
    "1695": [],
    "1499": [],
    "1955": [],
    "6769": [],
    "5222": [],
    "4379": [],
    "6076": [],
    "6921": [],
    "4453": [],
    "4502": [],
    "179": [],
    "3137": [],
    "5119": [],
    "5213": [],
    "1968": [],
    "6897": [],
    "5695": [],
    "2861": [],
    "3848": [],
    "6365": [],
    "4519": [],
    "1747": [],
    "635": [],
    "514": [],
    "3825": [],
    "3671": [],
    "131": [],
    "3370": [],
    "1548": [],
    "4668": [],
    "458": [],
    "569": [],
    "4398": [],
    "1521": [],
    "3320": [],
    "6692": [],
    "1325": [],
    "1005": [],
    "877": [],
    "5023": [],
    "4213": [],
    "5683": [],
    "1163": [],
    "2243": [],
    "3589": [],
    "266": [],
    "4042": [],
    "1775": [],
    "5287": [],
    "649": [],
    "132": [],
    "4466": [],
    "178": [],
    "836": [],
    "5043": [],
    "621": [],
    "538": [],
    "5955": [],
    "125": [],
    "5995": [],
    "6732": [],
    "4627": [],
    "4654": [],
    "4068": [],
    "6526": [],
    "529": [],
    "4432": [],
    "3717": [],
    "3366": [],
    "6791": [],
    "3515": [],
    "1058": [],
    "6637": [],
    "6053": [],
    "2864": [],
    "5755": [],
    "5981": [],
    "5986": [],
    "5170": [],
    "4172": [],
    "6711": [],
    "3056": [],
    "6356": [],
    "3480": [],
    "2971": [],
    "113": [],
    "321": [],
    "5781": [],
    "2455": [],
    "4669": [],
    "5507": [],
    "959": [],
    "920": [],
    "2915": [],
    "3886": [],
    "5709": [],
    "6461": [],
    "3496": [],
    "4452": [],
    "6877": [],
    "213": [],
    "279": [],
    "3688": [],
    "6064": [],
    "349": [],
    "4372": [],
    "1083": [],
    "5247": [],
    "6297": [],
    "859": [],
    "5998": [],
    "6843": [],
    "3949": [],
    "4014": [],
    "122": [],
    "5655": [],
    "6657": [],
    "1565": [],
    "4036": [],
    "1162": [],
    "3345": [],
    "5856": [],
    "747": [],
    "822": [],
    "6047": [],
    "1758": [],
    "1084": [],
    "4241": [],
    "4282": [],
    "1417": [],
    "1589": [],
    "788": [],
    "4992": [],
    "606": [],
    "1459": [],
    "850": [],
    "4090": [],
    "3665": [],
    "2629": [],
    "4463": [],
    "1562": [],
    "2956": [],
    "6756": [],
    "4083": [],
    "1291": [],
    "908": [],
    "1656": [],
    "1178": [],
    "4246": [],
    "305": [],
    "4987": [],
    "6635": [],
    "4045": [],
    "1087": [],
    "228": [],
    "4030": [],
    "1626": [],
    "1118": [],
    "734": [],
    "783": []
}